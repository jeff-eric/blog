<!-- build time:Tue Nov 26 2019 14:32:24 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-CN,zh-HK,zh-TW,en,default"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/han-css@3/dist/han.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css"><link rel="stylesheet" href="/blog/css/main.css?v=7.0.1"><link rel="apple-touch-icon" sizes="180x180" href="/blog/uploads/avatar.jpg?v=7.0.1"><link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/avatar.jpg?v=7.0.1"><link rel="icon" type="image/png" sizes="16x16" href="/blog/blog/uploads/avatar.jpg?v=7.0.1"><link rel="mask-icon" href="/blog/uploads/avatar.jpg?v=7.0.1" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/blog/",scheme:"Gemini",version:"7.0.1",sidebar:{position:"left",display:"always",offset:12,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!0,fancybox:!0,fastclick:!0,lazyload:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta property="og:type" content="website"><meta property="og:title" content="纯天然绿色学渣"><meta property="og:url" content="https:&#x2F;&#x2F;jeff-eric.github.com&#x2F;blog&#x2F;index.html"><meta property="og:site_name" content="纯天然绿色学渣"><meta property="og:locale" content="zh-CN"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://jeff-eric.github.com/blog/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>纯天然绿色学渣</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?bb5d4f8207d7c2bd1aa936180430bbaa";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/blog/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">纯天然绿色学渣</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-home&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;首页</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-tags&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;标签&lt;span class=&quot;badge&quot;&gt;28&lt;&#x2F;span&gt;</a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-th&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;分类&lt;span class=&quot;badge&quot;&gt;12&lt;&#x2F;span&gt;</a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-archive&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;归档&lt;span class=&quot;badge&quot;&gt;42&lt;&#x2F;span&gt;</a></li><li class="menu-item menu-item-tools"><a href="/blog/tools/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-tree&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;工具</a></li><li class="menu-item menu-item-search"><a href="javascript:;" target="_blank" rel="noopener" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jeff-eric.github.com/blog/blog/2019/10/24/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jeff-Eric"><meta itemprop="description" content=""><meta itemprop="image" content="/blog/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="纯天然绿色学渣"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/blog/2019/10/24/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">AbstractQueuedSynchronizer 原理分析 - 独占&#x2F;共享模式</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-24 14:13:00" itemprop="dateCreated datePublished" datetime="2019-10-24T14:13:00+08:00">2019-10-24</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-10-25 19:03:50" itemprop="dateModified" datetime="2019-10-25T19:03:50+08:00">2019-10-25</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/blog/2019/10/24/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/2019/10/24/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/" itemprop="commentCount"></span> </a></span><span id="/blog/2019/10/24/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/" class="leancloud_visitors" data-flag-title="AbstractQueuedSynchronizer 原理分析 - 独占/共享模式"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body han-init-context" itemprop="articleBody"><h1><a id="_1"></a>概念</h1><p>AbstractQueuedSynchronizer （抽象队列同步器，简称 AQS），AQS 是很多同步器的基础框架，比如 ReentrantLock、CountDownLatch 和 Semaphore 等都是基于 AQS 实现的。除此之外，我们还可以基于 AQS，定制出我们所需要的同步器。</p><h1><a id="_4"></a>原理</h1><p>在 AQS 内部，通过维护一个FIFO 队列来管理多线程的排队工作。在公平竞争的情况下，无法获取同步状态的线程将会被封装成一个节点，置于队列尾部。入队的线程将会通过自旋的方式获取同步状态，若在有限次的尝试后，仍未获取成功，线程则会被阻塞住。大致示意图如下：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191024151919.png" alt></p><p>当头结点释放同步状态后，且后继节点对应的线程被阻塞，此时头结点线程将会去唤醒后继节点线程。后继节点线程恢复运行并获取同步状态后，会将旧的头结点从队列中移除，并将自己设为头结点。大致示意图如下：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191024152033.png" alt></p><h1><a id="_11"></a>常用方法</h1><p>主要介绍三组重要的方法，通过使用这三组方法即可实现一个同步组件。<br>第一组方法是用于访问/设置同步状态的，如下：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>int getState()</td><td>设置同步状态</td></tr><tr><td>void setState()</td><td>设置同步状态</td></tr><tr><td>boolean compareAndSetState(int expect, int update)</td><td>通过 CAS 设置同步状态</td></tr></tbody></table><p>第二组方<font color="red">需要由同步组件覆写</font>。如下：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean tryAcquire(int arg)</td><td>独占式获取同步状态</td></tr><tr><td>boolean tryRelease(int arg)</td><td>独占式释放同步状态</td></tr><tr><td>int tryAcquireShared(int arg)</td><td>共享式获取同步状态</td></tr><tr><td>boolean tryReleaseShared(int arg)</td><td>共享式私房同步状态</td></tr><tr><td>boolean isHeldExclusively()</td><td>检测当前线程是否获取独占锁</td></tr></tbody></table><p>第三组方法是一组模板方法，同步组件可直接调用。如下：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void acquire(int arg)</td><td>独占式获取同步状态，该方法将会调用 tryAcquire 尝试获取同步状态。获取成功则返回，获取失败，线程进入同步队列等待。</td></tr><tr><td>void acquireInterruptibly(int arg)</td><td>响应中断版的 acquire</td></tr><tr><td>boolean tryAcquireNanos(int arg,long nanos)</td><td>超时+响应中断版的 acquire</td></tr><tr><td>void acquireShared(int arg)</td><td>共享式获取同步状态，同一时刻可能会有多个线程获得同步状态。比如读写锁的读锁就是就是调用这个方法获取同步状态的。</td></tr><tr><td>void acquireSharedInterruptibly(int arg)</td><td>响应中断版的 acquireShared</td></tr><tr><td>boolean tryAcquireSharedNanos(int arg,long nanos)</td><td>超时+响应中断版的 acquireShared</td></tr><tr><td>boolean release(int arg)</td><td>独占式释放同步状态</td></tr><tr><td>boolean releaseShared(int arg)</td><td>共享式释放同步状态</td></tr></tbody></table><p>上面列举了一堆方法，看似繁杂。但稍微理一下，就会发现上面诸多方法无非就两大类：一类是独占式获取和释放独占状态，另一类是共享式获取和释放同步状态。</p><h1><a id="_46"></a>源码</h1><h2><a id="_47"></a><a class="header-anchor" href="#线程队列节点结构">¶</a>线程队列节点结构</h2><p>在并发的情况下，AQS 会将未获取同步状态的线程将会封装成节点，并将其放入同步队列尾部。同步队列中的节点除了要保存线程，还要保存等待状态。不管是独占式还是共享式，在获取状态失败时都会用到节点类。所以这里我们要先看一下节点类的实现，为后面的源码分析进行简单铺垫。源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line"></span><br><span class="line">    /** 共享类型节点，标记节点在共享模式下等待 */</span><br><span class="line">    static final Node SHARED = new Node();</span><br><span class="line">    </span><br><span class="line">    /** 独占类型节点，标记节点在独占模式下等待 */</span><br><span class="line">    static final Node EXCLUSIVE = null;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 这里的状态，我的个人理解是，对下一个对象的操作行为</span><br><span class="line">     * 如果是CANCELLED 表示：当前线程已经释放锁</span><br><span class="line">     * 如果是0（默认状态） 表示：下一个线程正在运行中，不需要唤醒</span><br><span class="line">     * 如果是SIANAL、CONDITION、propagate 表示：线程正在等待中，需要前节点释放同步状态后，来唤醒</span><br><span class="line">     */</span><br><span class="line">    /** 当前线程取消竞争 */</span><br><span class="line">    static final int CANCELLED =  1;</span><br><span class="line">    </span><br><span class="line">    /** </span><br><span class="line">     * 后置节点等待被唤醒 </span><br><span class="line">     */</span><br><span class="line">    static final int SIGNAL    = -1;</span><br><span class="line">    </span><br><span class="line">    /** 条件等待。表明节点等待在 Condition 上 */</span><br><span class="line">    static final int CONDITION = -2;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 和共享有关  </span><br><span class="line">     */</span><br><span class="line">    static final int PROPAGATE = -3;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 等待状态，取值如下：</span><br><span class="line">     *   SIGNAL,</span><br><span class="line">     *   CANCELLED,</span><br><span class="line">     *   CONDITION,</span><br><span class="line">     *   PROPAGATE,</span><br><span class="line">     *   0</span><br><span class="line">     * </span><br><span class="line">     * 初始情况下，waitStatus = 0</span><br><span class="line">     */</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 前驱节点</span><br><span class="line">     */</span><br><span class="line">    volatile Node prev;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 后继节点</span><br><span class="line">     */</span><br><span class="line">    volatile Node next;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 对应的线程</span><br><span class="line">     */</span><br><span class="line">    volatile Thread thread;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 下一个等待节点，和condition 有关，用在 ConditionObject 中</span><br><span class="line">     */</span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断节点是否是共享节点</span><br><span class="line">     */</span><br><span class="line">    final boolean isShared() &#123;</span><br><span class="line">        return nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // CLH队列的头结点，其不包含线程信息，head永远为null</span><br><span class="line">    private transient volatile Node head;</span><br><span class="line">    </span><br><span class="line">    // CLH队列的尾节点，每次新加一个节点都会尾插到最后</span><br><span class="line">    private transient volatile Node tail;</span><br><span class="line">    </span><br><span class="line">    // 当前锁被占据的次数，因为可以被一个线程重复占据，所以其值可以大于0</span><br><span class="line">    // 没有线程占据，其值就是0</span><br><span class="line">    private volatile int state;</span><br><span class="line">    </span><br><span class="line">    // 当前运行的线程，也是占据锁的线程，注意和CLH中的线程无关</span><br><span class="line">    private transient Thread exclusiveOwnerThread; </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取前驱节点</span><br><span class="line">     */</span><br><span class="line">    final Node predecessor() throws NullPointerException &#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        if (p == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        else</span><br><span class="line">            return p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    // Used to establish initial head or SHARED marker</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** addWaiter 方法会调用该构造方法 */</span><br><span class="line">    Node(Thread thread, Node mode) &#123;</span><br><span class="line">        this.nextWaiter = mode;</span><br><span class="line">        this.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Condition 中会用到此构造方法 */</span><br><span class="line">    Node(Thread thread, int waitStatus) &#123; // Used by Condition</span><br><span class="line">        this.waitStatus = waitStatus;</span><br><span class="line">        this.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><a id="_51"></a><a class="header-anchor" href="#独占模式">¶</a>独占模式</h2><h3><a id="_52"></a><a class="header-anchor" href="#获取同步状态">¶</a>获取同步状态</h3><p>独占式获取同步状态时通过 acquire 进行的，下面来分析一下该方法的源码。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 该方法将会调用子类复写的 tryAcquire 方法获取同步状态，</span><br><span class="line"> * - 获取成功：直接返回</span><br><span class="line"> * - 获取失败：将线程封装在节点中，并将节点置于同步队列尾部，</span><br><span class="line"> *     通过自旋尝试获取同步状态。如果在有限次内仍无法获取同步状态，</span><br><span class="line"> *     该线程将会被 LockSupport.park 方法阻塞住，直到被前驱节点唤醒</span><br><span class="line"> * arg 是一个扩展字段，或者说是调用发的一个信号量    </span><br><span class="line"> */</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 向同步队列尾部添加一个节点 */</span><br><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">    // 尝试以快速方式将节点添加到队列尾部</span><br><span class="line">    // tail是当前队列的尾部</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    if (pred != null) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        // 使用cas(乐观锁), 保证队列的更新</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 快速插入节点失败，调用 enq 方法，不停的尝试插入节点</span><br><span class="line">    // 初始化 或者 等待cas结果的一致</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 通过 CAS + 自旋的方式插入节点到队尾</span><br><span class="line"> */</span><br><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        if (t == null) &#123; // Must initialize</span><br><span class="line">            // 设置头结点，初始情况下，头结点是一个空节点</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 将节点插入队列尾部。这里是先将新节点的前驱设为尾节点，之后在尝试将新节点设为尾节</span><br><span class="line">             * 点，最后再将原尾节点的后继节点指向新的尾节点。除了这种方式，我们还先设置尾节点，</span><br><span class="line">             * 之后再设置前驱和后继，即：</span><br><span class="line">             * </span><br><span class="line">             *    if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">             *        node.prev = t;</span><br><span class="line">             *        t.next = node;</span><br><span class="line">             *    &#125;</span><br><span class="line">             *    </span><br><span class="line">             * 但如果是这样做，会导致一个问题，即短时内，队列结构会遭到破坏。考虑这种情况，</span><br><span class="line">             * 某个线程在调用 compareAndSetTail(t, node)成功后，该线程被 CPU 切换了。此时</span><br><span class="line">             * 设置前驱和后继的代码还没带的及执行，但尾节点指针却设置成功，导致队列结构短时内会</span><br><span class="line">             * 出现如下情况：</span><br><span class="line">             *</span><br><span class="line">             *      +------+  prev +-----+       +-----+</span><br><span class="line">             * head |      | &lt;---- |     |       |     |  tail</span><br><span class="line">             *      |      | ----&gt; |     |       |     |</span><br><span class="line">             *      +------+ next  +-----+       +-----+</span><br><span class="line">             *</span><br><span class="line">             * tail 节点完全脱离了队列，这样导致一些队列遍历代码出错。如果先设置</span><br><span class="line">             * 前驱，在设置尾节点。及时线程被切换，队列结构短时可能如下：</span><br><span class="line">             *</span><br><span class="line">             *      +------+  prev +-----+ prev  +-----+</span><br><span class="line">             * head |      | &lt;---- |     | &lt;---- |     |  tail</span><br><span class="line">             *      |      | ----&gt; |     |       |     |</span><br><span class="line">             *      +------+ next  +-----+       +-----+</span><br><span class="line">             *      </span><br><span class="line">             * 这样并不会影响从后向前遍历，不会导致遍历逻辑出错。</span><br><span class="line">             * </span><br><span class="line">             * 参考：</span><br><span class="line">             *    https://www.cnblogs.com/micrari/p/6937995.html</span><br><span class="line">             */</span><br><span class="line">             // 这个代码细节写的very/very/very good， 很精妙</span><br><span class="line">            node.prev = t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 同步队列中的线程在此方法中以循环尝试获取同步状态，在有限次的尝试后，</span><br><span class="line"> * 若仍未获取锁，线程将会被阻塞，直至被前驱节点的线程唤醒。</span><br><span class="line"> */</span><br><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        // 循环获取同步状态</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            /*</span><br><span class="line">             * 前驱节点如果是头结点，表明前驱节点已经获取了同步状态。前驱节点释放同步状态后，</span><br><span class="line">             * 在不出异常的情况下， tryAcquire(arg) 应返回 true。此时节点就成功获取了同</span><br><span class="line">             * 步状态，并将自己设为头节点，原头节点出队。</span><br><span class="line">             */ </span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                // 成功获取同步状态，设置自己为头节点</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = null; // help GC</span><br><span class="line">                failed = false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            /*</span><br><span class="line">             * 如果获取同步状态失败，则根据条件判断是否应该阻塞自己。</span><br><span class="line">             * 如果不阻塞，CPU 就会处于忙等状态，这样会浪费 CPU 资源</span><br><span class="line">             */</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 如果在获取同步状态中出现异常，failed = true，cancelAcquire 方法会被执行。</span><br><span class="line">         * tryAcquire 需同步组件开发者覆写，难免不了会出现异常。</span><br><span class="line">         */</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 设置头节点 */</span><br><span class="line">private void setHead(Node node) &#123;</span><br><span class="line">    // 仅有一个线程可以成功获取同步状态，所以这里不需要进行同步控制</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = null;</span><br><span class="line">    node.prev = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 该方法主要用途是，当线程在获取同步状态失败时，根据前驱节点的等待状态，决定后续的动作。比如前驱</span><br><span class="line"> * 节点等待状态为 SIGNAL，表明当前节点线程应该被阻塞住了。不能老是尝试，避免 CPU 忙等。</span><br><span class="line"> *    —————————————————————————————————————————————————————————————————</span><br><span class="line"> *    | 前驱节点等待状态 |                   相应动作                     |</span><br><span class="line"> *    —————————————————————————————————————————————————————————————————</span><br><span class="line"> *    | SIGNAL         | 阻塞                                          |</span><br><span class="line"> *    | CANCELLED      | 向前遍历, 移除前面所有为该状态的节点               |</span><br><span class="line"> *    | waitStatus &lt; 0 | 将前驱节点状态设为 SIGNAL, 并再次尝试获取同步状态   |</span><br><span class="line"> *    —————————————————————————————————————————————————————————————————</span><br><span class="line"> */</span><br><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    int ws = pred.waitStatus;</span><br><span class="line">    /* </span><br><span class="line">     * 前驱节点等待状态为 SIGNAL，表示当前线程应该被阻塞。</span><br><span class="line">     * 线程阻塞后，会在前驱节点释放同步状态后被前驱节点线程唤醒</span><br><span class="line">     */</span><br><span class="line">    if (ws == Node.SIGNAL)</span><br><span class="line">        return true;</span><br><span class="line">        </span><br><span class="line">    /*</span><br><span class="line">     * 前驱节点等待状态为 CANCELLED，则以前驱节点为起点向前遍历，</span><br><span class="line">     * 移除其他等待状态为 CANCELLED 的节点。</span><br><span class="line">     */ </span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">        do &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 等待状态为 0 或 PROPAGATE，设置前驱节点等待状态为 SIGNAL，</span><br><span class="line">         * 并再次尝试获取同步状态。</span><br><span class="line">         */</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    // 调用 LockSupport.park 阻塞自己</span><br><span class="line">    LockSupport.park(this);</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 取消获取同步状态</span><br><span class="line"> */</span><br><span class="line">private void cancelAcquire(Node node) &#123;</span><br><span class="line">    if (node == null)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    node.thread = null;</span><br><span class="line"></span><br><span class="line">    // 前驱节点等待状态为 CANCELLED，则向前遍历并移除其他为该状态的节点</span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    while (pred.waitStatus &gt; 0)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    // 记录 pred 的后继节点，后面会用到</span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    // 将当前节点等待状态设为 CANCELLED</span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 如果当前节点是尾节点，则通过 CAS 设置前驱节点 prev 为尾节点。设置成功后，再利用 CAS 将 </span><br><span class="line">     * prev 的 next 引用置空，断开与后继节点的联系，完成清理工作。</span><br><span class="line">     */ </span><br><span class="line">    if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        /* </span><br><span class="line">         * 执行到这里，表明 pred 节点被成功设为了尾节点，这里通过 CAS 将 pred 节点的后继节点</span><br><span class="line">         * 设为 null。注意这里的 CAS 即使失败了，也没关系。失败了，表明 pred 的后继节点更新</span><br><span class="line">         * 了。pred 此时已经是尾节点了，若后继节点被更新，则是有新节点入队了。这种情况下，CAS </span><br><span class="line">         * 会失败，但失败不会影响同步队列的结构。</span><br><span class="line">         */</span><br><span class="line">        compareAndSetNext(pred, predNext, null);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int ws;</span><br><span class="line">        // 根据条件判断是唤醒后继节点，还是将前驱节点和后继节点连接到一起</span><br><span class="line">        if (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != null) &#123;</span><br><span class="line">            </span><br><span class="line">            Node next = node.next;</span><br><span class="line">            if (next != null &amp;&amp; next.waitStatus &lt;= 0)</span><br><span class="line">                /*</span><br><span class="line">                 * 这里使用 CAS 设置 pred 的 next，表明多个线程同时在取消，这里存在竞争。</span><br><span class="line">                 * 不过此处没针对 compareAndSetNext 方法失败后做一些处理，表明即使失败了也</span><br><span class="line">                 * 没关系。实际上，多个线程同时设置 pred 的 next 引用时，只要有一个能设置成</span><br><span class="line">                 * 功即可。</span><br><span class="line">                 */</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 唤醒后继节点对应的线程。这里简单讲一下为什么要唤醒后继线程，考虑下面一种情况：</span><br><span class="line">             *        head          node1         node2         tail</span><br><span class="line">             *        ws=0          ws=1          ws=-1         ws=0</span><br><span class="line">             *      +------+  prev +-----+  prev +-----+  prev +-----+</span><br><span class="line">             *      |      | &lt;---- |     | &lt;---- |     | &lt;---- |     |  </span><br><span class="line">             *      |      | ----&gt; |     | ----&gt; |     | ----&gt; |     |</span><br><span class="line">             *      +------+  next +-----+  next +-----+  next +-----+</span><br><span class="line">             *      </span><br><span class="line">             * 头结点初始状态为 0，node1、node2 和 tail 节点依次入队。node1 自旋过程中调用 </span><br><span class="line">             * tryAcquire 出现异常，进入 cancelAcquire。head 节点此时等待状态仍然是 0，它</span><br><span class="line">             * 会认为后继节点还在运行中，所它在释放同步状态后，不会去唤醒后继等待状态为非取消的</span><br><span class="line">             * 节点 node2。如果 node1 再不唤醒 node2 的线程，该线程面临无法被唤醒的情况。此</span><br><span class="line">             * 时，整个同步队列就回全部阻塞住。</span><br><span class="line">             */</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; // help GC</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    int ws = node.waitStatus;</span><br><span class="line">    /*</span><br><span class="line">     * 通过 CAS 将等待状态设为 0，让后继节点线程多一次</span><br><span class="line">     * 尝试获取同步状态的机会</span><br><span class="line">     */</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s = null;</span><br><span class="line">       /*</span><br><span class="line">        * 这里如果 s == null 处理，是不是表明 node 是尾节点？答案是不一定。原因之前在分析 </span><br><span class="line">        * enq 方法时说过。这里再啰嗦一遍，新节点入队时，队列瞬时结构可能如下：</span><br><span class="line">        *                      node1         node2</span><br><span class="line">        *      +------+  prev +-----+ prev  +-----+</span><br><span class="line">        * head |      | &lt;---- |     | &lt;---- |     |  tail</span><br><span class="line">        *      |      | ----&gt; |     |       |     |</span><br><span class="line">        *      +------+ next  +-----+       +-----+</span><br><span class="line">        * </span><br><span class="line">        * node2 节点为新入队节点，此时 tail 已经指向了它，但 node1 后继引用还未设置。</span><br><span class="line">        * 这里 node1 就是 node 参数，s = node1.next = null，但此时 node1 并不是尾</span><br><span class="line">        * 节点。所以这里不能从前向后遍历同步队列，应该从后向前。</span><br><span class="line">        */</span><br><span class="line">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            if (t.waitStatus &lt;= 0)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    if (s != null)</span><br><span class="line">        // 唤醒 node 的后继节点线程</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，独占式获取同步状态的分析就讲完了。如果仅分析获取同步状态的大致流程，那么这个流程并不难。但若深入到细节之中，还是需要思考思考。这里对独占式获取同步状态的大致流程做个总结，如下：</p><ul><li>调用 tryAcquire 方法尝试获取同步状态</li><li>获取成功，直接返回</li><li>获取失败，将线程封装到节点中，并将节点入队</li><li>入队节点在 acquireQueued 方法中自旋获取同步状态</li><li>若节点的前驱节点是头节点，则再次调用 tryAcquire 尝试获取同步状态</li><li>获取成功，当前节点将自己设为头节点并返回</li><li>获取失败，可能再次尝试，也可能会被阻塞。这里简单认为会被阻塞。</li></ul><p>上面的步骤对应下面的流程图：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191024174549.png" alt></p><h2><a id="_68"></a><a class="header-anchor" href="#释放同步状态">¶</a>释放同步状态</h2><p>相对于获取同步状态，释放同步状态的过程则要简单的多，这里简单罗列一下步骤：</p><ul><li>调用 tryRelease(arg) 尝试释放同步状态</li><li>根据条件判断是否应该唤醒后继线程</li></ul><p>就两个步骤，下面看一下源码分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        /*</span><br><span class="line">         * 这里简单列举条件分支的可能性，如下：</span><br><span class="line">         * 1. head = null</span><br><span class="line">         *     head 还未初始化。初始情况下，head = null，当第一个节点入队后，head 会被初始</span><br><span class="line">         *     为一个虚拟（dummy）节点。这里，如果还没节点入队就调用 release 释放同步状态，</span><br><span class="line">         *     就会出现 h = null 的情况。</span><br><span class="line">         *     </span><br><span class="line">         * 2. head != null &amp;&amp; waitStatus = 0</span><br><span class="line">         *     表明后继节点对应的线程仍在运行中，不需要唤醒</span><br><span class="line">         * </span><br><span class="line">         * 3. head != null &amp;&amp; waitStatus &lt; 0</span><br><span class="line">         *     后继节点对应的线程可能被阻塞了，需要唤醒 </span><br><span class="line">         */</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            // 唤醒后继节点，上面分析过了，这里不再赘述</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><a id="_77"></a><a class="header-anchor" href="#共享模式">¶</a>共享模式</h2><p>与独占模式不同，共享模式下，同一时刻会有多个线程获取共享同步状态。共享模式是实现读写锁中的读锁、CountDownLatch 和 Semaphore 等同步组件的基础，搞懂了，再去理解一些共享同步组件就不难了。</p><h3><a id="_79"></a><a class="header-anchor" href="#获取同步状态-v2">¶</a>获取同步状态</h3><p>共享类型的节点获取共享同步状态后，如果后继节点也是共享类型节点，当前节点则会唤醒后继节点。这样，多个节点线程即可同时获取共享同步状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    // 尝试获取共享同步状态，tryAcquireShared 返回的是整型</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">    final Node node = addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        // 这里和前面一样，也是通过有限次自旋的方式获取同步状态</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            /*</span><br><span class="line">             * 前驱是头结点，其类型可能是 EXCLUSIVE，也可能是 SHARED.</span><br><span class="line">             * 如果是 EXCLUSIVE，线程无法获取共享同步状态。</span><br><span class="line">             * 如果是 SHARED，线程则可获取共享同步状态。</span><br><span class="line">             * 能不能获取共享同步状态要看 tryAcquireShared 具体的实现。比如多个线程竞争读写</span><br><span class="line">             * 锁的中的读锁时，均能成功获取读锁。但多个线程同时竞争信号量时，可能就会有一部分线</span><br><span class="line">             * 程因无法竞争到信号量资源而阻塞。</span><br><span class="line">             */ </span><br><span class="line">            if (p == head) &#123;</span><br><span class="line">                // 尝试获取共享同步状态</span><br><span class="line">                // 获取失败：负数</span><br><span class="line">                // 成功：0，但是后续节点无法获取同步状态</span><br><span class="line">                // 成功：&gt;0 , 同时后续节点可以获取同步状态，但是后续线程必须检查状态的可用性</span><br><span class="line">                int r = tryAcquireShared(arg);</span><br><span class="line">                if (r &gt;= 0) &#123;</span><br><span class="line">                    // 设置头结点，如果后继节点是共享类型，唤醒后继节点</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    if (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">/**</span><br><span class="line"> * 这个方法做了两件事情：</span><br><span class="line"> * 1. 设置自身为头结点</span><br><span class="line"> * 2. 根据条件判断是否要唤醒后继节点</span><br><span class="line"> */ </span><br><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">    Node h = head;</span><br><span class="line">    // 设置头结点</span><br><span class="line">    setHead(node);</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     * 这个条件分支由 propagate &gt; 0 和 h.waitStatus &lt; 0 两部分组成。</span><br><span class="line">     * h.waitStatus &lt; 0 时，waitStatus = SIGNAL 或 PROPAGATE。这里仅依赖</span><br><span class="line">     * 条件 propagate &gt; 0 判断是否唤醒后继节点是不充分的，至于原因请参考下面</span><br><span class="line">     */</span><br><span class="line">    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</span><br><span class="line">        (h = head) == null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        /*</span><br><span class="line">         * 节点 s 如果是共享类型节点，则应该唤醒该节点</span><br><span class="line">         * 至于 s == null 的情况前面分析过，这里不在赘述。</span><br><span class="line">         */ </span><br><span class="line">        if (s == null || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 该方法用于在 acquires/releases 存在竞争的情况下，确保唤醒动作向后传播。</span><br><span class="line"> */ </span><br><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    /*</span><br><span class="line">     * 下面的循环在 head 节点存在后继节点的情况下，做了两件事情：</span><br><span class="line">     * 1. 如果 head 节点等待状态为 SIGNAL，则将 head 节点状态设为 0，并唤醒后继节点</span><br><span class="line">     * 2. 如果 head 节点等待状态为 0，则将 head 节点状态设为 PROPAGATE，保证唤醒能够正</span><br><span class="line">     *    常传播下去。关于 PROPAGATE 状态的细节分析，后面会讲到。</span><br><span class="line">     */</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">            int ws = h.waitStatus;</span><br><span class="line">            if (ws == Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            // loop to recheck cases</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            /* </span><br><span class="line">             * ws = 0 的情况下，这里要尝试将状态从 0 设为 PROPAGATE，保证唤醒向后</span><br><span class="line">             * 传播。setHeadAndPropagate 在读到 h.waitStatus &lt; 0 时，可以继续唤醒</span><br><span class="line">             * 后面的节点。</span><br><span class="line">             */</span><br><span class="line">            else if (ws == 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                // loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        if (h == head)                   // loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，共享模式下获取同步状态的逻辑就分析完了，不过我这里只做了简单分析。相对于独占式获取同步状态，共享式的情况更为复杂。独占模式下，只有一个节点线程可以成功获取同步状态，也只有获取已同步状态节点线程才可以释放同步状态。但在共享模式下，多个共享节点线程可以同时获得同步状态，在一些线程获取同步状态的同时，可能还会有另外一些线程正在释放同步状态。所以，共享模式更为复杂。这里我的脑力跟不上了，没法面面俱到的分析。<br>最后说一下共享模式下获取同步状态的大致流程，如下：</p><ul><li>获取共享同步状态</li><li>若获取失败，则生成节点，并入队</li><li>如果前驱为头结点，再次尝试获取共享同步状态</li><li>获取成功则将自己设为头结点，如果后继节点是共享类型的，则唤醒</li><li>若失败，将节点状态设为 SIGNAL，再次尝试。若再次失败，线程进入等待状态</li></ul><h2><a id="_90"></a><a class="header-anchor" href="#释放同步状态-v2">¶</a>释放同步状态</h2><p>释放共享状态主要逻辑在 doReleaseShared 中，doReleaseShared 上节已经分析过，这里就不赘述了。共享节点线程在获取同步状态和释放同步状态时都会调用 doReleaseShared，所以 doReleaseShared 是多线程竞争集中的地方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><a id="PROPAGATE__94"></a>PROPAGATE 状态存在的意义</h1><p>AQS 的节点有几种不同的状态，PROPAGATE 字面意义，即向后传播唤醒动作。<br>那么就有两个问题：</p><ul><li>PROPAGATE 状态用在哪里，以及怎样向后传播唤醒动作的？</li><li>引入 PROPAGATE 状态是为了解决什么问题？</li></ul><h2><a id="_PROPAGATE__100"></a><a class="header-anchor" href="#利用-propagate-传播唤醒动作">¶</a>利用 PROPAGATE 传播唤醒动作</h2><p>PROPAGATE 状态是用来传播唤醒动作的，那么它是在哪里进行传播的呢？答案是在setHeadAndPropagate方法中，这里再来看看 setHeadAndPropagate 方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">    Node h = head;</span><br><span class="line">    setHead(node);</span><br><span class="line">    </span><br><span class="line">    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</span><br><span class="line">        (h = head) == null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        if (s == null || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意看 setHeadAndPropagate 方法中那个长长的判断语句，其中有一个条件是h.waitStatus &lt; 0，当 h.waitStatus = SIGNAL(-1) 或 PROPAGATE(-3) 是，这个条件就会成立。那么 PROPAGATE 状态是在何时被设置的呢？答案是在doReleaseShared方法中，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">            int ws = h.waitStatus;</span><br><span class="line">            if (ws == Node.SIGNAL) &#123;...&#125;</span><br><span class="line">            </span><br><span class="line">            // 如果 ws = 0，则将 h 状态设为 PROPAGATE</span><br><span class="line">            else if (ws == 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                // loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再回到 setHeadAndPropagate 的实现，该方法既然引入了h.waitStatus &lt; 0这个条件，就意味着仅靠条件propagate &gt; 0判断是否唤醒后继节点线程的机制是不充分的。为啥?</p><h2><a id="_PROPAGATE__106"></a><a class="header-anchor" href="#引入-propagate-所解决的问题">¶</a>引入 PROPAGATE 所解决的问题</h2><p>PROPAGATE 的引入是为了解决一个 BUG – <a href="https://bugs.java.com/view_bug.do?bug_id=6801020" target="_blank" rel="noopener">JDK-6801020</a>，复现这个 BUG 的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line">public class TestSemaphore &#123;</span><br><span class="line"></span><br><span class="line">   private static Semaphore sem = new Semaphore(0);</span><br><span class="line"></span><br><span class="line">   private static class Thread1 extends Thread &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void run() &#123;</span><br><span class="line">           sem.acquireUninterruptibly();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static class Thread2 extends Thread &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void run() &#123;</span><br><span class="line">           sem.release();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">       for (int i = 0; i &lt; 10000000; i++) &#123;</span><br><span class="line">           Thread t1 = new Thread1();</span><br><span class="line">           Thread t2 = new Thread1();</span><br><span class="line">           Thread t3 = new Thread2();</span><br><span class="line">           Thread t4 = new Thread2();</span><br><span class="line">           t1.start();</span><br><span class="line">           t2.start();</span><br><span class="line">           t3.start();</span><br><span class="line">           t4.start();</span><br><span class="line">           t1.join();</span><br><span class="line">           t2.join();</span><br><span class="line">           t3.join();</span><br><span class="line">           t4.join();</span><br><span class="line">           System.out.println(i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 BUG 的描述消息可知 JDK 6u11,6u17 两个版本受到影响。那么，接下来再来看看引起这个 BUG 的代码 – JDK 6u17 中 setHeadAndPropagate 和 releaseShared 两个方法源码，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">    setHead(node);</span><br><span class="line">    if (propagate &gt; 0 &amp;&amp; node.waitStatus != 0) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * Don&apos;t bother fully figuring out successor.  If it</span><br><span class="line">         * looks null, call unparkSuccessor anyway to be safe.</span><br><span class="line">         */</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        if (s == null || s.isShared())</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 和 release 方法的源码基本一样</span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来简单说明 TestSemaphore 这个类的逻辑。这个类持有一个数值为 0 的信号量对象，并创建了4个线程，线程 t1 和 t2 用于获取信号量，t3 和 t4 则是调用 release() 方法释放信号量。在一般情况下，TestSemaphore 这个类的代码都可以正常执行。但当有极端情况出现时，可能会导致同步队列挂掉。这里演绎一下这个极端情况，考虑某次循环时，队列结构如下：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191024181912.png" alt></p><ul><li>时刻1：线程 t3 调用 unparkSuccessor 方法，head 节点状态由 SIGNAL(-1) 变为0，并唤醒线程 t1。此时信号量数值为1。</li><li>时刻2：线程 t1 恢复运行，t1 调用 Semaphore.NonfairSync 的 tryAcquireShared，返回0。然后线程 t1 被切换，暂停运行。</li><li>时刻3：线程 t4 调用 releaseShared 方法，因 head 的状态为0，所以 t4 不会调用 unparkSuccessor 方法。</li><li>时刻4：线程 t1 恢复运行，t1 成功获取信号量，调用 setHeadAndPropagate。但因为 propagate = 0，线程 t1 无法调用 unparkSuccessor 唤醒线程 t2，t2 面临无线程唤醒的情况。因为 t2 无法退出等待状态，所以 t2.join 会阻塞主线程，导致程序挂住。</li></ul><p>下面再来看一下修复 BUG 后的代码，根据 BUG 详情页显示，该 BUG 在 JDK 1.7 中被修复。这里找一个 JDK 7 较早版本（JDK 7u10）的代码看一下，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">    Node h = head; // Record old head for check below</span><br><span class="line">    setHead(node);</span><br><span class="line">    </span><br><span class="line">    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        if (s == null || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">            int ws = h.waitStatus;</span><br><span class="line">            if (ws == Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            // loop to recheck cases</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws == 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                // loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        if (h == head)                   // loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在按照上面的代码演绎一下逻辑，如下：</p><ul><li>时刻1：线程 t3 调用 unparkSuccessor 方法，head 节点状态由 SIGNAL(-1) 变为0，并唤醒线程t1。此时信号量数值为1。</li><li>时刻2：线程 t1 恢复运行，t1 调用 Semaphore.NonfairSync 的 tryAcquireShared，返回0。然后线程 t1 被切换，暂停运行。</li><li>时刻3：线程 t4 调用 releaseShared 方法，检测到h.waitStatus = 0，t4 将头节点等待状态由0设为PROPAGATE(-3)。</li><li>时刻4：线程 t1 恢复运行，t1 成功获取信号量，调用 setHeadAndPropagate。因 propagate = 0，propagate &gt; 0 条件不满足。而 h.waitStatus = PROPAGATE(-3)，所以条件h.waitStatus &lt; 0成立。进而，线程 t1 可以唤醒线程 t2，完成唤醒动作的传播。</li></ul><h3><a id="PROPAGATE__128"></a><a class="header-anchor" href="#propagate-状态用在哪里-以及怎样向后传播唤醒动作的？">¶</a>PROPAGATE 状态用在哪里，以及怎样向后传播唤醒动作的？</h3><p>PROPAGATE 状态用在 setHeadAndPropagate。当头节点状态被设为 PROPAGATE 后，后继节点成为新的头结点后。若 propagate &gt; 0 条件不成立，则根据条件h.waitStatus &lt; 0成立与否，来决定是否唤醒后继节点，即向后传播唤醒动作。</p><h3><a id="_PROPAGATE__131"></a><a class="header-anchor" href="#引入-propagate-状态是为了解决什么问题？">¶</a>引入 PROPAGATE 状态是为了解决什么问题？</h3><p>引入 PROPAGATE 状态是为了解决并发释放信号量所导致部分请求信号量的线程无法被唤醒的问题。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jeff-eric.github.com/blog/blog/2019/10/24/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jeff-Eric"><meta itemprop="description" content=""><meta itemprop="image" content="/blog/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="纯天然绿色学渣"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/blog/2019/10/24/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">AbstractQueuedSynchronizer 原理分析 - 独占模式</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-24 14:13:00" itemprop="dateCreated datePublished" datetime="2019-10-24T14:13:00+08:00">2019-10-24</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-10-25 19:48:56" itemprop="dateModified" datetime="2019-10-25T19:48:56+08:00">2019-10-25</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/blog/2019/10/24/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/2019/10/24/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F/" itemprop="commentCount"></span> </a></span><span id="/blog/2019/10/24/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F/" class="leancloud_visitors" data-flag-title="AbstractQueuedSynchronizer 原理分析 - 独占模式"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body han-init-context" itemprop="articleBody"><h1><a id="AQS__1"></a>AQS 结构</h1><p>先来看看 AQS 有哪些属性，搞清楚这些基本就知道 AQS 是什么套路了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的</span><br><span class="line">private transient volatile Node head;</span><br><span class="line"></span><br><span class="line">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span><br><span class="line">private transient volatile Node tail;</span><br><span class="line"></span><br><span class="line">// 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁</span><br><span class="line">// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1</span><br><span class="line">private volatile int state;</span><br><span class="line"></span><br><span class="line">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span><br><span class="line">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span><br><span class="line">// if (currentThread == getExclusiveOwnerThread()) &#123;state++&#125;</span><br><span class="line">private transient Thread exclusiveOwnerThread; //继承自AbstractOwnableSynchronizer</span><br></pre></td></tr></table></figure><p>AbstractQueuedSynchronizer 的等待队列示意如下所示，注意了，之后分析过程中所说的 queue，也就是阻塞队列<br>不包含 head ！！！<br>不包含 head ！！！<br>不包含 head ！！！<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191025190929.png" alt></p><p>等待队列中每个线程被包装成一个 Node 实例，数据结构是链表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line">    // 标识节点当前在共享模式下</span><br><span class="line">    static final Node SHARED = new Node();</span><br><span class="line">    // 标识节点当前在独占模式下</span><br><span class="line">    static final Node EXCLUSIVE = null;</span><br><span class="line"></span><br><span class="line">    // ======== 下面的几个int常量是给waitStatus用的 ===========</span><br><span class="line">    /** waitStatus value to indicate thread has cancelled */</span><br><span class="line">    // 代码此线程取消了争抢这个锁</span><br><span class="line">    static final int CANCELLED =  1;</span><br><span class="line">    /** waitStatus value to indicate successor&apos;s thread needs unparking */</span><br><span class="line">    // 官方的描述是，其表示当前node的后继节点对应的线程需要被唤醒</span><br><span class="line">    static final int SIGNAL    = -1;</span><br><span class="line">    /** waitStatus value to indicate thread is waiting on condition */</span><br><span class="line">    // 本文不分析condition，所以略过吧，下一篇文章会介绍这个</span><br><span class="line">    static final int CONDITION = -2;</span><br><span class="line">    /**</span><br><span class="line">     * waitStatus value to indicate the next acquireShared should</span><br><span class="line">     * unconditionally propagate</span><br><span class="line">     */</span><br><span class="line">    // 同样的不分析，略过吧</span><br><span class="line">    static final int PROPAGATE = -3;</span><br><span class="line">    // =====================================================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 取值为上面的1、-1、-2、-3，或者0(以后会讲到)</span><br><span class="line">    // 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待，</span><br><span class="line">    //    ps: 半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的。。。</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line">    // 前驱节点的引用</span><br><span class="line">    volatile Node prev;</span><br><span class="line">    // 后继节点的引用</span><br><span class="line">    volatile Node next;</span><br><span class="line">    // 这个就是线程本尊</span><br><span class="line">    volatile Thread thread;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node 的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已，大家先要有这个概念在心里。<br>上面的是基础知识，后面会多次用到，心里要时刻记着它们，心里想着这个结构图就可以了。下面，我们开始说 ReentrantLock 的公平锁。再次强调，我说的阻塞队列不包含 head 节点。<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191025191212.png" alt></p><p>首先，我们先看下 ReentrantLock 的使用方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 我用个web开发中的service概念吧</span><br><span class="line">public class OrderService &#123;</span><br><span class="line">    // 使用static，这样每个线程拿到的是同一把锁，当然，spring mvc中service默认就是单例，别纠结这个</span><br><span class="line">    private static ReentrantLock reentrantLock = new ReentrantLock(true);</span><br><span class="line"></span><br><span class="line">    public void createOrder() &#123;</span><br><span class="line">        // 比如我们同一时间，只允许一个线程创建订单</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        // 通常，lock 之后紧跟着 try 语句</span><br><span class="line">        try &#123;</span><br><span class="line">            // 这块代码同一时间只能有一个线程进来(获取到锁的线程)，</span><br><span class="line">            // 其他的线程在lock()方法上阻塞，等待获取到锁，再进来</span><br><span class="line">            // 执行代码...</span><br><span class="line">            // 执行代码...</span><br><span class="line">            // 执行代码...</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 释放锁</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock 在内部用了内部类 Sync 来管理锁，所以真正的获取锁和释放锁是由 Sync 的实现类来控制的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sync 有两个实现，分别为 NonfairSync（非公平锁）和 FairSync（公平锁），我们看 FairSync 部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><a id="_25"></a>线程强锁</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID = -3000897897090466540L;</span><br><span class="line">      // 争锁</span><br><span class="line">    final void lock() &#123;</span><br><span class="line">        acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line">      // 来自父类AQS，我直接贴过来这边，下面分析的时候同样会这样做，不会给读者带来阅读压力</span><br><span class="line">    // 我们看到，这个方法，如果tryAcquire(arg) 返回true, 也就结束了。</span><br><span class="line">    // 否则，acquireQueued方法会将线程压到队列中</span><br><span class="line">    public final void acquire(int arg) &#123; // 此时 arg == 1</span><br><span class="line">        // 首先调用tryAcquire(1)一下，名字上就知道，这个只是试一试</span><br><span class="line">        // 因为有可能直接就成功了呢，也就不需要进队列排队了，</span><br><span class="line">        // 对于公平锁的语义就是：本来就没人持有锁，根本没必要进队列等待(又是挂起，又是等待被唤醒的)</span><br><span class="line">        if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            // tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;</span><br><span class="line">              selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Fair version of tryAcquire.  Don&apos;t grant access unless</span><br><span class="line">     * recursive call or no waiters or is first.</span><br><span class="line">     */</span><br><span class="line">    // 尝试直接获取锁，返回值是boolean，代表是否获取到锁</span><br><span class="line">    // 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取</span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        final Thread current = Thread.currentThread();</span><br><span class="line">        int c = getState();</span><br><span class="line">        // state == 0 此时此刻没有线程持有锁</span><br><span class="line">        if (c == 0) &#123;</span><br><span class="line">            // 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span><br><span class="line">            // 看看有没有别人在队列中等了半天了</span><br><span class="line">            if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                // 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span><br><span class="line">                // 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=</span><br><span class="line">                // 因为刚刚还没人的，我判断过了</span><br><span class="line">                compareAndSetState(0, acquires)) &#123;</span><br><span class="line"></span><br><span class="line">                // 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          // 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span><br><span class="line">        // 这里不存在并发问题</span><br><span class="line">        else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            int nextc = c + acquires;</span><br><span class="line">            if (nextc &lt; 0)</span><br><span class="line">                throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁</span><br><span class="line">        // 回到上面一个外层调用方法继续看:</span><br><span class="line">        // if (!tryAcquire(arg) </span><br><span class="line">        //        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span><br><span class="line">        //     selfInterrupt();</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 假设tryAcquire(arg) 返回false，那么代码将执行：</span><br><span class="line">      //        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，</span><br><span class="line">    // 这个方法，首先需要执行：addWaiter(Node.EXCLUSIVE)</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates and enqueues node for current thread and given mode.</span><br><span class="line">     *</span><br><span class="line">     * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span><br><span class="line">     * @return the new node</span><br><span class="line">     */</span><br><span class="line">    // 此方法的作用是把线程包装成node，同时进入到队列中</span><br><span class="line">    // 参数mode此时是Node.EXCLUSIVE，代表独占模式</span><br><span class="line">    private Node addWaiter(Node mode) &#123;</span><br><span class="line">        Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">        // Try the fast path of enq; backup to full enq on failure</span><br><span class="line">        // 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后</span><br><span class="line">        Node pred = tail;</span><br><span class="line"></span><br><span class="line">        // tail!=null =&gt; 队列不为空(tail==head的时候，其实队列是空的，不过不管这个吧)</span><br><span class="line">        if (pred != null) &#123; </span><br><span class="line">            // 将当前的队尾节点，设置为自己的前驱 </span><br><span class="line">            node.prev = pred; </span><br><span class="line">            // 用CAS把自己设置为队尾, 如果成功后，tail == node 了，这个节点成为阻塞队列新的尾巴</span><br><span class="line">            if (compareAndSetTail(pred, node)) &#123; </span><br><span class="line">                // 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，</span><br><span class="line">                // 上面已经有 node.prev = pred，加上下面这句，也就实现了和之前的尾节点双向连接了</span><br><span class="line">                pred.next = node;</span><br><span class="line">                // 线程入队了，可以返回了</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 仔细看看上面的代码，如果会到这里，</span><br><span class="line">        // 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)</span><br><span class="line">        // 读者一定要跟上思路，如果没有跟上，建议先不要往下读了，往回仔细看，否则会浪费时间的</span><br><span class="line">        enq(node);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Inserts node into queue, initializing if necessary. See picture above.</span><br><span class="line">     * @param node the node to insert</span><br><span class="line">     * @return node&apos;s predecessor</span><br><span class="line">     */</span><br><span class="line">    // 采用自旋的方式入队</span><br><span class="line">    // 之前说过，到这个方法只有两种可能：等待队列为空，或者有线程竞争入队，</span><br><span class="line">    // 自旋在这边的语义是：CAS设置tail过程中，竞争一次竞争不到，我就多次竞争，总会排到的</span><br><span class="line">    private Node enq(final Node node) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            // 之前说过，队列为空也会进来这里</span><br><span class="line">            if (t == null) &#123; // Must initialize</span><br><span class="line">                // 初始化head节点</span><br><span class="line">                // 细心的读者会知道原来 head 和 tail 初始化的时候都是 null 的</span><br><span class="line">                // 还是一步CAS，你懂的，现在可能是很多线程同时进来呢</span><br><span class="line">                if (compareAndSetHead(new Node()))</span><br><span class="line">                    // 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了</span><br><span class="line"></span><br><span class="line">                    // 这个时候有了head，但是tail还是null，设置一下，</span><br><span class="line">                    // 把tail指向head，放心，马上就有线程要来了，到时候tail就要被抢了</span><br><span class="line">                    // 注意：这里只是设置了tail=head，这里可没return哦，没有return，没有return</span><br><span class="line">                    // 所以，设置完了以后，继续for循环，下次就到下面的else分支了</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 下面几行，和上一个方法 addWaiter 是一样的，</span><br><span class="line">                // 只是这个套在无限循环里，反正就是将当前线程排到队尾，有线程竞争的话排不上重复排</span><br><span class="line">                node.prev = t;</span><br><span class="line">                if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    return t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 现在，又回到这段代码了</span><br><span class="line">    // if (!tryAcquire(arg) </span><br><span class="line">    //        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span><br><span class="line">    //     selfInterrupt();</span><br><span class="line"></span><br><span class="line">    // 下面这个方法，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列</span><br><span class="line">    // 注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，</span><br><span class="line">    // 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false</span><br><span class="line">    // 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了</span><br><span class="line">    final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">        boolean failed = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean interrupted = false;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                final Node p = node.predecessor();</span><br><span class="line">                // p == head 说明当前节点虽然进到了阻塞队列，但是是阻塞队列的第一个，因为它的前驱是head</span><br><span class="line">                // 注意，阻塞队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为阻塞队列</span><br><span class="line">                // 所以当前节点可以去试抢一下锁</span><br><span class="line">                // 这里我们说一下，为什么可以去试试：</span><br><span class="line">                // 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，</span><br><span class="line">                // enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程</span><br><span class="line">                // 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，</span><br><span class="line">                // tryAcquire已经分析过了, 忘记了请往前看一下，就是简单用CAS试操作一下state</span><br><span class="line">                if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                // 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，</span><br><span class="line">                // 要么就是tryAcquire(arg)没有抢赢别人，继续往下看</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 什么时候 failed 会为 true???</span><br><span class="line">            // tryAcquire() 方法抛异常的情况</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Checks and updates status for a node that failed to acquire.</span><br><span class="line">     * Returns true if thread should block. This is the main signal</span><br><span class="line">     * control in all acquire loops.  Requires that pred == node.prev</span><br><span class="line">     *</span><br><span class="line">     * @param pred node&apos;s predecessor holding status</span><br><span class="line">     * @param node the node</span><br><span class="line">     * @return &#123;@code true&#125; if thread should block</span><br><span class="line">     */</span><br><span class="line">    // 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是：&quot;当前线程没有抢到锁，是否需要挂起当前线程？&quot;</span><br><span class="line">    // 第一个参数是前驱节点，第二个参数才是代表当前线程的节点</span><br><span class="line">    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">        int ws = pred.waitStatus;</span><br><span class="line">        // 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span><br><span class="line">        if (ws == Node.SIGNAL)</span><br><span class="line">            /*</span><br><span class="line">             * This node has already set status asking a release</span><br><span class="line">             * to signal it, so it can safely park.</span><br><span class="line">             */</span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        // 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。</span><br><span class="line">        // 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。</span><br><span class="line">        // 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，</span><br><span class="line">        // 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，</span><br><span class="line">        // 找前驱节点的前驱节点做爹，往前遍历总能找到一个好爹的</span><br><span class="line">        if (ws &gt; 0) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">             * indicate retry.</span><br><span class="line">             */</span><br><span class="line">            do &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /*</span><br><span class="line">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">             * need a signal, but don&apos;t park yet.  Caller will need to</span><br><span class="line">             * retry to make sure it cannot acquire before parking.</span><br><span class="line">             */</span><br><span class="line">            // 仔细想想，如果进入到这个分支意味着什么</span><br><span class="line">            // 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3</span><br><span class="line">            // 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0</span><br><span class="line">            // 正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0</span><br><span class="line">            // 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)</span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        // 这个方法返回 false，那么会再走一次 for 循序，</span><br><span class="line">        //     然后再次进来此方法，此时会从第一个分支返回 true</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // private static boolean shouldParkAfterFailedAcquire(Node pred, Node node)</span><br><span class="line">    // 这个方法结束根据返回值我们简单分析下：</span><br><span class="line">    // 如果返回true, 说明前驱节点的waitStatus==-1，是正常情况，那么当前线程需要被挂起，等待以后被唤醒</span><br><span class="line">    //        我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了</span><br><span class="line">    // 如果返回false, 说明当前不需要被挂起，为什么呢？往后看</span><br><span class="line"></span><br><span class="line">    // 跳回到前面是这个方法</span><br><span class="line">    // if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    //                parkAndCheckInterrupt())</span><br><span class="line">    //                interrupted = true;</span><br><span class="line"></span><br><span class="line">    // 1. 如果shouldParkAfterFailedAcquire(p, node)返回true，</span><br><span class="line">    // 那么需要执行parkAndCheckInterrupt():</span><br><span class="line"></span><br><span class="line">    // 这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的</span><br><span class="line">    // 这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒=======</span><br><span class="line">    private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        return Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2. 接下来说说如果shouldParkAfterFailedAcquire(p, node)返回false的情况</span><br><span class="line"></span><br><span class="line">   // 仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的，原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。</span><br><span class="line"></span><br><span class="line">    // 解释下为什么shouldParkAfterFailedAcquire(p, node)返回false的时候不直接挂起线程：</span><br><span class="line">    // =&gt; 是为了应对在经过这个方法后，node已经是head的直接后继节点了。剩下的读者自己想想吧。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说到这里，也就明白了，多看几遍 final boolean acquireQueued(final Node node, int arg) 这个方法吧。自己推演下各个分支怎么走，哪种情况下会发生什么，走到哪里。</p><h1><a id="_29"></a>解锁操作</h1><p>最后，就是还需要介绍下唤醒的动作了。我们知道，正常情况下，如果线程没获取到锁，线程会被 LockSupport.park(this); 挂起停止，等待被唤醒。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// 唤醒的代码还是比较简单的，你如果上面加锁的都看懂了，下面都不需要看就知道怎么回事了</span><br><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    // 往后看吧</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 回到ReentrantLock看tryRelease方法</span><br><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    int c = getState() - releases;</span><br><span class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    // 是否完全释放锁</span><br><span class="line">    boolean free = false;</span><br><span class="line">    // 其实就是重入的问题，如果c==0，也就是说没有嵌套锁了，可以释放了，否则还不能释放掉</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        free = true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Wakes up node&apos;s successor, if one exists.</span><br><span class="line"> *</span><br><span class="line"> * @param node the node</span><br><span class="line"> */</span><br><span class="line">// 唤醒后继节点</span><br><span class="line">// 从上面调用处知道，参数node是head头结点</span><br><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    /*</span><br><span class="line">     * If status is negative (i.e., possibly needing signal) try</span><br><span class="line">     * to clear in anticipation of signalling.  It is OK if this</span><br><span class="line">     * fails or if status is changed by waiting thread.</span><br><span class="line">     */</span><br><span class="line">    int ws = node.waitStatus;</span><br><span class="line">    // 如果head节点当前waitStatus&lt;0, 将其修改为0</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line">    /*</span><br><span class="line">     * Thread to unpark is held in successor, which is normally</span><br><span class="line">     * just the next node.  But if cancelled or apparently null,</span><br><span class="line">     * traverse backwards from tail to find the actual</span><br><span class="line">     * non-cancelled successor.</span><br><span class="line">     */</span><br><span class="line">    // 下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待（waitStatus==1）</span><br><span class="line">    // 从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s = null;</span><br><span class="line">        // 从后往前找，仔细看代码，不必担心中间有节点取消(waitStatus==1)的情况</span><br><span class="line">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            if (t.waitStatus &lt;= 0)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    if (s != null)</span><br><span class="line">        // 唤醒线程</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唤醒线程以后，被唤醒的线程将从以下代码中继续往前走：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this); // 刚刚线程被挂起在这里了</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line">// 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了</span><br></pre></td></tr></table></figure><h1><a id="_35"></a>总结</h1><p>总结一下吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在并发环境下，加锁和解锁需要以下三个部件的协调：</span><br><span class="line"></span><br><span class="line">锁状态。我们要知道锁是不是被别的线程占有了，这个就是 state 的作用，它为 0 的时候代表没有线程占有锁，可以去争抢这个锁，用 CAS 将 state 设为 1，如果 CAS 成功，说明抢到了锁，这样其他线程就抢不到了，如果锁重入的话，state进行 +1 就可以，解锁就是减 1，直到 state 又变为 0，代表释放锁，所以 lock() 和 unlock() 必须要配对啊。然后唤醒等待队列中的第一个线程，让其来占有锁。</span><br><span class="line">线程的阻塞和解除阻塞。AQS 中采用了 LockSupport.park(thread) 来挂起线程，用 unpark 来唤醒线程。</span><br><span class="line">阻塞队列。因为争抢锁的线程可能很多，但是只能有一个线程拿到锁，其他的线程都必须等待，这个时候就需要一个 queue 来管理这些线程，AQS 用的是一个 FIFO 的队列，就是一个链表，每个 node 都持有后继节点的引用。AQS 采用了 CLH 锁的变体来实现，感兴趣的读者可以参考这篇文章关于CLH的介绍，写得简单明了。</span><br></pre></td></tr></table></figure><h1><a id="_39"></a>示例图解析</h1><p>下面属于回顾环节，用简单的示例来说一遍，如果上面的有些东西没看懂，这里还有一次帮助你理解的机会。</p><p>首先，第一个线程调用 reentrantLock.lock()，翻到最前面可以发现，tryAcquire(1) 直接就返回 true 了，结束。只是设置了 state=1，连 head 都没有初始化，更谈不上什么阻塞队列了。要是线程 1 调用 unlock() 了，才有线程 2 来，那世界就太太太平了，完全没有交集嘛，那我还要 AQS 干嘛。</p><p>如果线程 1 没有调用 unlock() 之前，线程 2 调用了 lock(), 想想会发生什么？</p><p>线程 2 会初始化 head【new Node()】，同时线程 2 也会插入到阻塞队列并挂起 (注意看这里是一个 for 循环，而且设置 head 和 tail 的部分是不 return 的，只有入队成功才会跳出循环)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        if (t == null) &#123; // Must initialize</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，是线程 2 初始化 head 节点，此时 head==tail, waitStatus==0<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191025192734.png" alt><br>然后线程 2 入队：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191025192751.png" alt><br>同时我们也要看此时节点的 waitStatus，我们知道 head 节点是线程 2 初始化的，此时的 waitStatus 没有设置， java 默认会设置为 0，但是到 shouldParkAfterFailedAcquire 这个方法的时候，线程 2 会把前驱节点，也就是 head 的waitStatus设置为 -1。</p><p>那线程 2 节点此时的 waitStatus 是多少呢，由于没有设置，所以是 0；</p><p>如果线程 3 此时再进来，直接插到线程 2 的后面就可以了，此时线程 3 的 waitStatus 是 0，到 shouldParkAfterFailedAcquire 方法的时候把前驱节点线程 2 的 waitStatus 设置为 -1。<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191025192812.png" alt></p><p>这里可以简单说下 waitStatus 中 SIGNAL(-1) 状态的意思，Doug Lea 注释的是：代表后继节点需要被唤醒。也就是说这个 waitStatus 其实代表的不是自己的状态，而是后继节点的状态，我们知道，每个 node 在入队的时候，都会把前驱节点的状态改为 SIGNAL，然后阻塞，等待被前驱唤醒。这里涉及的是两个问题：有线程取消了排队、唤醒操作。其实本质是一样的，读者也可以顺着 “waitStatus代表后继节点的状态” 这种思路去看一遍源码。</p><h1><a id="_62"></a>疑问</h1><h2><a id="headnew_Nodehead_63"></a><a class="header-anchor" href="#保留head为刚开始的new-node-不好吗？为什么要重新设置一下head呢？">¶</a>保留head为刚开始的new Node()不好吗？为什么要重新设置一下head呢？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final Node p = node.predecessor();</span><br><span class="line">if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">     setHead(node); </span><br><span class="line">     p.next = null; // help GC</span><br><span class="line">     failed = false;</span><br><span class="line">     return interrupted;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>假设不调用 setHead(node)，我们假设此时 A 持有这个锁，head 是 new Node() 那个空节点。</p><p>A 持有的锁用完了，释放锁，唤醒后继节点 B。后继节点 B 从 parkAndCheckInterrupt() 这个方法返回，注意这里的 for 循环。然后调用 final Node p = node.predecessor(); 这个方法，那么这个时候，p == head 就不成立了，也就进不到 tryAcquire(arg) 这里去获取锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for (;;) &#123;</span><br><span class="line">    final Node p = node.predecessor();</span><br><span class="line">    if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">        // 进到这里，说明获取到锁了</span><br><span class="line">        setHead(node);</span><br><span class="line">        p.next = null; // help GC</span><br><span class="line">        failed = false;</span><br><span class="line">        return interrupted;</span><br><span class="line">    &#125;</span><br><span class="line">    if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">        parkAndCheckInterrupt())</span><br><span class="line">        interrupted = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一处。既然当前线程获取到了锁，它就不应该再是阻塞队列的一员。如果没有 setHead 这一步，下面这个方法就不准确了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final Collection&lt;Thread&gt; getQueuedThreads() &#123;</span><br><span class="line">    ArrayList&lt;Thread&gt; list = new ArrayList&lt;Thread&gt;();</span><br><span class="line">    for (Node p = tail; p != null; p = p.prev) &#123;</span><br><span class="line">        Thread t = p.thread;</span><br><span class="line">        if (t != null) // 注意这里</span><br><span class="line">            list.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><a id="finallycancelAcquire_tailCANCELheadCANCEL_72"></a><a class="header-anchor" href="#这个finally里的cancelacquire-似乎永远都不会被执行吧-为什么都是要从tail往前找第一个状态是非cancel的节点呢-如果从head往后找第一个状态是非cancel的话效率会不会高一点">¶</a>这个finally里的cancelAcquire 似乎永远都不会被执行吧?为什么都是要从tail往前找第一个状态是非CANCEL的节点呢，如果从head往后找第一个状态是非CANCEL的话效率会不会高一点?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">boolean failed = true;</span><br><span class="line">try &#123;</span><br><span class="line">    boolean interrupted = false;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        final Node p = node.predecessor();</span><br><span class="line">        if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">            setHead(node);</span><br><span class="line">            p.next = null; // help GC</span><br><span class="line">            failed = false;</span><br><span class="line">            return interrupted;</span><br><span class="line">        &#125;</span><br><span class="line">        if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">            parkAndCheckInterrupt())</span><br><span class="line">            interrupted = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    if (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个问题：这里的 failed 确实永远都不会为 true，cancelAcquire() 永远不会得到执行。那为什么要这么写呢，如果你看了后面的两篇，可能会有些体会，这部分其实是用于响应中断或超时的，你可以参考 doAcquireNanos(int arg, long nanosTimeout) 或 doAcquireInterruptibly(int arg)。在这个方法中确实是没用的，这更像是模板代码吧。<br>这段代码的异常可能发生在 tryAcquire(arg) 这里，因为这是依赖于子类来实现的。</p><p>第二个问题：应该说的是 unparkSuccessor(Node node) 这个方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Node s = node.next;</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s = null;</span><br><span class="line">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            if (t.waitStatus &lt;= 0)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    if (s != null)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br></pre></td></tr></table></figure><p>首先，第一行代码先检测 head 的后继节点，只有当此时的后继节点不存在或者这个后继节点取消了才开始从后往前找，所以大部分情况下，其实不会发生从后往前遍历整个队列的情况。（后继节点取消很正常，但是某节点在入队的时候，如果发现前驱是取消状态，前驱节点是会被请出队列的）</p><p>这个问题的答案在 addWaiter(Node mode)方法中，看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Node pred = tail;</span><br><span class="line">    if (pred != null) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        // 1. 先设置的 tail</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            // 2. 设置前驱节点的后继节点为当前节点</span><br><span class="line">            pred.next = node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以，这里存在并发问题：从前往后寻找不一定能找到刚刚加入队列的后继节点。</p><h2><a id="JavamonitorAQSAQS_85"></a><a class="header-anchor" href="#感觉java的monitor和aqs的目的和实现思路很相似-为什么还要再实现一遍aqs呢？">¶</a>感觉Java的monitor和AQS的目的和实现思路很相似，为什么还要再实现一遍AQS呢？</h2><p>monitor 功能太单一了，就是获取独占锁，</p><p>AQS 相比 monitor，功能要丰富很多，比如我们可以设置超时时间，可以用线程中断进行退出，可以选择公平/非公平模式等, 采用 AQS 可以实现很多灵活的场景</p><h2><a id="acquireQueuedshouldParkAfterFailedAcquirep_nodewaitStatus01falseacquireQueuedshouldParkAfterFailedAcquiretrueparkAndCheckInterruptBAwaitStatus1unparkB_90"></a><a class="header-anchor" href="#acquirequeued方法里面-第一次调用shouldparkafterfailedacquire-p-node-的时候-把前驱节点waitstatus从0改为-1-然后返回false-回到acquirequeued方法-再尝试拿一次锁-然后第二次调用shouldparkafterfailedacquire返回true-调用parkandcheckinterrupt-挂起线程-那么-如果在某线程b还没有挂起之前-前驱节点的线程a发现自己waitstatus为-1直接unpark-然后刚刚的线程b才挂起-那不就没人能唤醒它了吗？它是怎么保证被唤醒的？">¶</a>acquireQueued方法里面，第一次调用shouldParkAfterFailedAcquire(p, node)的时候，把前驱节点waitStatus从0改为-1，然后返回false，回到acquireQueued方法，再尝试拿一次锁，然后第二次调用shouldParkAfterFailedAcquire返回true，调用parkAndCheckInterrupt()挂起线程。那么，如果在某线程B还没有挂起之前，前驱节点的线程A发现自己waitStatus为-1直接unpark，然后刚刚的线程B才挂起。那不就没人能唤醒它了吗？它是怎么保证被唤醒的？</h2><p>你应该已经把流程摸清楚了，我就说一点就可以了，你的疑问其实在 unpark() 方法上。<br>1、如果一个线程 park 了，那么调用 unpark(thread) 这个线程会被唤醒；<br>2、如果一个线程先被调用了 unpark，那么下一个 park(thread) 操作不会挂起线程。</p><h2><a id="tailheadtailnull_95"></a><a class="header-anchor" href="#为什么要先读tail-再读head-我猜是为了增加tail为null的可能性-可是增加这种可能性的目的呢？">¶</a>为什么要先读tail，再读head，我猜是为了增加tail为null的可能性，可是增加这种可能性的目的呢？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">    // The correctness of this depends on head being initialized</span><br><span class="line">    // before tail and on head.next being accurate if the current</span><br><span class="line">    // thread is first in queue.</span><br><span class="line">    Node t = tail; // Read fields in reverse initialization order</span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    return h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == null || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下面这段代码，如果是第一个 node 进队列的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        if (t == null) &#123;</span><br><span class="line">            // 1. 设置 head </span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                // 2. 设置 tail</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，先有 head 然后才有 tail。</p><p>回到 hasQueuedPredecessors：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    return h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == null || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有可能的情况就是 t 为 null，h 不为 null 对吧，这个时候返回值取决于 h.next。<br>如果调换一下 Node t = tail; 和 Node h = head; 那么可能出现 h 为 null，t 不为 null，这个方法会返回 false。<br>但是其实不对的，很可能这个间隙是有节点 enq 成功的。</p><h2><a id="nodenewnull_107"></a><a class="header-anchor" href="#为什么共享锁的node节点是new了一个节点-独占是null呢">¶</a>为什么共享锁的node节点是new了一个节点，独占是null呢?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">其实我也不知道是为什么???</span><br><span class="line">大神 Doug Lea 的想法应该是(我怎么知道他到底怎么想的)：nextWaiter 这个属性在这个时候是没用的，因为它用来实现 Condition，那么不用白不用，虽然不好理解，可是充分利用资源呀，不然还得自己额外定义一个用来标识模式的属性。</span><br></pre></td></tr></table></figure><h2><a id="tryAcquireargaddWaiterNodeEXCLUSIVE__selfInterrupt_selfInterruptacquireint_arg_110"></a><a class="header-anchor" href="#请问这个里如果同步状态tryacquire-arg-获取失败-就构造一个同步节点通过addwaiter-node-exclusive-将节点添加到尾部-如果条件成立执行-selfinterrupt-会中断当前线程吗-selfinterrupt-的用途不是太明白-有的书籍上说acquire-int-arg-方法对中断不敏感-不会将获取同步状态失败的线程从同步队列中移除">¶</a>请问这个里如果同步状态tryAcquire(arg)获取失败，就构造一个同步节点通过addWaiter(Node.EXCLUSIVE)将节点添加到尾部，如果条件成立执行 selfInterrupt()会中断当前线程吗 selfInterrupt()的用途不是太明白，有的书籍上说acquire(int arg)方法对中断不敏感，不会将获取同步状态失败的线程从同步队列中移除</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acquireQueued 返回值代表的是：是否被中断过。但是，不管是否被中断过，acquireQueued 出来以后，线程的中断状态一定是 false，所以如果发生过中断，要重新设置中断状态。<br>虽然 acquire(int arg) 确实是不关心中断的，但是它会保持这个状态，如果客户端想要知道是否发生过中断的话，还是可以知道的。因为中断情况下，中断状态虽然中间丢过，但是 selfInterrupt() 会设置回去。<br>会实际受到中断影响的是另一个方法 acquireInterruptibly(int arg)，这个方法会通过抛出异常的方式告诉客户端。</p><p>acquireQueued 返回值代表的是：是否被中断过。但是，不管是否被中断过，acquireQueued 出来以后，线程的中断状态一定是 false。<br>请问为什么说：acquireQueued 出来以后，线程的中断状态一定是 false ？</p><p>看一下 Thread.interrupted() 这个方法，这个方法用于检测中断状态，同时会清除中断状态。</p><h2><a id="head_head_head_121"></a><a class="header-anchor" href="#不是很明白head-节点是当前独占锁的持有者的意思-注释也说到head一般指的是占有锁的线程-请问从何作出这个判断？-看代码感觉整个阻塞队列-包括head节点-都没有当前占有锁线程的信息">¶</a>不是很明白head 节点是当前独占锁的持有者的意思(注释也说到head一般指的是占有锁的线程)，请问从何作出这个判断？ 看代码感觉整个阻塞队列（包括head节点）都没有当前占有锁线程的信息。</h2><p>这是隐含的信息，ReentrantLock 具有排他性，lock() 方法要么阻塞，要么顺利拿到锁返回。<br>当 lock() 返回的时候，我们说当前线程持有了独占锁，而此时的 head 就是当前线程。<br>（这里说的情况不考虑连 head 都没有初始化的场景）</p><p>这样的说法很容易让人混淆，应该是得分两种情况考虑:<br>1、当前已有别的线程持有锁的时候，head是指向(head.next)下次解锁时即将能持有锁的线程。<br>2、当持有锁的线程unlock时， head 指向的就是当前持有锁的线程 ，但这个时间非常短，因为head马上又会指向一下个即将能持有锁的线程。</p><p>AcquireQueue()里，如果tryacquire()成功，会用setHead(node)将当前获得锁的Node设为Head。</p><h2><a id="_133"></a><a class="header-anchor" href="#为什么如果不满足条件就唤醒下一位">¶</a>为什么如果不满足条件就唤醒下一位</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void cancelAcquire(Node node) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // If we are the tail, remove ourselves.</span><br><span class="line">    if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, null);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int ws;</span><br><span class="line">        /* 这里为什么如果不满足条件就唤醒下一位</span><br><span class="line">         * 第一个条件我是理解的 如果pred是head 那么需要唤醒下一位</span><br><span class="line">         * 因为如果前面是pred ==head 那么这个cancel的线程定时醒来后</span><br><span class="line">         * 如果还没有执行赋值，那么此时持有锁的线程正好开始释放锁，</span><br><span class="line">         * 那么会唤醒第一个阻塞的线程，假设这个线程正好是上面的线程</span><br><span class="line">         * 那么如果此时这个cancel的线程不传递这个唤醒，就会造成</span><br><span class="line">         * 其他线程醒不来， 但是为什么下面两个条件的失败也会唤醒后面的线程？</span><br><span class="line">         */</span><br><span class="line">        if (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != null) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化一下，如果要进入到 else，需要满足：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(ws = pred.waitStatus) != Node.SIGNAL</span><br><span class="line">&amp;&amp;</span><br><span class="line">ws &gt; 0 || (ws &lt;=0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))</span><br></pre></td></tr></table></figure><p>HongJie 2018-04-24 08:00:26<br>转化一下，如果要进入到 else，需要满足：</p><p>(ws = pred.waitStatus) != Node.SIGNAL<br>&amp;&amp;<br>ws &gt; 0 || (ws &lt;=0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))<br>再将其转化为下面两种情况：</p><p>(ws = pred.waitStatus != Node.SIGNAL) &amp;&amp; ws &gt; 0<br>前驱节点处于 CANCELLED 状态，显然是需要唤醒后继节点的，这条很简单</p><p>(ws = pred.waitStatus != Node.SIGNAL) &amp;&amp; (ws &lt;= 0) &amp;&amp; (!compareAndSetWaitStatus(pred, ws, Node.SIGNAL))<br>这种情况下，在将前驱设置为 SIGNAL 的时候失败了，我想到的一种情况是，在 CAS 之前前驱设置为了 CANCELLED</p><p>结合 acquireQueued 方法来看，假设里面的 tryAcquire 抛出异常的场景。</p><h2><a id="predthread__null_154"></a><a class="header-anchor" href="#pred-thread-null">¶</a>pred.thread == null</h2><p>head 是 new Node() 的“空节点”，要是不做唤醒后继节点的话，那。。。你懂的</p><h2><a id="VMmonitormutexAQSReentrantLock_157"></a><a class="header-anchor" href="#vm的monitor最终是使用了-如果升级为重量锁-mutex-操作系统级的支持；能否这样理解-基于aqs的reentrantlock不需要操作系统的锁支持了-所以比较轻？而且也不会升级为重量级锁-本身只是个等待队列而已">¶</a>VM的monitor最终是使用了（如果升级为重量锁）mutex，操作系统级的支持；能否这样理解，基于AQS的ReentrantLock不需要操作系统的锁支持了，所以比较轻？而且也不会升级为重量级锁，本身只是个等待队列而已。</h2><p>我里理解的ReetrantLock 公平锁 和 synchronized 的原理差不多，也有重量级锁，也有升级的步骤。<br>ReetrantLock 首先会采用自旋获取锁（偏向锁），之后的线程进来发现获取不到锁，就加入队列中，如果前驱节点是 head，就会尝试获取一次错，如果没有获取成功，就线程挂起（锁膨胀）。涉及到上下文切换，系统调用。</p><h2><a id="12head_true_h__t__s__hnext__null__161"></a><a class="header-anchor" href="#1队列非空-2队列第一个节点-非head-非当前线程-满足两个条件返回true-那么h-t-s-h-next-null-这样一种场景怎么理解">¶</a>1队列非空，2队列第一个节点（非head）非当前线程 满足两个条件返回true， 那么h != t &amp;&amp; (s = h.next) == null 这样一种场景怎么理解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">    Node t = tail; // Read fields in reverse initialization order</span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    return h != t &amp;&amp;</span><br><span class="line">        ( (s = h.next) == null || s.thread != Thread.currentThread() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你的问题需要到 enq 找答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        if (t == null) &#123;</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                // 看这里</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节点入队时，先成为 tail 然后才设置前驱的 next 属性。<br>那么对应于你的问题，h != t &amp;&amp; h.next == null 对应的就是某个节点现在已经是 tail 了，但是 head.next 还是 null。</p><p>虽然文中没有分析到这个分支，不过还是有些细心的读者对这个很感兴趣的，你也可以往前看下另一个读者的问题，也是针对这个方法的。<br>这里肯定是不会为 null 的，你可以把你认为它可能会为 null 的分析过程描述得详细一些，这样我们比较容易在一个频道上。</p><h2><a id="_171"></a><a class="header-anchor" href="#这个不是个死循环嘛？这么循环怎么能成立的呀？麻烦大神给解释一下">¶</a>这个不是个死循环嘛？这么循环怎么能成立的呀？麻烦大神给解释一下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do &#123; node.prev = pred = pred.prev;  &#125; while (pred.waitStatus &gt; 0);&lt;br&gt;pred = pred.prev</span><br></pre></td></tr></table></figure><p>这里没有死循环呀，一直在沿着队列往前走，找到一个 waitStatus&lt;=0 的节点</p><h2><a id="_175"></a><a class="header-anchor" href="#阻塞队列的头结点是什么时候初始化的呢？">¶</a>阻塞队列的头结点是什么时候初始化的呢？</h2><ol><li>当前队列为空</li><li>2.当有线程阻塞的时候</li></ol><h2><a id="_179"></a><a class="header-anchor" href="#为什么不在锁的构造器里就先建一个阻塞队列的头结点呢？">¶</a>为什么不在锁的构造器里就先建一个阻塞队列的头结点呢？</h2><p>如果没有线程竞争锁的话就是浪费一个节点的空间，Doug Lea大师的注释如下。可见大师的代码一点一滴都体现水平。</p><ul><li>CLH queues need a dummy header node to get started. But</li><li>we don’t create them on construction, because it would be wasted</li><li>effort if there is never contention. Instead, the node</li><li>is constructed and head and tail pointers are set upon first</li><li>contention. ``` 问：阻塞队列的头结点什么时候会被GC呢？ 答：当队列里第一个Node节点得到锁后，该节点会被设置成新的头结点。那么原来“老”的头结点由于没有任何引用指向它，就会被GC回收。</li></ul><h2><a id="nodenodeheadheadprednullhead_187"></a><a class="header-anchor" href="#队列中的线程节点node被唤醒后-node直接变为head-指向原head的指针pred没有被置null-原head节点没法回收吧">¶</a>队列中的线程节点node被唤醒后，node直接变为head，指向原head的指针pred没有被置null，原head节点没法回收吧</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    ...</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                // 拿到锁进来这里</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = null; // help GC</span><br><span class="line">                failed = false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 setHead(node) 方法里面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void setHead(Node node) &#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = null;</span><br><span class="line">    // 这个</span><br><span class="line">    node.prev = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><a id="headstatestatenodewaitStatus_192"></a><a class="header-anchor" href="#head节点的属性是不是state-这个state表示当前锁已经被占用几次了-阻塞队列里的node的属性是waitstatus-代表着阻塞队列里节点的状态-这是两个枚举值完全不相关的属性吗？">¶</a>head节点的属性是不是state，这个state表示当前锁已经被占用几次了。阻塞队列里的node的属性是waitStatus，代表着阻塞队列里节点的状态。这是两个枚举值完全不相关的属性吗？</h2><p>head节点和阻塞队列其它的node都是waitStatus，state是AQS的属性，不相关的</p><h2><a id="_fifo_hnew_Node_t__null__h__t__s__hnext__null__true__hnext__null__Predecessors_Predecessors__true___195"></a><a class="header-anchor" href="#刚初始化-fifo-的时候-h-new-node-t-null-这样子-h-t-s-h-next-null-不是为-true-吗-h-next-null-因为是刚初始化的节点-这样子不是没有-predecessors-嘛-那这个明明没有predecessors-却返回-true-；不是错了吗-是我理解错误吗">¶</a>刚初始化 fifo 的时候，h=new Node(); t = null; 这样子 h != t &amp;&amp; (s = h.next) == null 不是为 true 吗， h.next == null; 因为是刚初始化的节点，这样子不是没有 Predecessors 嘛。那这个明明没有Predecessors 却返回 true ；不是错了吗 是我理解错误吗?</h2><p>只要 head!=tail 就说明有新的节点进来到队列的尾部了，如果 h.next == null, 说明正在初始化节点中，如果不是初始化中的话，只要 Head 的下一个节点不是 刚进来的 thread 的 的Node,如果是的话就说明没有正在等待的节点，<br>对了先补充下这个方法的意思，查询是否有任何线程等待获取比当前线程更长的时间。<br>true如果有排队线前面的当前线程，并 false如果当前线程在队列或队列的头部是空的</p><h2><a id="_cancelAcquire__unparkSuccessornode___pred__head_pred____unparkSuccessornode___nodenext___unpark__unpark__park___unpark__unpark__condition__waiter___201"></a><a class="header-anchor" href="#对于-cancelacquire-的-unparksuccessor-node-会不会唤醒两次呢-如果-pred-head；然后又刚好-pred-线程也要出同步块了-也调用了-unparksuccessor-node-那这个时候-node-next-是不是-会两次-unpark-呢-因为-unpark-会抵消-park-所以-在第一次-unpark-将线程唤醒了-第二次-unpark-将许可证置为可用的-那么下次-condition-的-waiter-会不会-被抵消掉呢">¶</a>对于 cancelAcquire() 的 unparkSuccessor(node); 会不会唤醒两次呢。 如果 pred == head；然后又刚好 pred 线程也要出同步块了 也调用了 unparkSuccessor(node); 那这个时候 node.next 是不是 会两次 unpark() 呢，因为 unpark 会抵消 park() ，所以 在第一次 unpark 将线程唤醒了，第二次 unpark 将许可证置为可用的.那么下次 condition 的 waiter 会不会 被抵消掉呢?</h2><p>你的问题挺有趣的，我没有仔细去推演每一步，不过我觉得其实这也不是什么大问题。仔细想想，即使真的是两次 unpark 了（假设真的如此），大不了就是后面会出现一次 park 直接返回。<br>对于 park 方法，我们本来就是要假设它有可能会无故返回的，被中断或者系统的假唤醒，所以这些代码往往都在循环体中。</p><h2><a id="NodeNode_205"></a><a class="header-anchor" href="#获取锁-释放锁-阻塞队列的node数量不会减少吗？好像没看到在哪里减少阻塞队列里面node的数量？">¶</a>获取锁、释放锁，阻塞队列的Node数量不会减少吗？好像没看到在哪里减少阻塞队列里面Node的数量？</h2><p>因为我们通常并不关心阻塞队列中到底有多少 Node<br>获取到锁的节点会变成head，在那里会把原来的head移出队列<br>在acquireQueued里面获取到同步状态，下面两条语句让Head出列。<br>setHead(node);<br>p.next = null;</p><h2><a id="acquireQueuedheadhead__head_212"></a><a class="header-anchor" href="#在acquirequeued里会做自旋操作-如果前边节点是head就尝试获取锁-如果前面节点不是head-做后面的挂起或者不挂起-这样的话-只有一个节点-就是head后面的那个节点-才会尝试获取锁-这样何来竞争锁的说法呢">¶</a>在acquireQueued里会做自旋操作,如果前边节点是head就尝试获取锁,如果前面节点不是head,做后面的挂起或者不挂起. 这样的话,只有一个节点(就是head后面的那个节点)才会尝试获取锁,这样何来竞争锁的说法呢?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为非公平锁的实现里面，每个新来的线程，是不管队列是否为空，都会先去做一次抢锁的。</span><br></pre></td></tr></table></figure><h2><a id="unparkSuccessors__null__swaitStatus__0waitStatus__1acquireQueuedNode_node_int_argforheadnodepredecessor__headtryAcquireheadnodepredecessor__headtrue_215"></a><a class="header-anchor" href="#在unparksuccessor-方法中-如果s-null-s-waitstatus-0-会从阻塞队列的尾部开始一直向前找-找到最前面一个waitstatus-1的节点-将其唤醒-我的问题是-唤醒之后-该线程从acquirequeued-node-node-int-arg-方法的for循环中醒过来-继续循环-只有当自己的前驱节点为head节点即node-predecessor-head时-才会去tryacquire-抢锁-可是在从后往前找的过程中-并没有看到把当前找寻的目标节点和head节点链接上的步骤啊-这样不就不能判断node-predecessor-head为true吗？也就不能抢锁了">¶</a>在unparkSuccessor（）方法中，如果s == null || s.waitStatus &gt; 0，会从阻塞队列的尾部开始一直向前找，找到最前面一个waitStatus == -1的节点，将其唤醒。我的问题是，唤醒之后，该线程从acquireQueued（Node node, int arg）方法的for循环中醒过来，继续循环，只有当自己的前驱节点为head节点即node.predecessor() == head时，才会去tryAcquire（）抢锁，可是在从后往前找的过程中，并没有看到把当前找寻的目标节点和head节点链接上的步骤啊，这样不就不能判断node.predecessor() == head为true吗？也就不能抢锁了…</h2><p>问题在 acquireQueued 这个方法中。<br>我不清楚你具体的疑惑在哪里，但是你可以看看嵌套在死循环中的 shouldParkAfterFailedAcquire。<br>我觉得 AQS 里面有个比较重要的点是，它总是先保证节点能安全进入到队列中，至于你说的这种边界问题，都在“被动”发现 waitStatus 不对的时候去“纠正”它。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jeff-eric.github.com/blog/blog/2019/10/22/spring%20-%20IOC/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jeff-Eric"><meta itemprop="description" content=""><meta itemprop="image" content="/blog/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="纯天然绿色学渣"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/blog/2019/10/22/spring%20-%20IOC/" class="post-title-link" itemprop="url">spring - IOC</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-22 18:51:56" itemprop="dateCreated datePublished" datetime="2019-10-22T18:51:56+08:00">2019-10-22</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-11-14 17:40:59" itemprop="dateModified" datetime="2019-11-14T17:40:59+08:00">2019-11-14</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/blog/2019/10/22/spring%20-%20IOC/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/2019/10/22/spring%20-%20IOC/" itemprop="commentCount"></span> </a></span><span id="/blog/2019/10/22/spring%20-%20IOC/" class="leancloud_visitors" data-flag-title="spring - IOC"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body han-init-context" itemprop="articleBody"><h1><a id="IOC_1"></a>IOC体系结构</h1><h2><a id="BeanFactory_2"></a><a class="header-anchor" href="#beanfactory">¶</a>BeanFactory</h2><p><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191106110226.png" alt><br>ClassPathXmlApplicationContext 使用代码执行xml文件的类，是一个入口方法<br>通过这个文件向上找，会发现最终会继承ListableBeanFactory、HierarchicalBeanFactory等等一些实现了BeanFactory的抽象类</p><p>所以通过这个入口，我们发现BeanFactory是spring一切的基础，最顶级的抽象类<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191106155603.png" alt></p><ul><li>ListableBeanFactory：可列表化的bean工厂</li><li>HierarchicalBeanFactory：有层级关系的bean工厂（有父子继承关系的）</li><li>AutowireCapableBeanFactory：可自动注入的Bean工厂</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanFactory &#123;</span><br><span class="line">    //对 FactoryBean 的转义定义，因为如果使用 bean 的名字检索 FactoryBean 得到的对象是工厂生成的对象，</span><br><span class="line">    //如果需要得到工厂本身，需要转义</span><br><span class="line">    String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;</span><br><span class="line">    </span><br><span class="line">    //根据 bean 的名字，获取在 IOC 容器中得到 bean 实例</span><br><span class="line">    Object getBean(String name) throws BeansException;</span><br><span class="line">    </span><br><span class="line">    //根据 bean 的名字和 Class 类型来得到 bean 实例，增加了类型安全验证机制。</span><br><span class="line">    Object getBean(String name, Class requiredType) throws BeansException;</span><br><span class="line">    </span><br><span class="line">    //提供对 bean 的检索，看看是否在 IOC 容器有这个名字的 bean</span><br><span class="line">    boolean containsBean(String name);</span><br><span class="line">    </span><br><span class="line">    //根据 bean 名字得到 bean 实例，并同时判断这个 bean 是不是单例</span><br><span class="line">    boolean isSingleton(String name) throws NoSuchBeanDefinitionException;</span><br><span class="line">    </span><br><span class="line">    //得到 bean 实例的 Class 类型</span><br><span class="line">    Class getType(String name) throws NoSuchBeanDefinitionException;</span><br><span class="line">    </span><br><span class="line">    //得到 bean 的别名，如果根据别名检索，那么其原名也会被检索出来</span><br><span class="line">    String[] getAliases(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 BeanFactory 里只对 IOC 容器的基本行为作了定义，根本不关心你的 bean 是如何定义怎样加载的。<br>正如我们只关心工厂里得到什么的产品对象，至于工厂是怎么生产这些对象的，这个基本的接口不关心。</p><p>要知道工厂是如何产生对象的，我们需要看具体的 IOC 容器实现，Spring 提供了许多 IOC 容器的<br>实现。比如 XmlBeanFactory，ClasspathXmlApplicationContext 等。其中 XmlBeanFactory 就是针对最<br>基本的 IOC 容器的实现，这个 IOC 容器可以读取 XML 文件定义的 BeanDefinition（XML 文件中对 bean<br>的描述）,如果说 XmlBeanFactory 是容器中的低配屌丝，ApplicationContext 应该算容器中的高帅富</p><p>从 ApplicationContext 接口的实现，我们看出其特点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,</span><br><span class="line">		MessageSource, ApplicationEventPublisher, ResourcePatternResolver &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.支持信息源，可以实现国际化。（实现 MessageSource 接口）<br>2.访问资源。(实现 ResourcePatternResolver 接口)<br>3.支持应用事件。(实现 ApplicationEventPublisher 接口)</p><h2><a id="BeanDefinition_27"></a><a class="header-anchor" href="#beandefinition">¶</a>BeanDefinition</h2><p>这个主要是存储了bean定义的一些配置信息（其实就是讲xml中配置的信息，保存到BeanDefinition）</p><p>SpringIOC 容器管理了我们定义的各种 Bean 对象及其相互的关系，Bean 对象在 Spring 实现中是以<br>BeanDefinition 来描述的，其继承体系如下：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191106162927.png" alt><br>Bean 的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵<br>活性，以应对可能的变化。Bean 的解析主要就是对 Spring 配置文件的解析。这个解析过程主要通<br>过下图中的类完成：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191106163217.png" alt></p><h1><a id="IOC_38"></a>IOC容器的初始化</h1><p>IOC 容器的初始化包括 BeanDefinition 的 Resource 定位、载入和注册这三个基本的过程</p><ul><li>定位：就是找到定义的xml配置文件在哪里<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191106163655.png" alt></li><li>加载：通过xml解析工具解析xml文件</li><li>注册：将配置信息交给beanFactory，对xml中的bean进行创建生产<br>以ApplicationContext 为例，ApplicationContext 系列容器也许是我们最熟悉的，因为 web 项目中<br>使用的 XmlWebApplicationContext 就属于这个继承体系，还有 ClasspathXmlApplicationContext 等，<br>其继承体系如下图所示：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191106164041.png" alt><br>ApplicationContext 允许上下文嵌套，通过保持父上下文可以维持一个上下文体系。对于 bean 的查找<br>可以在这个上下文体系中发生，首先检查当前上下文，其次是父上下文，逐级向上，这样为不同的 Spring<br>应用提供了一个共享的 bean 定义环境。</li></ul><p>使用FileSystemXmlApplicationContext和使用ClassPathXmlApplicationContext的区别在于：</p><ul><li>FileSystemXmlApplicationContext在指定的文件系统路径下查找xml文件和本项目下的classPath<br>ApplicationContext context = new FileSystemXmlApplicationContext(“C:/bean.xml, classPath: bean.xml”);</li><li>ClassPathXmlApplicationContext是在所有的类路径（包含JAR文件） 下查找xml文件(classPath*)<br>ApplicationContext context = new ClassPathXmlApplicationContext(“bean.xml”);</li></ul><h2><a id="XmlBeanFactory_58"></a><a class="header-anchor" href="#xmlbeanfactory">¶</a>XmlBeanFactory</h2><p>低配BeanFactory的整个流程<br>先看下XmlBeanFactory的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class XmlBeanFactory extends DefaultListableBeanFactory&#123;</span><br><span class="line">    private final XmlBeanDefinitionReader reader;</span><br><span class="line">    public XmlBeanFactory(Resource resource)throws BeansException&#123;</span><br><span class="line">        this(resource, null);</span><br><span class="line">    &#125;</span><br><span class="line">    public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException&#123;</span><br><span class="line">        super(parentBeanFactory);</span><br><span class="line">        this.reader = new XmlBeanDefinitionReader(this);</span><br><span class="line">        this.reader.loadBeanDefinitions(resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还原一下调用过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//根据 Xml 配置文件创建 Resource 资源对象，该对象中包含了 BeanDefinition 的信息</span><br><span class="line">ClassPathResource resource =new ClassPathResource(&quot;application-context.xml&quot;);</span><br><span class="line"></span><br><span class="line">//创建 DefaultListableBeanFactory</span><br><span class="line">DefaultListableBeanFactory factory =new DefaultListableBeanFactory();</span><br><span class="line"></span><br><span class="line">//创建 XmlBeanDefinitionReader 读取器，用于载入 BeanDefinition。之所以需要 BeanFactory 作为参数，是因为会将读取的信息配置回调给 factory</span><br><span class="line">XmlBeanDefinitionReader reader =new XmlBeanDefinitionReader(factory);</span><br><span class="line"></span><br><span class="line">//XmlBeanDefinitionReader 执行载入 BeanDefinition 的方法，最后会完成 Bean 的载入和注册。完成后 Bean 就成功</span><br><span class="line">的放置到 IOC 容器当中，以后我们就可以从中取得 Bean 来使用</span><br><span class="line">reader.loadBeanDefinitions(resource);</span><br></pre></td></tr></table></figure><p>然后我们看下loadBeanDefinitions方法<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191106165946.png" alt><br>其实就是对xml文件的解析，并把解析出来的bean 定义配置回传给factory，让其进行new对象</p><h2><a id="FileSystemXmlApplicationContext_68"></a><a class="header-anchor" href="#filesystemxmlapplicationcontext">¶</a>FileSystemXmlApplicationContext</h2><p>最主要的构造方法，其余构造方法都是调用这个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Create a new FileSystemXmlApplicationContext, loading the definitions</span><br><span class="line">* from the given XML files and automatically refreshing the context.</span><br><span class="line">* @param configLocations array of file paths</span><br><span class="line">* @throws BeansException if context creation failed</span><br><span class="line">*/</span><br><span class="line">public FileSystemXmlApplicationContext(String... configLocations) throws BeansException &#123;</span><br><span class="line">    this(configLocations, true, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public FileSystemXmlApplicationContext(String[] configLocations, boolean refresh,</span><br><span class="line">ApplicationContext parent) throws BeansException &#123;</span><br><span class="line">    // 为了动态的确定用什么加载器去加载配置文件</span><br><span class="line">    super(parent);</span><br><span class="line">    // 告诉读取器reader 配置文件在哪里：定位配置文件，为了加载配置文件</span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    // 刷新</span><br><span class="line">    if (refresh) &#123;</span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为spring的context是可以自定义的，所以如果不设置，则使用默认的资源加载器，如果配置则使用用户自定义的ApplicationContext</p><p>设置资源加载器和资源定位<br>通过分析 FileSystemXmlApplicationContext 的源代码可以知道，在创建<br>FileSystemXmlApplicationContext 容器时，构造方法做以下两项重要工作：<br>1.调用父类容器的构造方法(super(parent)方法)为容器设置好 Bean 资源加载器。<br>2.再调用父类 AbstractRefreshableConfigApplicationContext 的<br>setConfigLocations(configLocations)方法设置 Bean 定义资源文件的定位路径。<br>通过追踪 FileSystemXmlApplicationContext 的继承体系，发现其父类的父类<br>AbstractApplicationContext 中初始化 IOC 容器所做的主要源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext, DisposableBean &#123;</span><br><span class="line">    //静态初始化块，在整个容器创建过程中只执行一次</span><br><span class="line">    static &#123;</span><br><span class="line">        //为了避免应用程序在 Weblogic8.1 关闭时出现类加载异常加载问题，加载 IoC 容器关闭事件(ContextClosedEvent)类</span><br><span class="line">        ContextClosedEvent.class.getName();</span><br><span class="line">    &#125;</span><br><span class="line">    public AbstractApplicationContext() &#123;</span><br><span class="line">        // 解析资源文件，动态的匹配</span><br><span class="line">        this.resourcePatternResolver = getResourcePatternResolver();</span><br><span class="line">    &#125;</span><br><span class="line">    //FileSystemXmlApplicationContext 调用父类构造方法调用的就是该方法</span><br><span class="line">    public AbstractApplicationContext(ApplicationContext parent) &#123;</span><br><span class="line">        this();</span><br><span class="line">        setParent(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    //获取一个 Spring Source 的加载器用于读入 Spring Bean 定义资源文件</span><br><span class="line">    protected ResourcePatternResolver getResourcePatternResolver() &#123;</span><br><span class="line">        //AbstractApplicationContext 继承 DefaultResourceLoader，因此也是一个资源加载器</span><br><span class="line">        //Spring 资源加载器，其 getResource(String location)方法用于载入资源</span><br><span class="line">        return new PathMatchingResourcePatternResolver(this);</span><br><span class="line">    &#125;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractApplicationContext构造方法中调用PathMatchingResourcePatternResolver的构造方法创建<br>Spring 资源加载器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public PathMatchingResourcePatternResolver(ResourceLoader resourceLoader) &#123;</span><br><span class="line">    Assert.notNull(resourceLoader, &quot;ResourceLoader must not be null&quot;);</span><br><span class="line">    //设置 Spring 的资源加载器</span><br><span class="line">    this.resourceLoader = resourceLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在设置容器的资源加载器之后，接下来 FileSystemXmlApplicationContet 执行 setConfigLocations 方<br>法通过调用其父类 AbstractRefreshableConfigApplicationContext 的方法进行对 Bean 定义资源文件<br>的定位，该方法的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//处理单个资源文件路径为一个字符串的情况</span><br><span class="line">public void setConfigLocation(String location) &#123;</span><br><span class="line">    //String CONFIG_LOCATION_DELIMITERS = &quot;,; /t/n&quot;;</span><br><span class="line">    //即多个资源文件路径之间用” ,; /t/n”分隔，解析成数组形式</span><br><span class="line">    setConfigLocations(StringUtils.tokenizeToStringArray(location, CONFIG_LOCATION_DELIMITERS));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//解析 Bean 定义资源文件的路径，处理多个资源文件字符串数组</span><br><span class="line">public void setConfigLocations(String[] locations) &#123;</span><br><span class="line">    if (locations != null) &#123;</span><br><span class="line">        Assert.noNullElements(locations, &quot;Config locations must not be null&quot;);</span><br><span class="line">        this.configLocations = new String[locations.length];</span><br><span class="line">        for (int i = 0; i &lt; locations.length; i++) &#123;</span><br><span class="line">            // resolvePath 将字符串解析为路径的方法</span><br><span class="line">            this.configLocations[i] = resolvePath(locations[i]).trim();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.configLocations = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这两个方法的源码我们可以看出，我们既可以使用一个字符串来配置多个 Spring Bean 定义资源<br>文件，也可以使用字符串数组，即下面两种方式都是可以的：<br>1.ClasspathResource res = new ClasspathResource(“a.xml,b.xml,……”);<br>多个资源文件路径之间可以是用” ,; /t/n”等分隔。<br>2.ClasspathResource res = new ClasspathResource(newString[]{“a.xml”,”b.xml”,……});<br>Spring IOC 容器在初始化时将配置的 Bean 定义资源文件定位为 Spring 封装的 Resource。<br>3.AbstractApplicationContext 的 refresh 函数载入 Bean 定义过程：<br>Spring IOC 容器对 Bean 定义资源的载入是从 refresh()函数开始的，refresh()是一个模板方法，<br>refresh()方法的作用是：在创建 IOC 容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，<br>以保证在 refresh 之后使用的是新建立起来的 IOC 容器。refresh 的作用类似于对 IOC 容器的重启，在<br>新建立好的容器中对容器进行初始化，对 Bean 定义资源进行载入</p><h3><a id="refresh_102"></a><a class="header-anchor" href="#refresh">¶</a>refresh()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public FileSystemXmlApplicationContext(String[] configLocations, boolean refresh,</span><br><span class="line">ApplicationContext parent) throws BeansException &#123;</span><br><span class="line">    // 为了动态的确定用什么加载器去加载配置文件</span><br><span class="line">    super(parent);</span><br><span class="line">    // 告诉读取器reader 配置文件在哪里：定位配置文件，为了加载配置文件</span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    // 刷新</span><br><span class="line">    if (refresh) &#123;</span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FileSystemXmlApplicationContext 通过调用其父类 AbstractApplicationContext 的 refresh()函数启<br>动整个 IoC 容器对 Bean 定义的载入过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">        synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">            //调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识</span><br><span class="line">            prepareRefresh();</span><br><span class="line">            //告诉子类启动 refreshBeanFactory()方法，Bean 定义资源文件的载入从子类的 refreshBeanFactory()方法启动</span><br><span class="line">            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">            //为 BeanFactory 配置容器特性，例如类加载器、事件处理器等</span><br><span class="line">            prepareBeanFactory(beanFactory);</span><br><span class="line">            try &#123;</span><br><span class="line">                //以下三个方法其实都是加载一些所谓的监听器（ApplicationAware/SessionAware等等）</span><br><span class="line">            </span><br><span class="line">                //为容器的某些子类指定特殊的 BeanPost 事件处理器</span><br><span class="line">                //比如监听spring是否启动，ApplicationAware中的setApplicationContext方法就可以进行一些容器初始化事件操作</span><br><span class="line">                postProcessBeanFactory(beanFactory);</span><br><span class="line">                //调用所有注册的 BeanFactoryPostProcessor 的 Bean</span><br><span class="line">                invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">                //为 BeanFactory 注册 BeanPost 事件处理器.</span><br><span class="line">                //BeanPostProcessor 是 Bean 后置处理器，用于监听容器触发的事件</span><br><span class="line">                registerBeanPostProcessors(beanFactory);</span><br><span class="line">                </span><br><span class="line">                //初始化信息源，和国际化相关.</span><br><span class="line">                initMessageSource();</span><br><span class="line">                </span><br><span class="line">                //初始化容器事件传播器.</span><br><span class="line">                initApplicationEventMulticaster();</span><br><span class="line">                //调用子类的某些特殊 Bean 初始化方法</span><br><span class="line">                onRefresh();</span><br><span class="line">                //为事件传播器注册事件监听器.</span><br><span class="line">                registerListeners();</span><br><span class="line">                //初始化所有剩余的单例 Bean.</span><br><span class="line">                finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">                //初始化容器的生命周期事件处理器，并发布容器的生命周期事件</span><br><span class="line">                finishRefresh();</span><br><span class="line">            &#125; catch (BeansException ex) &#123;</span><br><span class="line">                //销毁以创建的单态 Bean</span><br><span class="line">                destroyBeans();</span><br><span class="line">                //取消 refresh 操作，重置容器的同步标识.</span><br><span class="line">                cancelRefresh(ex);</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>refresh()方法主要为 IOC 容器 Bean 的生命周期管理提供条件，Spring IOC 容器载入 Bean 定义资源文<br>件从其子类容器的 refreshBeanFactory()方法启动，所以整个 refresh()中<br>“ConfigurableListableBeanFactory beanFactory =obtainFreshBeanFactory();”这句以后代码的<br>都是注册容器的信息源和生命周期事件，载入过程就是从这句代码启动。</p><p>refresh()方法的作用是：在创建 IOC 容器前，如果已经有容器存在，则需要把已有的容器销毁和关<br>闭，以保证在 refresh 之后使用的是新建立起来的 IOC 容器。refresh 的作用类似于对 IOC 容器的重启，<br>在新建立好的容器中对容器进行初始化，对 Bean 定义资源进行载入</p><p>AbstractApplicationContext的obtainFreshBeanFactory()方法调用子类容器的refreshBeanFactory()<br>方法，启动容器载入 Bean 定义资源文件的过程，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;</span><br><span class="line">    //这里使用了委派设计模式，父类定义了抽象的 refreshBeanFactory()方法，具体实现调用子类容器的refreshBeanFactory()方法</span><br><span class="line">    refreshBeanFactory();</span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">    if (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    return beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractApplicationContext 子类的 refreshBeanFactory()方法：<br>AbstractApplicationContext 类中只抽象定义了 refreshBeanFactory()方法，容器真正调用的是<br>其子类AbstractRefreshableApplicationContext实现的refreshBeanFactory()方法，方法的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected final void refreshBeanFactory() throws BeansException &#123;</span><br><span class="line">    //如果已经有容器，销毁容器中的 bean，关闭容器</span><br><span class="line">    if (hasBeanFactory()) &#123;</span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        //创建 IOC 容器</span><br><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        //对 IOC 容器进行定制化，如设置启动参数，开启注解的自动装配等</span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line">        //调用载入 Bean 定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的 loadBeanDefinitions方法，具体的实现调用子类容器</span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        synchronized (this.beanFactoryMonitor) &#123;</span><br><span class="line">            this.beanFactory = beanFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;catch (IOException ex) &#123;</span><br><span class="line">        throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，先判断 BeanFactory 是否存在，如果存在则先销毁 beans 并关闭 beanFactory，接着创<br>建 DefaultListableBeanFactory，并调用 loadBeanDefinitions(beanFactory)装载 bean 定义。</p><p>AbstractRefreshableApplicationContext 子类的 loadBeanDefinitions 方法：<br>AbstractRefreshableApplicationContext 中只定义了抽象的 loadBeanDefinitions 方法，容器真正调<br>用的是其子类 AbstractXmlApplicationContext 对该方法的实现，AbstractXmlApplicationContext 的<br>主要源码如下：<br>loadBeanDefinitions 方法同样是抽象方法，是由其子类实现的，也即在<br>AbstractXmlApplicationContext 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractXmlApplicationContext extends AbstractRefreshableConfigApplicationContext &#123;</span><br><span class="line">    </span><br><span class="line">    ……</span><br><span class="line"></span><br><span class="line">    //实现父类抽象的载入 Bean 定义方法</span><br><span class="line">    @Override</span><br><span class="line">    protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException,</span><br><span class="line">            IOException &#123;</span><br><span class="line">        //创建 XmlBeanDefinitionReader，即创建 Bean 读取器，并通过回调设置到容器中去，容 器使用该读取器读取 Bean 定义资源</span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">        //为 Bean 读取器设置 Spring 资源加载器，AbstractXmlApplicationContext 的祖先父类 AbstractApplicationContext 继承 DefaultResourceLoader，因此，容器本身也是一个资源加载器</span><br><span class="line">        beanDefinitionReader.setEnvironment(this.getEnvironment());</span><br><span class="line">        beanDefinitionReader.setResourceLoader(this);</span><br><span class="line">        //为 Bean 读取器设置 SAX xml 解析器</span><br><span class="line">        beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</span><br><span class="line">        //当 Bean 读取器读取 Bean 定义的 Xml 资源文件时，启用 Xml 的校验机制</span><br><span class="line">        initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">        //Bean 读取器真正实现加载的方法</span><br><span class="line">        loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //Xml Bean 读取器加载 Bean 定义资源</span><br><span class="line">    protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException,IOException &#123;</span><br><span class="line">        //获取 Bean 定义资源的定位</span><br><span class="line">        Resource[] configResources = getConfigResources();</span><br><span class="line">        if (configResources != null) &#123;</span><br><span class="line">            //Xml Bean 读取器调用其父类 AbstractBeanDefinitionReader 读取定位的 Bean 定义资源</span><br><span class="line">            reader.loadBeanDefinitions(configResources);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子类中获取的 Bean 定义资源定位为空，则获取 FileSystemXmlApplicationContext 构造方法中setConfigLocations 方法设置的资源</span><br><span class="line">        String[] configLocations = getConfigLocations();</span><br><span class="line">        if (configLocations != null) &#123;</span><br><span class="line">            //Xml Bean 读取器调用其父类 AbstractBeanDefinitionReader 读取定位的 Bean 定义资源</span><br><span class="line">            reader.loadBeanDefinitions(configLocations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //这里又使用了一个委托模式，调用子类的获取 Bean 定义资源定位的方法</span><br><span class="line">    //该方法在 ClassPathXmlApplicationContext 中进行实现，对于我们</span><br><span class="line">    //举例分析源码的 FileSystemXmlApplicationContext 没有使用该方法</span><br><span class="line">    protected Resource[] getConfigResources() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125; </span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Xml Bean 读取器(XmlBeanDefinitionReader)调用其父类 AbstractBeanDefinitionReader<br>的 reader.loadBeanDefinitions 方法读取 Bean 定义资源。</p><p>由于我们使用 FileSystemXmlApplicationContext 作为例子分析，因此 getConfigResources 的返回值<br>为 null，因此程序执行 reader.loadBeanDefinitions(configLocations)分支。</p><p>AbstractBeanDefinitionReader 读取 Bean 定义资源：<br>AbstractBeanDefinitionReader 的 loadBeanDefinitions 方法源码如下<br>可以到 org.springframework.beans.factory.support 看一下 BeanDefinitionReader 的结构<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191106202131.png" alt></p><p>在其抽象父类 AbstractBeanDefinitionReader 中定义了载入过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">//重载方法，调用下面的 loadBeanDefinitions(String, Set&lt;Resource&gt;);方法</span><br><span class="line">public int loadBeanDefinitions(String location) throws BeanDefinitionStoreException &#123;</span><br><span class="line">    return loadBeanDefinitions(location, null);</span><br><span class="line">&#125;</span><br><span class="line">public int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException &#123;</span><br><span class="line">    //获取在 IoC 容器初始化过程中设置的资源加载器</span><br><span class="line">    ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">    if (resourceLoader == null) &#123;</span><br><span class="line">        throw new BeanDefinitionStoreException(</span><br><span class="line">                &quot;Cannot import bean definitions from location [&quot; + location + &quot;]: no ResourceLoader</span><br><span class="line">                available&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (resourceLoader instanceof ResourcePatternResolver) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //将指定位置的 Bean 定义资源文件解析为 Spring IOC 容器封装的资源</span><br><span class="line">            //加载多个指定位置的 Bean 定义资源文件</span><br><span class="line">            // ResourcePatternResolver就是多个文件解析器，就是下面说到的多个文件可以使用，；等符号进行分割</span><br><span class="line">            Resource[] resources = ((ResourcePatternResolver)resourceLoader).getResources(location);</span><br><span class="line">            //委派调用其子类 XmlBeanDefinitionReader 的方法，实现加载功能</span><br><span class="line">            int loadCount = loadBeanDefinitions(resources);</span><br><span class="line">            if (actualResources != null) &#123;</span><br><span class="line">                for (Resource resource : resources) &#123;</span><br><span class="line">                    actualResources.add(resource);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location pattern [&quot; +</span><br><span class="line">                        location + &quot;]&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            return loadCount;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (IOException ex) &#123;</span><br><span class="line">            throw new BeanDefinitionStoreException(&quot;Could not resolve bean definition resource pattern [&quot; + location + &quot;]&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //将指定位置的 Bean 定义资源文件解析为 Spring IOC 容器封装的资源</span><br><span class="line">        //加载单个指定位置的 Bean 定义资源文件</span><br><span class="line">        // AbstractXmlApplicationContext line 89 设置了默认的资源加载器</span><br><span class="line">        Resource resource = resourceLoader.getResource(location);</span><br><span class="line">        //委派调用其子类 XmlBeanDefinitionReader 的方法，实现加载功能</span><br><span class="line">        int loadCount = loadBeanDefinitions(resource);</span><br><span class="line">        if (actualResources != null) &#123;</span><br><span class="line">            actualResources.add(resource);</span><br><span class="line">        &#125;</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location [&quot; + location +</span><br><span class="line">                    &quot;]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return loadCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//重载方法，调用 loadBeanDefinitions(String);</span><br><span class="line">public int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException &#123;</span><br><span class="line">    Assert.notNull(locations, &quot;Location array must not be null&quot;);</span><br><span class="line">    int counter = 0;</span><br><span class="line">    for (String location : locations) &#123;</span><br><span class="line">        counter += loadBeanDefinitions(location);</span><br><span class="line">    &#125;</span><br><span class="line">    return counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadBeanDefinitions(Resource…resources)方法和上面分析的 3 个方法类似，同样也是调用<br>XmlBeanDefinitionReader 的 loadBeanDefinitions 方法。</p><p>从对 AbstractBeanDefinitionReader 的 loadBeanDefinitions 方法源码分析可以看出该方法做了以下<br>两件事：</p><ul><li>调用资源加载器的获取资源方法 resourceLoader.getResource(location)，获取到要加载的资源。</li><li>真正执行加载功能是其子类 XmlBeanDefinitionReader 的 loadBeanDefinitions 方法。<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191106202401.png" alt><br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191106202419.png" alt></li></ul><p>看到第 8、16 行，结合上面的 ResourceLoader 与 ApplicationContext 的继承系图，可以知道此时调用<br>的是 DefaultResourceLoader 中的 getSource()方法定位 Resource，因为<br>FileSystemXmlApplicationContext 本身就是 DefaultResourceLoader 的实现类，所以此时又回到了<br>FileSystemXmlApplicationContext 中来。</p><p>资源加载器获取要读入的资源：<br>XmlBeanDefinitionReader 通过调用其父类 DefaultResourceLoader 的 getResource 方法获取要加载的<br>资源，其源码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//获取 Resource 的具体实现方法</span><br><span class="line">public Resource getResource(String location) &#123;</span><br><span class="line">    Assert.notNull(location, &quot;Location must not be null&quot;);</span><br><span class="line">    //如果是类路径的方式，那需要使用 ClassPathResource 来得到 bean 文件的资源对象</span><br><span class="line">    if (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line">        return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()),getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 如果是 URL 方式，使用 UrlResource 作为 bean 文件的资源对象</span><br><span class="line">        URL url = new URL(location);</span><br><span class="line">        return new UrlResource(url);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (MalformedURLException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果既不是 classpath 标识，又不是 URL 标识的 Resource 定位，则调用</span><br><span class="line">    //容器本身的 getResourceByPath 方法获取 Resource</span><br><span class="line">    return getResourceByPath(location);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FileSystemXmlApplicationContext 容器提供了 getResourceByPath 方法的实现，就是为了处理既不是<br>classpath 标识，又不是 URL 标识的 Resource 定位这种情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected Resource getResourceByPath(String path) &#123;</span><br><span class="line">    if (path != null &amp;&amp; path.startsWith(&quot;/&quot;)) &#123;</span><br><span class="line">        path = path.substring(1);</span><br><span class="line">    &#125;</span><br><span class="line">    //这里使用文件系统资源对象来定义 bean 文件</span><br><span class="line">    return new FileSystemResource(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样代码就回到了 FileSystemXmlApplicationContext 中来，他提供了 FileSystemResource 来完<br>成从文件系统得到配置文件的资源定义。</p><p>这样，就可以从文件系统路径上对 IOC 配置文件进行加载 - 当然我们可以按照这个逻辑从任何地方<br>加载，在 Spring 中我们看到它提供 的各种资源抽象，比如<br>ClassPathResource, URLResource,FileSystemResource 等来供我们使用。上面我们看到的是定位<br>Resource 的一个过程，而这只是加载过程的一部分.</p><h3><a id="XmlBeanDefinitionReader__Bean__177"></a><a class="header-anchor" href="#xmlbeandefinitionreader-加载-bean-定义资源">¶</a>XmlBeanDefinitionReader 加载 Bean 定义资源</h3><p>Bean 定义的 Resource 得到了</p><p>继续回到 XmlBeanDefinitionReader 的 loadBeanDefinitions(Resource …)方法看到代表 bean 文<br>件的资源定义以后的载入过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//XmlBeanDefinitionReader 加载资源的入口方法</span><br><span class="line">    public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">        //将读入的 XML 资源进行特殊编码处理</span><br><span class="line">        return loadBeanDefinitions(new EncodedResource(resource));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //这里是载入 XML 形式 Bean 定义资源文件方法</span><br><span class="line">    public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">        .......</span><br><span class="line">        // 主要去除配置文件的循环依赖</span><br><span class="line">		Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">		if (currentResources == null) &#123;</span><br><span class="line">			currentResources = new HashSet&lt;EncodedResource&gt;(4);</span><br><span class="line">			this.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">		&#125;</span><br><span class="line">		if (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">			throw new BeanDefinitionStoreException(</span><br><span class="line">					&quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            //将资源文件转为 InputStream 的 IO 流</span><br><span class="line">            InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">            try &#123;</span><br><span class="line">                //从 InputStream 中得到 XML 的解析源</span><br><span class="line">                InputSource inputSource = new InputSource(inputStream);</span><br><span class="line">                if (encodedResource.getEncoding() != null) &#123;</span><br><span class="line">                    inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">                &#125;</span><br><span class="line">                //这里是具体的读取过程</span><br><span class="line">                return doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                //关闭从 Resource 中得到的 IO 流</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .........</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //从特定 XML 文件中实际载入 Bean 定义资源的方法</span><br><span class="line">    protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int validationMode = getValidationModeForResource(resource);</span><br><span class="line">            //将 XML 文件转换为 DOM 对象，解析过程由 documentLoader 实现</span><br><span class="line">            Document doc = this.documentLoader.loadDocument(</span><br><span class="line">                    inputSource, this.entityResolver, this.errorHandler, validationMode,</span><br><span class="line">                    this.namespaceAware);</span><br><span class="line">            //这里是启动对 Bean 定义解析的详细过程，该解析过程会用到 Spring 的 Bean 配置规则</span><br><span class="line">            return registerBeanDefinitions(doc, resource);</span><br><span class="line">        &#125;</span><br><span class="line">.......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过源码分析，载入 Bean 定义资源文件的最后一步是将 Bean 定义资源转换为 Document 对象，该过程<br>由 documentLoader 实现</p><p>DocumentLoader 将 Bean 定义资源转换为 Document 对象：<br>DocumentLoader 将 Bean 定义资源转换成 Document 对象的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//使用标准的 JAXP 将载入的 Bean 定义资源转换成 document 对象</span><br><span class="line">    public Document loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception &#123;</span><br><span class="line">        //创建文件解析器工厂</span><br><span class="line">        DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode,</span><br><span class="line">                namespaceAware);</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(&quot;Using JAXP provider [&quot; + factory.getClass().getName() + &quot;]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //创建文档解析器</span><br><span class="line">        DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line">        //解析 Spring 的 Bean 定义资源</span><br><span class="line">        return builder.parse(inputSource);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected DocumentBuilderFactory createDocumentBuilderFactory(int validationMode, boolean namespaceAware) throws ParserConfigurationException &#123;</span><br><span class="line">        //创建文档解析工厂</span><br><span class="line">        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">        factory.setNamespaceAware(namespaceAware);</span><br><span class="line">        //设置解析 XML 的校验</span><br><span class="line">        if (validationMode != XmlValidationModeDetector.VALIDATION_NONE) &#123;</span><br><span class="line">            factory.setValidating(true);</span><br><span class="line">            if (validationMode == XmlValidationModeDetector.VALIDATION_XSD) &#123;</span><br><span class="line">                factory.setNamespaceAware(true);</span><br><span class="line">                try &#123;</span><br><span class="line">                    factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);</span><br><span class="line">                &#125; catch (IllegalArgumentException ex) &#123;</span><br><span class="line">                    ParserConfigurationException pcex = new ParserConfigurationException(</span><br><span class="line">                            &quot;Unable to validate using XSD: Your JAXP provider [&quot; + factory +</span><br><span class="line">                                    &quot;] does not support XML Schema. Are you running on Java 1.with Apache Crimson?</span><br><span class="line">                            &quot; +</span><br><span class="line">                            &quot;Upgrade to Apache Xerces (or Java 1.5) for full XSD support.&quot;);</span><br><span class="line">                    pcex.initCause(ex);</span><br><span class="line">                    throw pcex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该解析过程调用 JavaEE 标准的 JAXP 标准进行处理。<br>至此 Spring IOC 容器根据定位的 Bean 定义资源文件，将其加载读入并转换成为 Document 对象过程完成。<br>接下来我们要继续分析 Spring IOC 容器将载入的 Bean 定义资源文件转换为 Document 对象之后，是如<br>何将其解析为 Spring IOC 管理的 Bean 对象并将其注册到容器中的。</p><h3><a id="XmlBeanDefinitionReader__Bean__195"></a><a class="header-anchor" href="#xmlbeandefinitionreader-解析载入的-bean-定义资源文件">¶</a>XmlBeanDefinitionReader 解析载入的 Bean 定义资源文件</h3><p>XmlBeanDefinitionReader类中的doLoadBeanDefinitions方法是从特定XML 文件中实际载入Bean 定<br>义资源的方法，该方法在载入 Bean 定义资源之后将其转换为 Document 对象，接下来调用<br>registerBeanDefinitions 启动 Spring IOC 容器对 Bean 定义的解析过程，registerBeanDefinitions<br>方法源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//按照 Spring 的 Bean 语义要求将 Bean 定义资源解析并转换为容器内部数据结构</span><br><span class="line">public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">    //得到 BeanDefinitionDocumentReader 来对 xml 格式的 BeanDefinition 解析</span><br><span class="line">    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">    //获得容器中注册的 Bean 数量</span><br><span class="line">    int countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">    //解析过程入口，这里使用了委派模式，BeanDefinitionDocumentReader 只是个接口，</span><br><span class="line">    //具体的解析实现过程有实现类 DefaultBeanDefinitionDocumentReader 完成</span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">    //统计解析的 Bean 数量</span><br><span class="line">    return getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line">//创建 BeanDefinitionDocumentReader 对象，解析 Document 对象</span><br><span class="line">protected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() &#123;</span><br><span class="line">    return BeanDefinitionDocumentReader.class.cast(BeanUtils.instantiateClass(this.documentReaderClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bean 定义资源的载入解析分为以下两个过程：</p><ul><li>首先，通过调用 XML 解析器将 Bean 定义资源文件转换得到 Document 对象，但是这些 Document 对象并没有按照 Spring 的 Bean 规则进行解析。这一步是载入的过程</li><li>在完成通用的 XML 解析之后，按照 Spring 的 Bean 规则对 Document 对象进行解析。</li></ul><p>按照 Spring 的 Bean 规则对 Document 对象解析的过程是在接口 BeanDefinitionDocumentReader 的实现<br>类 DefaultBeanDefinitionDocumentReader 中实现的。</p><h3><a id="DefaultBeanDefinitionDocumentReader__Bean__Document__208"></a><a class="header-anchor" href="#defaultbeandefinitiondocumentreader-对-bean-定义的-document-对象解析">¶</a>DefaultBeanDefinitionDocumentReader 对 Bean 定义的 Document 对象解析</h3><p>BeanDefinitionDocumentReader 接口通过 registerBeanDefinitions 方法调用其实现类<br>DefaultBeanDefinitionDocumentReader 对 Document 对象进行解析，解析的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">//根据 Spring DTD 对 Bean 的定义规则解析 Bean 定义 Document 对象</span><br><span class="line">    public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123;</span><br><span class="line">        //获得 XML 描述符</span><br><span class="line">        this.readerContext = readerContext;</span><br><span class="line">        logger.debug(&quot;Loading bean definitions&quot;);</span><br><span class="line">        //获得 Document 的根元素</span><br><span class="line">        Element root = doc.getDocumentElement();</span><br><span class="line">        //具体的解析过程由 BeanDefinitionParserDelegate 实现，</span><br><span class="line">        //BeanDefinitionParserDelegate 中定义了 Spring Bean 定义 XML 文件的各种元素</span><br><span class="line">        BeanDefinitionParserDelegate delegate = createHelper(readerContext, root);</span><br><span class="line">        //在解析 Bean 定义之前，进行自定义的解析，增强解析过程的可扩展性</span><br><span class="line">        preProcessXml(root);</span><br><span class="line">        //从 Document 的根元素开始进行 Bean 定义的 Document 对象</span><br><span class="line">        parseBeanDefinitions(root, delegate);</span><br><span class="line">        //在解析 Bean 定义之后，进行自定义的解析，增加解析过程的可扩展性</span><br><span class="line">        postProcessXml(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //创建 BeanDefinitionParserDelegate，用于完成真正的解析过程</span><br><span class="line">    protected BeanDefinitionParserDelegate createHelper(XmlReaderContext readerContext, Element root) &#123;</span><br><span class="line">        BeanDefinitionParserDelegate delegate = new BeanDefinitionParserDelegate(readerContext);</span><br><span class="line">        //BeanDefinitionParserDelegate 初始化 Document 根元素</span><br><span class="line">        delegate.initDefaults(root);</span><br><span class="line">        return delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用 Spring 的 Bean 规则从 Document 的根元素开始进行 Bean 定义的 Document 对象</span><br><span class="line">    protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">        //Bean 定义的 Document 对象使用了 Spring 默认的 XML 命名空间</span><br><span class="line">        if (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">            //获取 Bean 定义的 Document 对象根元素的所有子节点</span><br><span class="line">            NodeList nl = root.getChildNodes();</span><br><span class="line">            for (int i = 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">                Node node = nl.item(i);</span><br><span class="line">                //获得 Document 节点是 XML 元素节点</span><br><span class="line">                if (node instanceof Element) &#123;</span><br><span class="line">                    Element ele = (Element) node;</span><br><span class="line">                    //Bean 定义的 Document 的元素节点使用的是 Spring 默认的 XML 命名空间</span><br><span class="line">                    if (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                        //使用 Spring 的 Bean 规则解析元素节点</span><br><span class="line">                        parseDefaultElement(ele, delegate);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        //没有使用 Spring 默认的 XML 命名空间，则使用用户自定义的解析规则解析元素节点</span><br><span class="line">                        delegate.parseCustomElement(ele);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //Document 的根节点没有使用 Spring 默认的命名空间，则使用用户自定义的解析规则解析 Document 根节点</span><br><span class="line">            delegate.parseCustomElement(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用 Spring 的 Bean 规则解析 Document 元素节点</span><br><span class="line">    private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">        //如果元素节点是&lt;Import&gt;导入元素，进行导入解析</span><br><span class="line">        if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">            importBeanDefinitionResource(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果元素节点是&lt;Alias&gt;别名元素，进行别名解析</span><br><span class="line">        else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">            processAliasRegistration(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        //元素节点既不是导入元素，也不是别名元素，即普通的&lt;Bean&gt;元素，</span><br><span class="line">        //按照 Spring 的 Bean 规则解析元素</span><br><span class="line">        else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">            processBeanDefinition(ele, delegate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //解析&lt;Import&gt;导入元素，从给定的导入路径加载 Bean 定义资源到 Spring IoC 容器中</span><br><span class="line">    protected void importBeanDefinitionResource(Element ele) &#123;</span><br><span class="line">        //获取给定的导入元素的 location 属性</span><br><span class="line">        String location = ele.getAttribute(RESOURCE_ATTRIBUTE);</span><br><span class="line">        //如果导入元素的 location 属性值为空，则没有导入任何资源，直接返回</span><br><span class="line">        if (!StringUtils.hasText(location)) &#123;</span><br><span class="line">            getReaderContext().error(&quot;Resource location must not be empty&quot;, ele);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //使用系统变量值解析 location 属性值</span><br><span class="line">        location = SystemPropertyUtils.resolvePlaceholders(location);</span><br><span class="line">        Set&lt;Resource&gt; actualResources = new LinkedHashSet&lt;Resource&gt;(4);</span><br><span class="line">        //标识给定的导入元素的 location 是否是绝对路径</span><br><span class="line">        boolean absoluteLocation = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            absoluteLocation = ResourcePatternUtils.isUrl(location) ||</span><br><span class="line">                    ResourceUtils.toURI(location).isAbsolute();</span><br><span class="line">        &#125; catch (URISyntaxException ex) &#123;</span><br><span class="line">            //给定的导入元素的 location 不是绝对路径</span><br><span class="line">        &#125;</span><br><span class="line">        //给定的导入元素的 location 是绝对路径</span><br><span class="line">        if (absoluteLocation) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //使用资源读入器加载给定路径的 Bean 定义资源</span><br><span class="line">                int importCount = getReaderContext().getReader().loadBeanDefinitions(location,</span><br><span class="line">                        actualResources);</span><br><span class="line">                if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(&quot;Imported &quot; + importCount + &quot; bean definitions from URL location [&quot; +</span><br><span class="line">                            location + &quot;]&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">                getReaderContext().error(</span><br><span class="line">                        &quot;Failed to import bean definitions from URL location [&quot; + location + &quot;]&quot;, ele, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //给定的导入元素的 location 是相对路径</span><br><span class="line">            try &#123;</span><br><span class="line">                int importCount;</span><br><span class="line">                //将给定导入元素的 location 封装为相对路径资源</span><br><span class="line">                Resource relativeResource = getReaderContext().getResource().createRelative(location);</span><br><span class="line">                //封装的相对路径资源存在</span><br><span class="line">                if (relativeResource.exists()) &#123;</span><br><span class="line">                    //使用资源读入器加载 Bean 定义资源</span><br><span class="line">                    importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);</span><br><span class="line">                    actualResources.add(relativeResource);</span><br><span class="line">                &#125;</span><br><span class="line">                //封装的相对路径资源不存在</span><br><span class="line">                else &#123;</span><br><span class="line">                    //获取 Spring IOC 容器资源读入器的基本路径</span><br><span class="line">                    String baseLocation = getReaderContext().getResource().getURL().toString();</span><br><span class="line">                    //根据 Spring IoC 容器资源读入器的基本路径加载给定导入路径的资源</span><br><span class="line">                    importCount = getReaderContext().getReader().loadBeanDefinitions(</span><br><span class="line">                            StringUtils.applyRelativePath(baseLocation, location), actualResources);</span><br><span class="line">                &#125;</span><br><span class="line">                if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(&quot;Imported &quot; + importCount + &quot; bean definitions from relative location [&quot;</span><br><span class="line">                            + location + &quot;]&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException ex) &#123;</span><br><span class="line">                getReaderContext().error(&quot;Failed to resolve current resource location&quot;, ele, ex);</span><br><span class="line">            &#125; catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">                getReaderContext().error(&quot;Failed to import bean definitions from relative location [&quot; +</span><br><span class="line">                                location + &quot;]&quot;,</span><br><span class="line">                        ele, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Resource[] actResArray = actualResources.toArray(new Resource[actualResources.size()]);</span><br><span class="line">        //在解析完&lt;Import&gt;元素之后，发送容器导入其他资源处理完成事件</span><br><span class="line">        getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //解析&lt;Alias&gt;别名元素，为 Bean 向 Spring IoC 容器注册别名</span><br><span class="line">    protected void processAliasRegistration(Element ele) &#123;</span><br><span class="line">        //获取&lt;Alias&gt;别名元素中 name 的属性值</span><br><span class="line">        String name = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">        //获取&lt;Alias&gt;别名元素中 alias 的属性值</span><br><span class="line">        String alias = ele.getAttribute(ALIAS_ATTRIBUTE);</span><br><span class="line">        boolean valid = true;</span><br><span class="line">        //&lt;alias&gt;别名元素的 name 属性值为空</span><br><span class="line">        if (!StringUtils.hasText(name)) &#123;</span><br><span class="line">            getReaderContext().error(&quot;Name must not be empty&quot;, ele);</span><br><span class="line">            valid = false;</span><br><span class="line">        &#125;</span><br><span class="line">        //&lt;alias&gt;别名元素的 alias 属性值为空</span><br><span class="line">        if (!StringUtils.hasText(alias)) &#123;</span><br><span class="line">            getReaderContext().error(&quot;Alias must not be empty&quot;, ele);</span><br><span class="line">            valid = false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (valid) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //向容器的资源读入器注册别名</span><br><span class="line">                getReaderContext().getRegistry().registerAlias(name, alias);</span><br><span class="line">            &#125; catch (Exception ex) &#123;</span><br><span class="line">                getReaderContext().error(&quot;Failed to register alias &apos;&quot; + alias +</span><br><span class="line">                        &quot;&apos; for bean with name &apos;&quot; + name + &quot;&apos;&quot;, ele, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            //在解析完&lt;Alias&gt;元素之后，发送容器别名处理完成事件</span><br><span class="line">            getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //解析 Bean 定义资源 Document 对象的普通元素</span><br><span class="line">    protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">        // BeanDefinitionHolder 是对 BeanDefinition 的封装，即 Bean 定义的封装类</span><br><span class="line">        //对 Document 对象中&lt;Bean&gt;元素的解析由 BeanDefinitionParserDelegate 实现 BeanDefinitionHolder</span><br><span class="line">        bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">        if (bdHolder != null) &#123;</span><br><span class="line">            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">            try &#123;</span><br><span class="line">                //向 Spring IoC 容器注册解析得到的 Bean 定义，这是 Bean 定义向 IOC 容器注册的入口</span><br><span class="line">                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder,</span><br><span class="line">                        getReaderContext().getRegistry());</span><br><span class="line">            &#125; catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">                getReaderContext().error(&quot;Failed to register bean definition with name &apos;&quot; +</span><br><span class="line">                        bdHolder.getBeanName() + &quot;&apos;&quot;, ele, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            //在完成向 Spring IoC 容器注册解析得到的 Bean 定义之后，发送注册事件</span><br><span class="line">            getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过上述 Spring IOC 容器对载入的 Bean 定义 Document 解析可以看出，我们使用 Spring 时，在 Spring<br>配置文件中可以使用<code>&lt;Import&gt;</code>元素来导入 IOC 容器所需要的其他资源，Spring IoC 容器在解析时会首<br>先将指定导入的资源加载进容器中。使用<code>&lt;Ailas&gt;</code>别名时，Spring IOC 容器首先将别名元素所定义的别<br>名注册到容器中。</p><p>对于既不是<code>&lt;Import&gt;</code>元素，又不是<code>&lt;Alias&gt;</code>元素的元素，即 Spring 配置文件中普通的<code>&lt;Bean&gt;</code>元素的解析<br>由 BeanDefinitionParserDelegate 类的 parseBeanDefinitionElement 方法来实现。</p><h3><a id="BeanDefinitionParserDelegate__Bean_Bean_220"></a><a class="header-anchor" href="#beandefinitionparserdelegate-解析-bean-定义资源文件中的-bean-元素">¶</a>BeanDefinitionParserDelegate 解析 Bean 定义资源文件中的<code>&lt;Bean&gt;</code>元素</h3><p>Bean 定义资源文件中的<code>&lt;Import&gt;</code>和<code>&lt;Alias&gt;</code>元素解析在 DefaultBeanDefinitionDocumentReader 中已经<br>完成，对 Bean 定义资源文件中使用最多的<code>&lt;Bean&gt;</code>元素交由 BeanDefinitionParserDelegate 来解析，其解析实现的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">//解析&lt;Bean&gt;元素的入口</span><br><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) &#123;</span><br><span class="line">    return parseBeanDefinitionElement(ele, null);</span><br><span class="line">&#125;</span><br><span class="line">//解析 Bean 定义资源文件中的&lt;Bean&gt;元素，这个方法中主要处理&lt;Bean&gt;元素的 id，name和别名属性</span><br><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition</span><br><span class="line">        containingBean) &#123;</span><br><span class="line">    //获取&lt;Bean&gt;元素中的 id 属性值</span><br><span class="line">    String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">    //获取&lt;Bean&gt;元素中的 name 属性值</span><br><span class="line">    String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">    //获取&lt;Bean&gt;元素中的 alias 属性值</span><br><span class="line">    List&lt;String&gt; aliases = new ArrayList&lt;String&gt;();</span><br><span class="line">    //将&lt;Bean&gt;元素中的所有 name 属性值存放到别名中</span><br><span class="line">    if (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, BEAN_NAME_DELIMITERS);</span><br><span class="line">        aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">    &#125;</span><br><span class="line">    String beanName = id;</span><br><span class="line">    //如果&lt;Bean&gt;元素中没有配置 id 属性时，将别名中的第一个值赋值给 beanName</span><br><span class="line">    if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">        beanName = aliases.remove(0);</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(&quot;No XML &apos;id&apos; specified - using &apos;&quot; + beanName +</span><br><span class="line">                    &quot;&apos; as bean name and &quot; + aliases + &quot; as aliases&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //检查&lt;Bean&gt;元素所配置的 id 或者 name 的唯一性，containingBean 标识&lt;Bean&gt;</span><br><span class="line">    //元素中是否包含子&lt;Bean&gt;元素</span><br><span class="line">    if (containingBean == null) &#123;</span><br><span class="line">    //检查&lt;Bean&gt;元素所配置的 id、name 或者别名是否重复</span><br><span class="line">        checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">    &#125;</span><br><span class="line">    //详细对&lt;Bean&gt;元素中配置的 Bean 定义进行解析的地方</span><br><span class="line">    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName,</span><br><span class="line">            containingBean);</span><br><span class="line">    if (beanDefinition != null) &#123;</span><br><span class="line">        if (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (containingBean != null) &#123;</span><br><span class="line">                    //如果&lt;Bean&gt;元素中没有配置 id、别名或者 name，且没有包含子元素</span><br><span class="line">                    //&lt;Bean&gt;元素，为解析的 Bean 生成一个唯一 beanName 并注册</span><br><span class="line">                    beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                            beanDefinition, this.readerContext.getRegistry(), true);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    //如果&lt;Bean&gt;元素中没有配置 id、别名或者 name，且包含了子元素</span><br><span class="line">                    //&lt;Bean&gt;元素，为解析的 Bean 使用别名向 IOC 容器注册</span><br><span class="line">                    beanName = this.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">                    //为解析的 Bean 使用别名注册时，为了向后兼容</span><br><span class="line">                    //Spring1.2/2.0，给别名添加类名后缀</span><br><span class="line">                    String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">                    if (beanClassName != null &amp;&amp;</span><br><span class="line">                            beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt;</span><br><span class="line">                            beanClassName.length() &amp;&amp;</span><br><span class="line">                            !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                        aliases.add(beanClassName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(&quot;Neither XML &apos;id&apos; nor &apos;name&apos; specified - &quot; +</span><br><span class="line">                            &quot;using generated bean name [&quot; + beanName + &quot;]&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception ex) &#123;</span><br><span class="line">                error(ex.getMessage(), ele);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">        return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">    &#125;</span><br><span class="line">    //当解析出错时，返回 null</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line">//详细对&lt;Bean&gt;元素中配置的 Bean 定义其他属性进行解析，由于上面的方法中已经对</span><br><span class="line">//Bean 的 id、name 和别名等属性进行了处理，该方法中主要处理除这三个以外的其他属性数据</span><br><span class="line">public AbstractBeanDefinition parseBeanDefinitionElement(</span><br><span class="line">        Element ele, String beanName, BeanDefinition containingBean) &#123;</span><br><span class="line">    //记录解析的&lt;Bean&gt;</span><br><span class="line">    this.parseState.push(new BeanEntry(beanName));</span><br><span class="line">    //这里只读取&lt;Bean&gt;元素中配置的 class 名字，然后载入到 BeanDefinition 中去</span><br><span class="line">    //只是记录配置的 class 名字，不做实例化，对象的实例化在依赖注入时完成</span><br><span class="line">    String className = null;</span><br><span class="line">    if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        String parent = null;</span><br><span class="line">        //如果&lt;Bean&gt;元素中配置了 parent 属性，则获取 parent 属性的值</span><br><span class="line">        if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">            parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">        &#125;</span><br><span class="line">        //根据&lt;Bean&gt;元素配置的 class 名称和 parent 属性值创建 BeanDefinition</span><br><span class="line">        //为载入 Bean 定义信息做准备</span><br><span class="line">        AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line">        //对当前的&lt;Bean&gt;元素中配置的一些属性进行解析和设置，如配置的单态(singleton)属性等</span><br><span class="line">        parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">        //为&lt;Bean&gt;元素解析的 Bean 设置 description 信息</span><br><span class="line">        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line">        //对&lt;Bean&gt;元素的 meta(元信息)属性解析</span><br><span class="line">        parseMetaElements(ele, bd);</span><br><span class="line">        //对&lt;Bean&gt;元素的 lookup-method 属性解析</span><br><span class="line">        parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        //对&lt;Bean&gt;元素的 replaced-method 属性解析</span><br><span class="line">        parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        //解析&lt;Bean&gt;元素的构造方法设置</span><br><span class="line">        parseConstructorArgElements(ele, bd);</span><br><span class="line">        //解析&lt;Bean&gt;元素的&lt;property&gt;设置</span><br><span class="line">        parsePropertyElements(ele, bd);</span><br><span class="line">        //解析&lt;Bean&gt;元素的 qualifier 属性</span><br><span class="line">        parseQualifierElements(ele, bd);</span><br><span class="line">        //为当前解析的 Bean 设置所需的资源和依赖对象</span><br><span class="line">        bd.setResource(this.readerContext.getResource());</span><br><span class="line">        bd.setSource(extractSource(ele));</span><br><span class="line">        return bd;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ClassNotFoundException ex) &#123;</span><br><span class="line">        error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (NoClassDefFoundError err) &#123;</span><br><span class="line">        error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable ex) &#123;</span><br><span class="line">        error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        this.parseState.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    //解析&lt;Bean&gt;元素出错时，返回 null</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要使用过 Spring，对 Spring 配置文件比较熟悉的人，通过对上述源码的分析，就会明白我们在 Spring<br>配置文件中<code>&lt;Bean&gt;</code>元素的中配置的属性就是通过该方法解析和设置到 Bean 中去的。</p><p>注意：在解析<code>&lt;Bean&gt;</code>元素过程中没有创建和实例化 Bean 对象，只是创建了 Bean 对象的定义类BeanDefinition，将<code>&lt;Bean&gt;</code>元素中的配置信息设置到 BeanDefinition 中作为记录，当依赖注入时才使用这些记录信息创建和实例化具体的 Bean 对象。</p><p>上面方法中一些对一些配置如元信息(meta)、qualifier 等的解析，我们在 Spring 中配置时使用的也不多，我们在使用 Spring 的<code>&lt;Bean&gt;</code>元素时，配置最多的是<code>&lt;property&gt;</code>属性，因此我们下面继续分析源码，了解 Bean 的属性在解析时是如何设置的。</p><h3><a id="BeanDefinitionParserDelegate_property_231"></a><a class="header-anchor" href="#beandefinitionparserdelegate-解析-property-元素">¶</a>BeanDefinitionParserDelegate 解析<code>&lt;property&gt;</code>元素</h3><p>BeanDefinitionParserDelegate 在解析<code>&lt;Bean&gt;</code>调用 parsePropertyElements 方法解析<code>&lt;Bean&gt;</code>元素中的<br><code>&lt;property&gt;</code>属性子元素，解析源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">//解析&lt;Bean&gt;元素中的&lt;property&gt;子元素</span><br><span class="line">public void parsePropertyElements(Element beanEle, BeanDefinition bd) &#123;</span><br><span class="line">    //获取&lt;Bean&gt;元素中所有的子元素</span><br><span class="line">    NodeList nl = beanEle.getChildNodes();</span><br><span class="line">    for (int i = 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">        Node node = nl.item(i);</span><br><span class="line">        //如果子元素是&lt;property&gt;子元素，则调用解析&lt;property&gt;子元素方法解析</span><br><span class="line">        if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) &#123;</span><br><span class="line">            parsePropertyElement((Element) node, bd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//解析&lt;property&gt;元素</span><br><span class="line">public void parsePropertyElement(Element ele, BeanDefinition bd) &#123;</span><br><span class="line">    //获取&lt;property&gt;元素的名字</span><br><span class="line">    String propertyName = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">    if (!StringUtils.hasLength(propertyName)) &#123;</span><br><span class="line">        error(&quot;Tag &apos;property&apos; must have a &apos;name&apos; attribute&quot;, ele);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    this.parseState.push(new PropertyEntry(propertyName));</span><br><span class="line">    try &#123;</span><br><span class="line">        //如果一个 Bean 中已经有同名的 property 存在，则不进行解析，直接返回。</span><br><span class="line">        //即如果在同一个 Bean 中配置同名的 property，则只有第一个起作用</span><br><span class="line">        if (bd.getPropertyValues().contains(propertyName)) &#123;</span><br><span class="line">            error(&quot;Multiple &apos;property&apos; definitions for property &apos;&quot; + propertyName + &quot;&apos;&quot;, ele);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //解析获取 property 的值</span><br><span class="line">        Object val = parsePropertyValue(ele, bd, propertyName);</span><br><span class="line">        //根据 property 的名字和值创建 property 实例</span><br><span class="line">        PropertyValue pv = new PropertyValue(propertyName, val);</span><br><span class="line">        //解析&lt;property&gt;元素中的属性</span><br><span class="line">        parseMetaElements(ele, pv);</span><br><span class="line">        pv.setSource(extractSource(ele));</span><br><span class="line">        bd.getPropertyValues().addPropertyValue(pv);</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        this.parseState.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//解析获取 property 值</span><br><span class="line">public Object parsePropertyValue(Element ele, BeanDefinition bd, String propertyName) &#123;</span><br><span class="line">    String elementName = (propertyName != null) ?</span><br><span class="line">            &quot;&lt;property&gt; element for property &apos;&quot; + propertyName + &quot;&apos;&quot; :</span><br><span class="line">            &quot;&lt;constructor-arg&gt; element&quot;;</span><br><span class="line">    //获取&lt;property&gt;的所有子元素，只能是其中一种类型:ref,value,list 等</span><br><span class="line">    NodeList nl = ele.getChildNodes();</span><br><span class="line">    Element subElement = null;</span><br><span class="line">    for (int i = 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">        Node node = nl.item(i);</span><br><span class="line">        //子元素不是 description 和 meta 属性</span><br><span class="line">        if (node instanceof Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp;</span><br><span class="line">                !nodeNameEquals(node, META_ELEMENT)) &#123;</span><br><span class="line">            if (subElement != null) &#123;</span><br><span class="line">                error(elementName + &quot; must not contain more than one sub-element&quot;, ele);</span><br><span class="line">            &#125;</span><br><span class="line">            //当前&lt;property&gt;元素包含有子元素</span><br><span class="line">            else &#123;</span><br><span class="line">                subElement = (Element) node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //判断 property 的属性值是 ref 还是 value，不允许既是 ref 又是 value</span><br><span class="line">    boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);</span><br><span class="line">    boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);</span><br><span class="line">    if ((hasRefAttribute &amp;&amp; hasValueAttribute) ||</span><br><span class="line">            ((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement != null)) &#123;</span><br><span class="line">        error(elementName +</span><br><span class="line">                        &quot; is only allowed to contain either &apos;ref&apos; attribute OR &apos;value&apos; attribute OR</span><br><span class="line">                sub-element&quot;, ele);</span><br><span class="line">    &#125;</span><br><span class="line">    //如果属性是 ref，创建一个 ref 的数据对象 RuntimeBeanReference</span><br><span class="line">    //这个对象封装了 ref 信息</span><br><span class="line">    if (hasRefAttribute) &#123;</span><br><span class="line">        String refName = ele.getAttribute(REF_ATTRIBUTE);</span><br><span class="line">        if (!StringUtils.hasText(refName)) &#123;</span><br><span class="line">            error(elementName + &quot; contains empty &apos;ref&apos; attribute&quot;, ele);</span><br><span class="line">        &#125;</span><br><span class="line">    //一个指向运行时所依赖对象的引用</span><br><span class="line">        RuntimeBeanReference ref = new RuntimeBeanReference(refName);</span><br><span class="line">    //设置这个 ref 的数据对象是被当前的 property 对象所引用</span><br><span class="line">        ref.setSource(extractSource(ele));</span><br><span class="line">        return ref;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果属性是 value，创建一个 value 的数据对象 TypedStringValue</span><br><span class="line">    //这个对象封装了 value 信息</span><br><span class="line">    else if (hasValueAttribute) &#123;</span><br><span class="line">        //一个持有 String 类型值的对象</span><br><span class="line">        TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));</span><br><span class="line">        //设置这个 value 数据对象是被当前的 property 对象所引用</span><br><span class="line">        valueHolder.setSource(extractSource(ele));</span><br><span class="line">        return valueHolder;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果当前&lt;property&gt;元素还有子元素</span><br><span class="line">    else if (subElement != null) &#123;</span><br><span class="line">        //解析&lt;property&gt;的子元素</span><br><span class="line">        return parsePropertySubElement(subElement, bd);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        //propery 属性中既不是 ref，也不是 value 属性，解析出错返回 null</span><br><span class="line">        error(elementName + &quot; must specify a ref or value&quot;, ele);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对上述源码的分析，我们可以了解在 Spring 配置文件中，<code>&lt;Bean&gt;</code>元素中<code>&lt;property&gt;</code>元素的相关配<br>置是如何处理的：</p><ul><li>ref 被封装为指向依赖对象一个引用</li><li>value 配置都会封装成一个字符串类型的对象</li><li>ref 和 value 都通过“解析的数据类型属性值.setSource(extractSource(ele));”方法将属性值/引用与所引用的属性关联起来<br>在方法的最后对于<code>&lt;property&gt;</code>元素的子元素通过 parsePropertySubElement 方法解析，我们继续分析<br>该方法的源码，了解其解析过程。</li></ul><h3><a id="property_244"></a><a class="header-anchor" href="#解析-property-元素的子元素">¶</a>解析<code>&lt;property&gt;</code>元素的子元素</h3><p>在 BeanDefinitionParserDelegate 类中的 parsePropertySubElement 方法对<code>&lt;property&gt;</code>中的子元素解析，源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">//解析&lt;property&gt;元素中 ref,value 或者集合等子元素</span><br><span class="line">    public Object parsePropertySubElement(Element ele, BeanDefinition bd, String defaultValueType) &#123;</span><br><span class="line">        //如果&lt;property&gt;没有使用 Spring 默认的命名空间，则使用用户自定义的规则解析</span><br><span class="line">        //内嵌元素</span><br><span class="line">        if (!isDefaultNamespace(ele)) &#123;</span><br><span class="line">            return parseNestedCustomElement(ele, bd);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子元素是 bean，则使用解析&lt;Bean&gt;元素的方法解析</span><br><span class="line">        else if (nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">            BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);</span><br><span class="line">            if (nestedBd != null) &#123;</span><br><span class="line">                nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);</span><br><span class="line">            &#125;</span><br><span class="line">            return nestedBd;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子元素是 ref，ref 中只能有以下 3 个属性：bean、local、parent</span><br><span class="line">        else if (nodeNameEquals(ele, REF_ELEMENT)) &#123;</span><br><span class="line">            //获取&lt;property&gt;元素中的 bean 属性值，引用其他解析的 Bean 的名称</span><br><span class="line">            //可以不再同一个 Spring 配置文件中，具体请参考 Spring 对 ref 的配置规则</span><br><span class="line">            String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);</span><br><span class="line">            boolean toParent = false;</span><br><span class="line">            if (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line">                //获取&lt;property&gt;元素中的 local 属性值，引用同一个 Xml 文件中配置</span><br><span class="line">                //的 Bean 的 id，local 和 ref 不同，local 只能引用同一个配置文件中的 Bean</span><br><span class="line">                refName = ele.getAttribute(LOCAL_REF_ATTRIBUTE);</span><br><span class="line">                if (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line">                    //获取&lt;property&gt;元素中 parent 属性值，引用父级容器中的 Bean</span><br><span class="line">                    refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);</span><br><span class="line">                    toParent = true;</span><br><span class="line">                    if (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line">                        error(&quot;&apos;bean&apos;, &apos;local&apos; or &apos;parent&apos; is required for &lt;ref&gt; element&quot;, ele);</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //没有配置 ref 的目标属性值</span><br><span class="line">            if (!StringUtils.hasText(refName)) &#123;</span><br><span class="line">                error(&quot;&lt;ref&gt; element contains empty target attribute&quot;, ele);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            //创建 ref 类型数据，指向被引用的对象</span><br><span class="line">            RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent);</span><br><span class="line">            //设置引用类型值是被当前子元素所引用</span><br><span class="line">            ref.setSource(extractSource(ele));</span><br><span class="line">            return ref;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子元素是&lt;idref&gt;，使用解析 ref 元素的方法解析</span><br><span class="line">        else if (nodeNameEquals(ele, IDREF_ELEMENT)) &#123;</span><br><span class="line">            return parseIdRefElement(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子元素是&lt;value&gt;，使用解析 value 元素的方法解析</span><br><span class="line">        else if (nodeNameEquals(ele, VALUE_ELEMENT)) &#123;</span><br><span class="line">            return parseValueElement(ele, defaultValueType);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子元素是 null，为&lt;property&gt;设置一个封装 null 值的字符串数据</span><br><span class="line">        else if (nodeNameEquals(ele, NULL_ELEMENT)) &#123;</span><br><span class="line">            TypedStringValue nullHolder = new TypedStringValue(null);</span><br><span class="line">            nullHolder.setSource(extractSource(ele));</span><br><span class="line">            return nullHolder;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子元素是&lt;array&gt;，使用解析 array 集合子元素的方法解析</span><br><span class="line">        else if (nodeNameEquals(ele, ARRAY_ELEMENT)) &#123;</span><br><span class="line">            return parseArrayElement(ele, bd);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子元素是&lt;list&gt;，使用解析 list 集合子元素的方法解析</span><br><span class="line">        else if (nodeNameEquals(ele, LIST_ELEMENT)) &#123;</span><br><span class="line">            return parseListElement(ele, bd);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子元素是&lt;set&gt;，使用解析 set 集合子元素的方法解析</span><br><span class="line">        else if (nodeNameEquals(ele, SET_ELEMENT)) &#123;</span><br><span class="line">            return parseSetElement(ele, bd);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子元素是&lt;map&gt;，使用解析 map 集合子元素的方法解析</span><br><span class="line">        else if (nodeNameEquals(ele, MAP_ELEMENT)) &#123;</span><br><span class="line">            return parseMapElement(ele, bd);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子元素是&lt;props&gt;，使用解析 props 集合子元素的方法解析</span><br><span class="line">        else if (nodeNameEquals(ele, PROPS_ELEMENT)) &#123;</span><br><span class="line">            return parsePropsElement(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        //既不是 ref，又不是 value，也不是集合，则子元素配置错误，返回 null</span><br><span class="line">        else &#123;</span><br><span class="line">            error(&quot;Unknown property sub-element: [&quot; + ele.getNodeName() + &quot;]&quot;, ele);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过上述源码分析，我们明白了在 Spring 配置文件中，对<code>&lt;property&gt;</code>元素中配置的 Array、List、Set、<br>Map、Prop 等各种集合子元素的都通过上述方法解析，生成对应的数据对象，比如 ManagedList、<br>ManagedArray、ManagedSet 等，这些 Managed 类是 Spring 对象 BeanDefiniton 的数据封装，对集合数据类型的具体解析有各自的解析方法实现，解析方法的命名非常规范，一目了然，我们对<list>集合元素的解析方法进行源码分析，了解其实现过程。</list></p><h3><a id="list_251"></a><a class="header-anchor" href="#解析-list-子元素">¶</a>解析<code>&lt;list&gt;</code>子元素</h3><p>在 BeanDefinitionParserDelegate 类中的 parseListElement 方法就是具体实现解析<code>&lt;property&gt;</code>元素中的<code>&lt;list&gt;</code>集合子元素，源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//解析&lt;list&gt;集合子元素</span><br><span class="line">public List parseListElement(Element collectionEle, BeanDefinition bd) &#123;</span><br><span class="line">    //获取&lt;list&gt;元素中的 value-type 属性，即获取集合元素的数据类型</span><br><span class="line">    String defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);</span><br><span class="line">    //获取&lt;list&gt;集合元素中的所有子节点</span><br><span class="line">    NodeList nl = collectionEle.getChildNodes();</span><br><span class="line">    //Spring 中将 List 封装为 ManagedList</span><br><span class="line">    ManagedList&lt;Object&gt; target = new ManagedList&lt;Object&gt;(nl.getLength());</span><br><span class="line">    target.setSource(extractSource(collectionEle));</span><br><span class="line">    //设置集合目标数据类型</span><br><span class="line">    target.setElementTypeName(defaultElementType);</span><br><span class="line">    target.setMergeEnabled(parseMergeAttribute(collectionEle));</span><br><span class="line">    //具体的&lt;list&gt;元素解析</span><br><span class="line">    parseCollectionElements(nl, target, bd, defaultElementType);</span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br><span class="line">//具体解析&lt;list&gt;集合元素，&lt;array&gt;、&lt;list&gt;和&lt;set&gt;都使用该方法解析</span><br><span class="line">protected void parseCollectionElements(</span><br><span class="line">        NodeList elementNodes, Collection&lt;Object&gt; target, BeanDefinition bd, String</span><br><span class="line">        defaultElementType) &#123;</span><br><span class="line">    //遍历集合所有节点</span><br><span class="line">    for (int i = 0; i &lt; elementNodes.getLength(); i++) &#123;</span><br><span class="line">        Node node = elementNodes.item(i);</span><br><span class="line">        //节点不是 description 节点</span><br><span class="line">        if (node instanceof Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT)) &#123;</span><br><span class="line">            //将解析的元素加入集合中，递归调用下一个子元素</span><br><span class="line">            target.add(parsePropertySubElement((Element) node, bd, defaultElementType));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过对 Spring Bean 定义资源文件转换的 Document 对象中的元素层层解析，Spring IOC 现在已经将<br>XML 形式定义的 Bean 定义资源文件转换为 Spring IOC 所识别的数据结构——BeanDefinition，它是<br>Bean 定义资源文件中配置的 POJO 对象在 Spring IOC 容器中的映射，我们可以通过<br>AbstractBeanDefinition 为入口，看到了 IOC 容器进行索引、查询和操作。</p><p>通过 Spring IOC 容器对 Bean 定义资源的解析后，IOC 容器大致完成了管理 Bean 对象的准备工作，即<br>初始化过程，但是最为重要的依赖注入还没有发生，现在在 IOC 容器中 BeanDefinition 存储的只是一<br>些静态信息，接下来需要向容器注册 Bean 定义信息才能全部完成 IoC 容器的初始化过程</p><h3><a id="_BeanDefinition__IOC__264"></a><a class="header-anchor" href="#解析过后的-beandefinition-在-ioc-容器中的注册">¶</a>解析过后的 BeanDefinition 在 IOC 容器中的注册</h3><p>让我们继续跟踪程序的执行顺序，接下来会到我们第3步中分析DefaultBeanDefinitionDocumentReader<br>对 Bean 定义转换的 Document 对象解析的流程中，在其 parseDefaultElement 方法中完成对 Document<br>对象的解析后得到封装 BeanDefinition 的 BeanDefinitionHold 对象，然后调用<br>BeanDefinitionReaderUtils 的 registerBeanDefinition 方法向 IOC 容器注册解析的 Bean，BeanDefinitionReaderUtils 的注册的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//将解析的 BeanDefinitionHold 注册到容器中</span><br><span class="line">public static void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span><br><span class="line">        throws BeanDefinitionStoreException &#123;</span><br><span class="line">    //获取解析的 BeanDefinition 的名称</span><br><span class="line">    String beanName = definitionHolder.getBeanName();</span><br><span class="line">    //向 IOC 容器注册 BeanDefinition</span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line">    //如果解析的 BeanDefinition 有别名，向容器为其注册别名</span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    if (aliases != null) &#123;</span><br><span class="line">        for (String aliase : aliases) &#123;</span><br><span class="line">            registry.registerAlias(beanName, aliase);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 BeanDefinitionReaderUtils 向 IOC 容器注册解析的 BeanDefinition 时，真正完成注册功能的<br>是 DefaultListableBeanFactory。</p><h3><a id="DefaultListableBeanFactory__IOC__BeanDefinition_273"></a><a class="header-anchor" href="#defaultlistablebeanfactory-向-ioc-容器注册解析后的-beandefinition">¶</a>DefaultListableBeanFactory 向 IOC 容器注册解析后的 BeanDefinition</h3><p>DefaultListableBeanFactory 向 IOC 容器注册解析后的 BeanDefinition：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191107114157.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//存储注册信息的 BeanDefinition</span><br><span class="line">    private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;String, BeanDefinition&gt;();</span><br><span class="line">    //向 IoC 容器注册解析的 BeanDefiniton</span><br><span class="line">    public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException &#123;</span><br><span class="line">        Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);</span><br><span class="line">        Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);</span><br><span class="line">        //校验解析的 BeanDefiniton</span><br><span class="line">        if (beanDefinition instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">            &#125;</span><br><span class="line">            catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">                throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(),</span><br><span class="line">                        beanName,</span><br><span class="line">                        &quot;Validation of bean definition failed&quot;, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //注册的过程中需要线程同步，以保证数据的一致性</span><br><span class="line">        synchronized (this.beanDefinitionMap) &#123;</span><br><span class="line">            Object oldBeanDefinition = this.beanDefinitionMap.get(beanName);</span><br><span class="line">            //检查是否有同名的 BeanDefinition 已经在 IOC 容器中注册，如果已经注册，</span><br><span class="line">            //并且不允许覆盖已注册的 Bean，则抛出注册失败异常</span><br><span class="line">            if (oldBeanDefinition != null) &#123;</span><br><span class="line">                if (!this.allowBeanDefinitionOverriding) &#123;</span><br><span class="line">                    throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(),</span><br><span class="line">                            beanName,</span><br><span class="line">                            &quot;Cannot register bean definition [&quot; + beanDefinition + &quot;] for bean &apos;&quot; +</span><br><span class="line">                                    beanName +</span><br><span class="line">                                    &quot;&apos;: There is already [&quot; + oldBeanDefinition + &quot;] bound.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    //如果允许覆盖，则同名的 Bean，后注册的覆盖先注册的</span><br><span class="line">                    if (this.logger.isInfoEnabled()) &#123;</span><br><span class="line">                        this.logger.info(&quot;Overriding bean definition for bean &apos;&quot; + beanName +</span><br><span class="line">                                &quot;&apos;: replacing [&quot; + oldBeanDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //IOC 容器中没有已经注册同名的 Bean，按正常注册流程注册</span><br><span class="line">            else &#123;</span><br><span class="line">                this.beanDefinitionNames.add(beanName);</span><br><span class="line">                this.frozenBeanDefinitionNames = null;</span><br><span class="line">            &#125;</span><br><span class="line">            this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            //重置所有已经注册过的 BeanDefinition 的缓存</span><br><span class="line">            resetBeanDefinition(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>至此，Bean 定义资源文件中配置的 Bean 被解析过后，已经注册到 IOC 容器中，被容器管理起来，真正<br>完成了 IOC 容器初始化所做的全部工作。现在 IOC 容器中已经建立了整个 Bean 的配置信息，这些<br>BeanDefinition 信息已经可以使用，并且可以被检索，IOC 容器的作用就是对这些注册的 Bean 定义信<br>息进行处理和维护。这些的注册的 Bean 定义信息是 IoC 容器控制反转的基础，正是有了这些注册的数<br>据，容器才可以进行依赖注入。</p><h1><a id="_283"></a>总结</h1><p>现在通过上面的代码，总结一下 IOC 容器初始化的基本步骤：</p><ul><li>初始化的入口在容器实现中的 refresh()调用来完成</li><li>对 bean 定义载入 IOC 容器使用的方法是 loadBeanDefinition,</li></ul><p>其中的大致过程如下：<br>通过 ResourceLoader 来完成资源文件位置的定位，DefaultResourceLoader 是默<br>认的实现，同时上下文本身就给出了 ResourceLoader 的实现，可以从类路径，文件系统,URL 等方式来<br>定为资源位置。如果是 XmlBeanFactory 作为 IOC 容器，那么需要为它指定 bean 定义的资源，也就是说<br>bean 定义文件时通过抽象成 Resource 来被 IOC 容器处理的，容器通过 BeanDefinitionReader 来完成<br>定义信息的解析和 Bean 信息的注册,往往使用的是 XmlBeanDefinitionReader 来解析 bean 的 xml 定义<br>文件-实际的处理过程是委托给 BeanDefinitionParserDelegate来完成的，从而得到bean的定义信息，<br>这些信息在 Spring 中使用 BeanDefinition 对象来表示-这个名字可以让我们想到<br>loadBeanDefinition,RegisterBeanDefinition 这些相关方法-他们都是为处理BeanDefinitin 服务的，<br>容器解析得到 BeanDefinitionIoC 以后，需要把它在 IOC 容器中注册，这由 IOC 实<br>现 BeanDefinitionRegistry 接口来实现。注册过程就是在 IOC 容器内部维护的一个 HashMap 来保存得<br>到的 BeanDefinition 的过程。这个 HashMap 是 IOC 容器持有 bean 信息的场所，以后对 bean 的操作都<br>是围绕这个 HashMap 来实现的.</p><p>然后我们就可以通过 BeanFactory 和 ApplicationContext 来享受到 SpringIOC 的服务了,在使用 IOC<br>容器的时候，我们注意到除了少量粘合代码，绝大多数以正确 IOC 风格编写的应用程序代码完全不用关<br>心如何到达工厂，因为容器将把这些对象与容器管理的其他对象钩在一起。基本的策略是把工厂放到已<br>知的地方，最好是放在对预期使用的上下文有意义的地方，以及代码将实际需要访问工厂的地方。Spring<br>本身提供了对声明式载入 web 应用程序用法的应用程序上下文,并将其存储在 ServletContext 中的框架<br>实现。</p><h1><a id="_SpringIOC__309"></a>在使用 SpringIOC 容器的时候我们还需要区别两个概念</h1><h2><a id="BeanFactory__FactoryBean_310"></a><a class="header-anchor" href="#beanfactory-和-factorybean">¶</a>BeanFactory 和 FactoryBean</h2><ul><li>BeanFactory 功能性工厂，专门用来生产bean的，如果是生产车的就叫做CarFactory,是 IOC 容器的编程抽象，比如ApplicationContext，XmlBeanFactory 等，这些都是 IOC 容器的具体表现，需要使用什么样的容器由客户决定,但 Spring 为我们提供了丰富的选择。</li><li>FactoryBean 是由spring工厂生产出来的bean, 只是一个可以在 IOC 而容器中被管理的一个bean,是对各种处理过程和资源使用的抽象,FactoryBean 在需要时产生另一个对象，而不返回FactoryBean 本身,我们可以把它看成是一个抽象工厂，对它的调用返回的是工厂生产的产品。所有的FactoryBean 都实现特殊的 org.springframework.beans.factory.FactoryBean 接口，当使用容器中FactoryBean 的时候，该容器不会返回 FactoryBean 本身,而是返回其生成的对象。Spring 包括了大部分的通用资源和服务访问抽象的 FactoryBean 的实现，其中包括:对 JNDI 查询的处理，对代理对象的处理，对事务性代理的处理，对 RMI 代理的处理等，这些我们都可以看成是具体的工厂,看成是 Spring 为我们建立好的工厂。也就是说 Spring 通过使用抽象工厂模式为我们准备了一系列工厂来生产一些特定的对象,免除我们手工重复的工作，我们要使用时只需要在 IOC 容器里配置好就能很方便的使用了</li></ul><p><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/ioc%20%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt></p><h5><a id="springboot_316"></a><a class="header-anchor" href="#springboot">¶</a>springboot</h5><p>SpringApplication<br>AnnotationConfigServletWebServerApplicationContext<br>ServletWebServerApplicationContext<br>AbstractApplicationContext 在这个类中定义了扫描注解的执行器<br>ClassPathBeanDefinitionScanner<br>ClassPathScanningCandidateComponentProvider<br>AbstractTypeHierarchyTraversingFilter<br>AnnotationTypeFilter</p><p><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191114174000.png" alt></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jeff-eric.github.com/blog/blog/2019/10/22/fq%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jeff-Eric"><meta itemprop="description" content=""><meta itemprop="image" content="/blog/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="纯天然绿色学渣"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/blog/2019/10/22/fq%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" class="post-title-link" itemprop="url">fq软件安装</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-22 18:51:56" itemprop="dateCreated datePublished" datetime="2019-10-22T18:51:56+08:00">2019-10-22</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-10-29 19:17:56" itemprop="dateModified" datetime="2019-10-29T19:17:56+08:00">2019-10-29</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/VPS/" itemprop="url" rel="index"><span itemprop="name">VPS</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/blog/2019/10/22/fq%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/2019/10/22/fq%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" itemprop="commentCount"></span> </a></span><span id="/blog/2019/10/22/fq%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" class="leancloud_visitors" data-flag-title="fq软件安装"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body han-init-context" itemprop="articleBody"><h1><a id="Shadowsocks__1"></a>Shadowsocks 一键安装脚本（四合一）</h1><h3><a id="root_2"></a><a class="header-anchor" href="#使用root用户登录-运行以下命令：">¶</a>使用root用户登录，运行以下命令：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x shadowsocks-all.sh ./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br></pre></td></tr></table></figure><h3><a id="_5"></a><a class="header-anchor" href="#安装完成后-脚本提示如下">¶</a>安装完成后，脚本提示如下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Congratulations, your_shadowsocks_version install completed!</span><br><span class="line">Your Server IP        :your_server_ip</span><br><span class="line">Your Server Port      :your_server_port</span><br><span class="line">Your Password         :your_password</span><br><span class="line">Your Encryption Method:your_encryption_method</span><br><span class="line">Your QR Code: (For Shadowsocks Windows, OSX, Android and iOS clients)</span><br><span class="line"> ss://your_encryption_method:your_password@your_server_ip:your_server_port</span><br><span class="line">Your QR Code has been saved as a PNG file path:</span><br><span class="line"> your_path.png</span><br><span class="line">Welcome to visit:https://teddysun.com/486.html</span><br><span class="line">Enjoy it!</span><br></pre></td></tr></table></figure><h3><a id="_7"></a><a class="header-anchor" href="#卸载方法">¶</a>卸载方法</h3><p>若已安装多个版本，则卸载时也需多次运行（每次卸载一种）<br>使用root用户登录，运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./shadowsocks-all.sh uninstall</span><br></pre></td></tr></table></figure><h3><a id="_11"></a><a class="header-anchor" href="#启动脚本">¶</a>启动脚本</h3><p>启动脚本后面的参数含义，从左至右依次为：启动，停止，重启，查看状态。</p><h4><a id="ShadowsocksPython__13"></a><a class="header-anchor" href="#shadowsocks-python-版：">¶</a>Shadowsocks-Python 版：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/shadowsocks-python start | stop | restart | status</span><br></pre></td></tr></table></figure><h4><a id="ShadowsocksR__15"></a><a class="header-anchor" href="#shadowsocksr-版：">¶</a>ShadowsocksR 版：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/shadowsocks-r start | stop | restart | status</span><br></pre></td></tr></table></figure><h4><a id="ShadowsocksGo__17"></a><a class="header-anchor" href="#shadowsocks-go-版：">¶</a>Shadowsocks-Go 版：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/shadowsocks-go start | stop | restart | status</span><br></pre></td></tr></table></figure><h4><a id="Shadowsockslibev__19"></a><a class="header-anchor" href="#shadowsocks-libev-版：">¶</a>Shadowsocks-libev 版：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/shadowsocks-libev start | stop | restart | status</span><br></pre></td></tr></table></figure><h3><a id="_21"></a><a class="header-anchor" href="#各版本默认配置文件">¶</a>各版本默认配置文件</h3><h4><a id="ShadowsocksPython__22"></a><a class="header-anchor" href="#shadowsocks-python-版：-v2">¶</a>Shadowsocks-Python 版：</h4><p>/etc/shadowsocks-python/config.json</p><h4><a id="ShadowsocksR__24"></a><a class="header-anchor" href="#shadowsocksr-版：-v2">¶</a>ShadowsocksR 版：</h4><p>/etc/shadowsocks-r/config.json</p><h4><a id="ShadowsocksGo__26"></a><a class="header-anchor" href="#shadowsocks-go-版：-v2">¶</a>Shadowsocks-Go 版：</h4><p>/etc/shadowsocks-go/config.json</p><h4><a id="Shadowsockslibev__28"></a><a class="header-anchor" href="#shadowsocks-libev-版：-v2">¶</a>Shadowsocks-libev 版：</h4><p>/etc/shadowsocks-libev/config.json</p><h1><a id="Kcptun__31"></a>Kcptun 服务端安装脚本</h1><p>GitHub 地址：<a href="https://github.com/kuoruan/shell-scripts" target="_blank" rel="noopener">https://github.com/kuoruan/shell-scripts</a></p><h3><a id="_33"></a><a class="header-anchor" href="#安装">¶</a>安装</h3><p><font color="red">注意：在配置之前请确认一下你的加速地址，大部分不能加速都是由于加速地址配置错误。</font><br>首先找到你的 Shadowsocks 端口，比如我的 Shadowsocks 端口为 8388，然后在命令行输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nl | grep 8388</span><br></pre></td></tr></table></figure><p>如果提示以上命令不存在，请输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -nl | grep 8388</span><br></pre></td></tr></table></figure><p>将 8388 替换为你的 Shadowsocks 端口。<br>然后你会看到类似下面的输出（着重看显示为红色的部分）：<br>情况1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp6       0      0     :::8388                 :::*                    LISTEN     </span><br><span class="line">udp6       0      0     :::8388                 :::*</span><br></pre></td></tr></table></figure><p>情况2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp       0      0     127.0.0.1:8388                 :::*                    LISTEN     </span><br><span class="line">udp       0      0     127.0.0.1:8388                 :::*</span><br></pre></td></tr></table></figure><p>情况3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp       0      0     0.0.0.0:8388                 :::*                    LISTEN     </span><br><span class="line">udp       0      0     0.0.0.0:8388                 :::*</span><br></pre></td></tr></table></figure><p>情况4（假如 10.10.10.10 是当前服务器IP）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp       0      0     10.10.10.10:8388                 :::*                    LISTEN     </span><br><span class="line">udp       0      0     10.10.10.10:8388                 :::*</span><br></pre></td></tr></table></figure><p>若为情况1、情况2和情况3，那么你的加速地址可以为：加速 IP 127.0.0.1，加速端口 8388（你的 Shadowsocks 端口）<br>若为情况4，那么你的加速地址为：加速IP 10.10.10.10（你的服务器IP），加速端口8388（你的 Shadowsocks 端口）</p><p>使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/kuoruan/shell-scripts/raw/master/kcptun/kcptun.sh</span><br><span class="line">chmod +x ./kcptun.sh</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kcptun.sh</span><br></pre></td></tr></table></figure><h4><a id="_Kcptun__55"></a><a class="header-anchor" href="#设置-kcptun-的服务端端口">¶</a>设置 Kcptun 的服务端端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入 Kcptun Server 端口 [1-65535]:</span><br><span class="line">(默认: 29900):</span><br></pre></td></tr></table></figure><p>请输入一个未被占用的端口，Kcptun 运行时将使用此端口。</p><h4><a id="_IP_58"></a><a class="header-anchor" href="#设置加速的-ip">¶</a>设置加速的 IP</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入需要加速的地址:</span><br><span class="line">(默认: 127.0.0.1):</span><br></pre></td></tr></table></figure><p>填入上面获取到的加速 IP。如果你想使用 IPv6，请直接填写 IPv6 地址，不需要加 []，脚本会自动添加。</p><h4><a id="_61"></a><a class="header-anchor" href="#设置需要加速的端口">¶</a>设置需要加速的端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入需要加速的端口 [1-65535]:</span><br><span class="line">(默认: 12948):</span><br></pre></td></tr></table></figure><p>填入上面获取到的加速端口。<br>程序会检查当前是不是有程序占用着此端口，如果你的 Shadowsocks 没在运行，或者没有软件使用此端口，会弹出如下提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前没有软件使用此端口, 确定加速此端口?(y/n)</span><br></pre></td></tr></table></figure><h4><a id="_Kcptun__66"></a><a class="header-anchor" href="#设置-kcptun-密码">¶</a>设置 Kcptun 密码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入 Kcptun 密码:</span><br><span class="line">(如果不想使用密码请留空):</span><br></pre></td></tr></table></figure><p>这就是说，你可以为 Kcptun 单独设置一个密码，防止被他人恶意使用。这个密码和 SS 的密码没有半毛钱关系，请不要把它们混淆了。<br>再提一句，Kcptun 和 Shadowsocks 没有任何关系，请不要脑补它们之间存在任何联系，Kcptun 你可以理解为一款网络加速软件，只不过它是通过将 TCP 协议转换为 UDP 协议，然后再通过大量的发送数据包，浪费了带宽以换取网速的提升。它能加速所有以 TCP 协议传输数据的软件，不单单是 Shadowsocks。只是大家都用来……你懂的<br>回到上面的密码设置问题，如果你这里选择直接回车，也就是代表你不自定义密码。但是 Kcptun 有一个默认的密码，这个密码是： it’s a secrect 。</p><h4><a id="_71"></a><a class="header-anchor" href="#禁用压缩">¶</a>禁用压缩</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">是否禁用数据压缩?</span><br><span class="line">(默认: 不禁用) [y/n]:</span><br></pre></td></tr></table></figure><p>Kcptun 默认是启用压缩的。如果你这里设置为 y，也就是配置为 nocomp:true，那么就是禁用压缩。<br>许多朋友这里设置的是保持默认（启用压缩），而偏偏在软件之中设置为禁用压缩，当然就连不上咯。<br>其他配置项不用我说了，如果你了解它是干什么的，可以自定义配置。如果不知道，那么直接回车使用默认参数。<br>但是，使用默认参数，是有可能浪费大量流量的，如果你想减少流量使用，你需要会调节参数：</p><ul><li>先将 client rcvwnd 和 server sndwnd 调到一个较小值；</li><li>同时在两端逐步增大 client rcvwnd 和 server sndwnd ;</li><li>尝试下载，观察如果带宽利用率（服务器＋客户端两端都要观察）接近物理带宽则停止，否则跳转到第二步。</li></ul><p>任何事物都是有两面性的，选择了速度，就只有放弃流量。<br>各参数详细信息请查看：<a href="https://github.com/xtaci/kcptun" target="_blank" rel="noopener">https://github.com/xtaci/kcptun</a></p><p>安装成功，应该能看到如下输出信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">恭喜, Kcptun 服务端配置完毕！</span><br><span class="line"> </span><br><span class="line">正在获取当前安装的 Kcptun 版本...</span><br><span class="line"> </span><br><span class="line">服务器IP:  10.10.10.10</span><br><span class="line">端口:  29900</span><br><span class="line">加速地址: 127.0.0.1:8388</span><br><span class="line">密码: 123456</span><br><span class="line">加密方式 Crypt:  salsa20</span><br><span class="line"> </span><br><span class="line">当前安装的 Kcptun 版本为: v20160922</span><br><span class="line"> </span><br><span class="line">推荐的客户端配置为: </span><br><span class="line">&#123;</span><br><span class="line">  &quot;localaddr&quot;: &quot;:8388&quot;,</span><br><span class="line">  &quot;remoteaddr&quot;: &quot;10.10.10.10:29900&quot;,</span><br><span class="line">  &quot;key&quot;: &quot;123456&quot;,</span><br><span class="line">  &quot;crypt&quot;: &quot;salsa20&quot;,</span><br><span class="line">  &quot;mode&quot;: &quot;fast&quot;,</span><br><span class="line">  &quot;mtu&quot;: 1350,</span><br><span class="line">  &quot;sndwnd&quot;: 1024,</span><br><span class="line">  &quot;rcvwnd&quot;: 1024,</span><br><span class="line">  &quot;datashard&quot;: 10,</span><br><span class="line">  &quot;parityshard&quot;: 3,</span><br><span class="line">  &quot;dscp&quot;: 0,</span><br><span class="line">  &quot;conn&quot;: 1,</span><br><span class="line">  &quot;autoexpire&quot;: 60,</span><br><span class="line">  &quot;nocomp&quot;: false</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">手机端参数可以使用：</span><br><span class="line">  *******</span><br><span class="line"> </span><br><span class="line">其他参数请自行计算或设置, 详细信息可以查看: https://github.com/xtaci/kcptun</span><br><span class="line"> </span><br><span class="line">Kcptun 安装目录: /usr/share/kcptun</span><br><span class="line">Kcptun 日志文件目录: /var/log/kcptun/</span><br></pre></td></tr></table></figure><p>请将以上的提示信息复制保存下来，后面配置客户端会用到这些提示信息。<br>注意：服务端的 sndwnd 对应的是客户端的 recwnd，所以请不要问我为什么输出的客户端参数和你配置的服务端参数是反的。<br>安装之后，Kcptun 服务交由 Supervisor 管理。</p><h4><a id="Supervisor__90"></a><a class="header-anchor" href="#supervisor-相关命令">¶</a>Supervisor 相关命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service supervisord &#123;start|stop|restart|status&#125;</span><br></pre></td></tr></table></figure><h4><a id="Kcptun__92"></a><a class="header-anchor" href="#kcptun-相关命令">¶</a>Kcptun 相关命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl &#123;start|stop|restart|status&#125; kcptun</span><br></pre></td></tr></table></figure><p>Supervisor 启动的时候会同时启动 Kcptun，运行 kcptun 相关命令时先确保 Supervisor 已启动。</p><h3><a id="_96"></a><a class="header-anchor" href="#更新">¶</a>更新</h3><p>./kcptun.sh update</p><h1><a id="Kcptun__99"></a>Kcptun 客户端</h1><h4><a id="_Kcptun__Kcptun__Kcptun_httpsgithubcomdfdragonkcptun_gclientreleaseshttpsgithubcomdfdragonkcptun_gclientreleases_100"></a><a class="header-anchor" href="#先到下载一个启动-kcptun-的工具-请注意-这只是用来启动-kcptun-的工具-而不是-kcptun-客户端-https-github-com-dfdragon-kcptun-gclient-releases">¶</a>先到下载一个启动 Kcptun 的工具。请注意，这只是用来启动 Kcptun 的工具，而不是 Kcptun 客户端。<a href="https://github.com/dfdragon/kcptun_gclient/releases" target="_blank" rel="noopener">https://github.com/dfdragon/kcptun_gclient/releases</a></h4><h4><a id="_Kcptun_101"></a><a class="header-anchor" href="#然后下载服务端对应版本的-kcptun-保存下来的提示信息里有-：">¶</a>然后下载服务端对应版本的 Kcptun（保存下来的提示信息里有）：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前安装的 Kcptun 版本为: v20160922</span><br></pre></td></tr></table></figure><p><a href="https://github.com/xtaci/kcptun/releases" target="_blank" rel="noopener">https://github.com/xtaci/kcptun/releases</a><br>32位系统下载：kcptun-windows-386-20160922.tar.gz<br>64位系统下载：kcptun-windows-amd64-20160922.tar.gz<br>文件名带有 windows 的才是 Windows 版，dirwin 是给 Mac 用的，注意别下错了<br>注意看红字的版本号和服务端版本一致。然后将它们解压到一起：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kcptun_gclient.exe -- Kcptun 启动工具</span><br><span class="line">client_windows_amd64.exe -- Kcptun 客户端程序</span><br><span class="line">server_windows_amd64.exe -- Kcptun 服务端程序</span><br></pre></td></tr></table></figure><p>打开 Kcptun 启动工具，界面如下，请按序号操作。<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191029180629.png" alt></p><h5><a id="_112"></a><a class="header-anchor" href="#直接导入配置文件">¶</a>直接导入配置文件</h5><p>我们可以将推荐参数保存为文件，找到如下这部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;localaddr&quot;: &quot;:8388&quot;,</span><br><span class="line">  &quot;remoteaddr&quot;: &quot;10.10.10.10:29900&quot;,</span><br><span class="line">  &quot;key&quot;: &quot;123456&quot;,</span><br><span class="line">  &quot;crypt&quot;: &quot;salsa20&quot;,</span><br><span class="line">  &quot;mode&quot;: &quot;fast&quot;,</span><br><span class="line">  &quot;mtu&quot;: 1350,</span><br><span class="line">  &quot;sndwnd&quot;: 1024,</span><br><span class="line">  &quot;rcvwnd&quot;: 1024,</span><br><span class="line">  &quot;datashard&quot;: 10,</span><br><span class="line">  &quot;parityshard&quot;: 3,</span><br><span class="line">  &quot;dscp&quot;: 0,</span><br><span class="line">  &quot;conn&quot;: 1,</span><br><span class="line">  &quot;autoexpire&quot;: 60,</span><br><span class="line">  &quot;nocomp&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个记事本文件，文件名随意（比如 config.txt 或者 config.json），然后将上面大括号里的内容复制到文件里边（包括大括号），确保它是标准的 json 格式<br>然后勾选“使用配置文件”，选择你新建的文件即可，下面的参数区域直接留空，点击启动。</p><h5><a id="_117"></a><a class="header-anchor" href="#手动配置参数">¶</a>手动配置参数</h5><p>手动配置的时候只需要看保存下来的提示信息上面一部分（有标红部分，非常显眼）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">服务器IP:  10.10.10.10</span><br><span class="line">端口:  29900</span><br><span class="line">加速地址: 127.0.0.1:8388</span><br><span class="line">加密方式 Crypt:  salsa20</span><br></pre></td></tr></table></figure><p>为了规避错误，遵循较少配置原则，在配置服务端时没有修改过的选项都不需要配置。配置完毕，点击启动。<br>几项说明：</p><ul><li>本地监听端口，这个端口你可以随意设置，不是必须设置为 Shadowsocsk 的端口；</li><li>KCP服务器地址为你的服务器IP地址，不是 127.0.0.1，端口为服务端 Kcptun 的端口；</li><li>如果你想使用IPv6协议，在填写服务器IP地址的时候需要用 [] 将IPv6地址括起来，如：[2000:0:0:0:0:0:0:1]；</li><li>通信密钥是你配置的 Kcptun 密码，不是 Shadowsocks 的密码；在配置 Kcptun 的时候，不用管 Shadowsocks 的配置参数；</li><li>参数区配置的时候，只需要配置你修改过的部分就行了，其他部分都不用改，除非你了解每项参数的意义；</li><li>日志区非常重要，在排查问题的时候，这是必看部分；</li><li>右下角为 Kcptun 最低需求版本，更新服务端之后，也需要更新本地客户端，只需要替换客户端文件即可。</li></ul><h1><a id="SSRKcptun_130"></a>SSR配置Kcptun</h1><p>在 Shadowsocks 客户端中添加一个选项，服务器IP固定填写 127.0.0.1，服务器端口填写 Kcptun 启动工具中配置的“本地监听端口”（即这里的 8388），密码和加密配置的是 Shadowsocks 的密码和加密。<br>基本原则，配置 Kcptun 的时候不用管 Shadowsocks 的参数，配置 Shadowsocks 的时候不用管 Kcptun 的参数，别把它们的配置参数搞混了。</p><h1><a id="BBR_134"></a>安装魔改BBR</h1><p>由于是官方BBR基础上的激进版本，所以优点与原版BBR基本一致，加速效果更为明显。<br>不支持OpenVZ架构的系统，不支持部分系统版本安装。</p><h2><a id="_137"></a><a class="header-anchor" href="#安装-v2">¶</a>安装</h2><h3><a id="Debian_138"></a><a class="header-anchor" href="#debian版：">¶</a>Debian版：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/tcp-nanqinlang/general/releases/download/3.4.2.1/tcp_nanqinlang-fool-1.3.0.sh</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash tcp_nanqinlang-fool-1.3.0.sh</span><br></pre></td></tr></table></figure><h3><a id="CentOS_141"></a><a class="header-anchor" href="#centos版：">¶</a>CentOS版：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/tcp-nanqinlang/general/master/General/CentOS/bash/tcp_nanqinlang-1.3.2.sh</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash tcp_nanqinlang-1.3.2.sh</span><br></pre></td></tr></table></figure><p>出现下图提示时，输入数字1选择安装内核，然后回车：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191029182257.png" alt><br>接下来的安装过程中，部分系统可能会有如下提示，提示删除旧的内核，是否取消。<br>这时按方向右键，选择No,后回车，确认删除。<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191029182338.png" alt></p><p>出现如下提示后，输入reboot回车重启系统：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191029182421.png" alt></p><p>系统重启完成后，重新连接，输入以下命令重新运行脚本：</p><h3><a id="Debian_154"></a><a class="header-anchor" href="#debian">¶</a>Debian:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash tcp_nanqinlang-fool-1.3.0.sh</span><br></pre></td></tr></table></figure><h3><a id="Centos_156"></a><a class="header-anchor" href="#centos">¶</a>Centos:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash tcp_nanqinlang-1.3.2.sh</span><br></pre></td></tr></table></figure><p>出现如下图提示后，输入2, 选择安装并开启算法：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191029182558.png" alt></p><p>稍等片刻，安装成功后的提示如下图：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191029182626.png" alt></p><h1><a id="BBR_164"></a>魔改BBR卸载</h1><p>Putty连接VPS服务器，运行如下命令：</p><h2><a id="Debian_166"></a><a class="header-anchor" href="#debian-v2">¶</a>Debian</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash tcp_nanqinlang-fool-1.3.0.sh</span><br></pre></td></tr></table></figure><h2><a id="CentOS_168"></a><a class="header-anchor" href="#centos-v2">¶</a>CentOS</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash tcp_nanqinlang-1.3.2.sh</span><br></pre></td></tr></table></figure><p>出现下图提示后，选择4进行卸载：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191029182756.png" alt><br>卸载完成后重启。<br>注意：此卸载仅卸载算法，并不卸载内核。</p><h1><a id="adbyby_176"></a>安装adbyby</h1><h2><a id="_177"></a><a class="header-anchor" href="#安装-v3">¶</a>安装</h2><p>系统要求：CentOS 6+/Debian 6+/Ubuntu 14.04 +，推荐Debian 7 x64。<br>执行下面的代码下载并运行脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubiBackup/doubi/master/adbyby.sh &amp;&amp; chmod +x adbyby.sh &amp;&amp; bash adbyby.sh</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191029190331.png" alt><br>运行脚本后会出现脚本操作菜单，选择并输入1就会开始安装。</p><h2><a id="_183"></a><a class="header-anchor" href="#其他操作">¶</a>其他操作</h2><p>启动：service adbyby start<br>停止：service adbyby stop<br>重启：service adbyby restart<br>查看状态：service adbyby status<br>安装目录：/usr/local/adbyby<br>配置文件：/usr/local/adbyby/bin/adhook.ini</p><h2><a id="_190"></a><a class="header-anchor" href="#其他说明">¶</a>其他说明</h2><p>ADbyby脚本支持开机启动。<br>ADbyby的广告过滤效果取决于广告过滤规则的完善程度，默认的规则并不是很全，所以想要更好的过滤效果请自行添加 广告过滤规则URL！</p><h2><a id="URL_194"></a><a class="header-anchor" href="#添加广告过滤-屏蔽规则url">¶</a>添加广告过滤/屏蔽规则URL</h2><p>默认的配置文件，我已经加上了四个URL规则，ADbyby会自动定时更新的，如果你想要添加或者删除这些URL规则，那么可以运行脚本后选择6选项。<br>然后就会打开配置文件，在最后的[exrule]项目下面添加/删除广告过滤URL规则即可，一行一个。<br>脚本中我是用vim编辑器打开配置文件的，打开后按I键即可进入编辑模式，然后就可以修改了（注意不要使用键盘中的小键盘）。<br>修改后，按ESC键退出编辑模式，然后输入:wq保存并退出，如果不想保存，那就:q!不保存强行退出。<br>以下这些广告过滤规则URL，可以根据需求添加进去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">https://opt.cn2qq.com/opt-file/video.txt</span><br><span class="line">https://opt.cn2qq.com/opt-file/lazy.txt</span><br><span class="line">https://easylist-downloads.adblockplus.org/easylistchina.txt</span><br><span class="line">https://easylist.to/easylist/easylist.txt</span><br><span class="line">https://easylist-downloads.adblockplus.org/easyprivacy.txt</span><br><span class="line">https://easylist-downloads.adblockplus.org/malwaredomains_full.txt</span><br><span class="line">https://raw.githubusercontent.com/xinggsf/Adblock-Plus-Rule/master/ABP-FX.txt</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jeff-eric.github.com/blog/blog/2019/10/22/spring%20-%20IOC%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jeff-Eric"><meta itemprop="description" content=""><meta itemprop="image" content="/blog/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="纯天然绿色学渣"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/blog/2019/10/22/spring%20-%20IOC%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" class="post-title-link" itemprop="url">spring - IOC高级特性</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-22 18:51:56" itemprop="dateCreated datePublished" datetime="2019-10-22T18:51:56+08:00">2019-10-22</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-11-17 15:28:33" itemprop="dateModified" datetime="2019-11-17T15:28:33+08:00">2019-11-17</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/blog/2019/10/22/spring%20-%20IOC%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/2019/10/22/spring%20-%20IOC%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" itemprop="commentCount"></span> </a></span><span id="/blog/2019/10/22/spring%20-%20IOC%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" class="leancloud_visitors" data-flag-title="spring - IOC高级特性"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body han-init-context" itemprop="articleBody"><h1><a id="_1"></a>介绍</h1><p>Spring IOC 容器对 Bean 定<br>义资源的定位、读入和解析过程，同时也清楚了当用户通过 getBean 方法向 IOC 容器获取被管理的 Bean<br>时，IOC 容器对 Bean 进行的初始化和依赖注入过程，这些是 Spring IOC 容器的基本功能特性。<br>Spring IOC 容器还有一些高级特性，如使用 lazy-init 属性对 Bean 预初始化、FactoryBean 产生或者<br>修饰 Bean 对象的生成、IOC 容器初始化 Bean 过程中使用 BeanPostProcessor 后置处理器对 Bean 声明周<br>期事件管理和 IOC 容器的 autowiring 自动装配功能等。</p><h1><a id="Spring_IOC__lazyinit__9"></a>Spring IOC 容器的 lazy-init 属性实现预实例化：</h1><p>IOC 容器的初始化过程就是对 Bean 定义<br>资源的定位、载入和注册，此时容器对 Bean 的依赖注入并没有发生，依赖注入主要是在应用程序第一<br>次向容器索取 Bean 时，通过 getBean 方法的调用完成。</p><p>当 Bean 定义资源的<bean>元素中配置了 lazy-init 属性时，容器将会在初始化的时候对所配置的 Bean<br>进行预实例化，Bean 的依赖注入在容器初始化的时候就已经完成。这样，当应用程序第一次向容器索取<br>被管理的 Bean 时，就不用再初始化和对 Bean 进行依赖注入了，直接从容器中获取已经完成依赖注入的<br>现成 Bean，可以提高应用第一次向容器获取 Bean 的性能。</bean></p><p>下面我们通过代码分析容器预实例化的实现过程：</p><h2><a id="refresh_20"></a><a class="header-anchor" href="#refresh">¶</a>refresh()</h2><p>先从 IOC 容器的初始会过程开始，通过前面文章分析，我们知道 IOC 容器读入已经定位的 Bean 定义资<br>源是从 refresh 方法开始的，我们首先从 AbstractApplicationContext 类的 refresh 方法入手分析，<br>源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">// 容器初始化的过程，读入 Bean 定义资源，并解析注册</span><br><span class="line">	public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">		synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">			//调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识.</span><br><span class="line">			prepareRefresh();</span><br><span class="line"></span><br><span class="line">			//告诉子类启动 refreshBeanFactory()方法，Bean 定义资源文件的载入从子类的 refreshBeanFactory()方法启动</span><br><span class="line">			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">			//为 BeanFactory 配置容器特性，例如类加载器、事件处理器等</span><br><span class="line">			prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">				//以下三个方法其实都是加载一些所谓的监听器（ApplicationAware/SessionAware等等）</span><br><span class="line"></span><br><span class="line">				// Allows post-processing of the bean factory in context subclasses.</span><br><span class="line">				//为容器的某些子类指定特殊的 BeanPost 事件处理器</span><br><span class="line">				//比如监听spring是否启动，ApplicationAware中的setApplicationContext方法就可以进行一些容器初始化事件操作</span><br><span class="line">				postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">				// Invoke factory processors registered as beans in the context.</span><br><span class="line">				//调用所有注册的 BeanFactoryPostProcessor 的 Bean</span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				//为 BeanFactory 注册 BeanPost 事件处理器.</span><br><span class="line">				//BeanPostProcessor 是 Bean 后置处理器，用于监听容器触发的事件</span><br><span class="line">				// Register bean processors that intercept bean creation.</span><br><span class="line">				registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				//初始化信息源，和国际化相关.</span><br><span class="line">				// Initialize message source for this context.</span><br><span class="line">				initMessageSource();</span><br><span class="line"></span><br><span class="line">				//初始化容器事件传播器.</span><br><span class="line">				// Initialize event multicaster for this context.</span><br><span class="line">				initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">				//调用子类的某些特殊 Bean 初始化方法</span><br><span class="line">				// Initialize other special beans in specific context subclasses.</span><br><span class="line">				onRefresh();</span><br><span class="line"></span><br><span class="line">				//为事件传播器注册事件监听器.</span><br><span class="line">				// Check for listener beans and register them.</span><br><span class="line">				registerListeners();</span><br><span class="line"></span><br><span class="line">				//初始化所有剩余的单例 Bean.</span><br><span class="line">				// Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">				//初始化容器的生命周期事件处理器，并发布容器的生命周期事件</span><br><span class="line">				// Last step: publish corresponding event.</span><br><span class="line">				finishRefresh();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			catch (BeansException ex) &#123;</span><br><span class="line">				//销毁以创建的单态 Bean</span><br><span class="line">				// Destroy already created singletons to avoid dangling resources.</span><br><span class="line">				destroyBeans();</span><br><span class="line"></span><br><span class="line">				//取消 refresh 操作，重置容器的同步标识.</span><br><span class="line">				// Reset &apos;active&apos; flag.</span><br><span class="line">				cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">				// Propagate exception to caller.</span><br><span class="line">				throw ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>在 refresh 方法中 ConfigurableListableBeanFactorybeanFactory = obtainFreshBeanFactory();<br>启动了 Bean 定义资源的载入、注册过程，而 finishBeanFactoryInitialization 方法是对注册后的 Bean<br>定义中的预实例化(lazy-init=false，Spring 默认就是预实例化，即为 true)的 Bean 进行处理的地方。</p><h2><a id="finishBeanFactoryInitialization__Bean_30"></a><a class="header-anchor" href="#finishbeanfactoryinitialization-处理预实例化-bean">¶</a>finishBeanFactoryInitialization 处理预实例化 Bean</h2><p>当Bean定义资源被载入IOC容器之后，容器将Bean定义资源解析为容器内部的数据结构BeanDefinition<br>注册到容器中，AbstractApplicationContext 类中的 finishBeanFactoryInitialization 方法对配置了<br>预实例化属性的 Bean 进行预初始化过程，源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//对配置了 lazy-init 属性的 Bean 进行预实例化处理</span><br><span class="line">	protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">		// Initialize conversion service for this context.</span><br><span class="line">		//这是 Spring3 以后新加的代码，为容器指定一个转换服务(ConversionService)</span><br><span class="line">		//在对某些 Bean 属性进行转换时使用</span><br><span class="line">		if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">				beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">			beanFactory.setConversionService(</span><br><span class="line">					beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span><br><span class="line">		String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);</span><br><span class="line">		for (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">			getBean(weaverAwareName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Stop using the temporary ClassLoader for type matching.</span><br><span class="line">		//为了类型匹配，停止使用临时的类加载器</span><br><span class="line">		beanFactory.setTempClassLoader(null);</span><br><span class="line"></span><br><span class="line">		// Allow for caching all bean definition metadata, not expecting further changes.</span><br><span class="line">		//缓存容器中所有注册的 BeanDefinition 元数据，以防被修改</span><br><span class="line">		beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">		// Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">		//对配置了 lazy-init 属性的单态模式 Bean 进行预实例化处理</span><br><span class="line">		beanFactory.preInstantiateSingletons();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>ConfigurableListableBeanFactory 是一个接口，其 preInstantiateSingletons 方法由其子类<br>DefaultListableBeanFactory 提供。</p><h2><a id="DefaultListableBeanFactory__lazyinit__Bean__40"></a><a class="header-anchor" href="#defaultlistablebeanfactory-对配置-lazy-init-属性单态-bean-的预实例化">¶</a>DefaultListableBeanFactory 对配置 lazy-init 属性单态 Bean 的预实例化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//对配置 lazy-init 属性单态 Bean 的预实例化</span><br><span class="line">	public void preInstantiateSingletons() throws BeansException &#123;</span><br><span class="line">		if (this.logger.isInfoEnabled()) &#123;</span><br><span class="line">			this.logger.info(&quot;Pre-instantiating singletons in &quot; + this);</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;String&gt; beanNames;</span><br><span class="line">		//在对配置 lazy-init 属性单态 Bean 的预实例化过程中，必须多线程同步，以确保数据一致性</span><br><span class="line">		synchronized (this.beanDefinitionMap) &#123;</span><br><span class="line">			// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span><br><span class="line">			// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span><br><span class="line">			beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames);</span><br><span class="line">		&#125;</span><br><span class="line">		for (String beanName : beanNames) &#123;</span><br><span class="line">			//获取指定名称的 Bean 定义</span><br><span class="line">			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			//Bean 不是抽象的，是单态模式的，且 lazy-init 属性配置为 false</span><br><span class="line">			if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">				//如果指定名称的 bean 是创建容器的 Bean</span><br><span class="line">				if (isFactoryBean(beanName)) &#123;</span><br><span class="line">					//FACTORY_BEAN_PREFIX=”&amp;”，当 Bean 名称前面加”&amp;”符号</span><br><span class="line">					//时，获取的是产生容器对象本身，而不是容器产生的 Bean.</span><br><span class="line">					//调用 getBean 方法，触发容器对 Bean 实例化和依赖注入过程</span><br><span class="line">					final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">					//标识是否需要预实例化</span><br><span class="line">					boolean isEagerInit;</span><br><span class="line">					if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;</span><br><span class="line">						//一个匿名内部类</span><br><span class="line">						isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">							public Boolean run() &#123;</span><br><span class="line">								return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;, getAccessControlContext());</span><br><span class="line">					&#125;</span><br><span class="line">					else &#123;</span><br><span class="line">						isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;</span><br><span class="line">								((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">					&#125;</span><br><span class="line">					if (isEagerInit) &#123;</span><br><span class="line">						//调用 getBean 方法，触发容器对 Bean 实例化和依赖注入过程</span><br><span class="line">						getBean(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					//调用 getBean 方法，触发容器对 Bean 实例化和依赖注入过程</span><br><span class="line">					getBean(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>通过对 lazy-init 处理源码的分析，我们可以看出，如果设置了 lazy-init 属性，则容器在完成 Bean<br>定义的注册之后，会通过 getBean 方法，触发对指定 Bean 的初始化和依赖注入过程，这样当应用第一<br>次向容器索取所需的 Bean 时，容器不再需要对 Bean 进行初始化和依赖注入，直接从已经完成实例化和<br>依赖注入的 Bean 中取一个现成的 Bean，这样就提高了第一次获取 Bean 的性能。</p><h1><a id="FactoryBean__47"></a>FactoryBean 的实现</h1><p>在 Spring 中，有两个很容易混淆的类：BeanFactory 和 FactoryBean。<br>BeanFactory：Bean 工厂，是一个工厂(Factory)，我们 Spring IOC 容器的最顶层接口就是这个<br>BeanFactory，它的作用是管理 Bean，即实例化、定位、配置应用程序中的对象及建立这些对象间的依<br>赖。</p><p>FactoryBean：工厂 Bean，是一个 Bean，作用是产生其他 bean 实例。通常情况下，这种 bean 没有什么<br>特别的要求，仅需要提供一个工厂方法，该方法用来返回其他 bean 实例。通常情况下，bean 无须自己<br>实现工厂模式，Spring 容器担任工厂角色；但少数情况下，容器中的 bean 本身就是工厂，其作用是产<br>生其它 bean 实例。</p><p>当用户使用容器本身时，可以使用转义字符”&amp;”来得到 FactoryBean 本身，以区别通过 FactoryBean<br>产生的实例对象和 FactoryBean 对象本身。在 BeanFactory 中通过如下代码定义了该转义字符：<br>StringFACTORY_BEAN_PREFIX = “&amp;”;</p><p>如果 myJndiObject 是一个 FactoryBean，则使用&amp;myJndiObject 得到的是 myJndiObject 对象，而不是<br>myJndiObject 产生出来的对象。</p><h2><a id="FactoryBean__65"></a><a class="header-anchor" href="#factorybean-的源码如下">¶</a>FactoryBean 的源码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//工厂 Bean，用于产生其他对象</span><br><span class="line">public interface FactoryBean&lt;T&gt; &#123;</span><br><span class="line">    //获取容器管理的对象实例</span><br><span class="line">    T getObject() throws Exception;</span><br><span class="line">    //获取 Bean 工厂创建的对象的类型</span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line">    //Bean 工厂创建的对象是否是单态模式，如果是单态模式，则整个容器中只有一个实例</span><br><span class="line">    //对象，每次请求都返回同一个实例对象</span><br><span class="line">    boolean isSingleton();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><a id="AbstractBeanFactory__getBean__FactoryBean_68"></a><a class="header-anchor" href="#abstractbeanfactory-的-getbean-方法调用-factorybean">¶</a>AbstractBeanFactory 的 getBean 方法调用 FactoryBean</h2><p>在前面我们分析 Spring IOC 容器实例化 Bean 并进行依赖注入过程的源码时，提到在 getBean 方法触<br>发容器实例化 Bean 的时候会调用 AbstractBeanFactory 的 doGetBean 方法来进行实例化的过程，源码<br>如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line">//真正实现向 IOC 容器获取 Bean 的功能，也是触发依赖注入功能的地方</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">protected &lt;T&gt; T doGetBean(</span><br><span class="line">        final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)</span><br><span class="line">        throws BeansException &#123;</span><br><span class="line">    //根据指定的名称获取被管理 Bean 的名称，剥离指定名称中对容器的相关依赖</span><br><span class="line">    //如果指定的是别名，将别名转换为规范的 Bean 名称</span><br><span class="line">    final String beanName = transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line"></span><br><span class="line">    // Eagerly check singleton cache for manually registered singletons.</span><br><span class="line">    //先从缓存中取是否已经有被创建过的单态类型的 Bean</span><br><span class="line">    //对于单例模式的 Bean 整个 IOC 容器中只创建一次，不需要重复创建</span><br><span class="line">    Object sharedInstance = getSingleton(beanName);</span><br><span class="line">    //IOC 容器创建单例模式 Bean 实例对象</span><br><span class="line">    if (sharedInstance != null &amp;&amp; args == null) &#123;</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            //如果指定名称的 Bean 在容器中已有单例模式的 Bean 被创建</span><br><span class="line">            //直接返回已经创建的 Bean</span><br><span class="line">            if (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                logger.debug(&quot;Returning eagerly cached instance of singleton bean &apos;&quot; + beanName +</span><br><span class="line">                        &quot;&apos; that is not fully initialized yet - a consequence of a circular reference&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                logger.debug(&quot;Returning cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //获取给定 Bean 的实例对象，主要是完成 FactoryBean 的相关处理</span><br><span class="line">        //注意：BeanFactory 是管理容器中 Bean 的工厂，而 FactoryBean 是创建创建对象的工厂 Bean，两者之间有区别</span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else &#123;</span><br><span class="line">        // Fail if we&apos;re already creating this bean instance:</span><br><span class="line">        // We&apos;re assumably within a circular reference.</span><br><span class="line">        //缓存没有正在创建的单例模式 Bean</span><br><span class="line">        //缓存中已经有已经创建的原型模式 Bean</span><br><span class="line">        //但是由于循环引用的问题导致实例化对象失败</span><br><span class="line">        if (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Check if bean definition exists in this factory.</span><br><span class="line">        //对 IOC 容器中是否存在指定名称的 BeanDefinition 进行检查，首先检查是否</span><br><span class="line">        //能在当前的 BeanFactory 中获取的所需要的 Bean，如果不能则委托当前容器</span><br><span class="line">        //的父级容器去查找，如果还是找不到则沿着容器的继承体系向父级容器查找</span><br><span class="line">        // 为什么要委托父容器去找呢？</span><br><span class="line">        // ioc容器是可以被关联的：FileSystemXmlApplicationContext(String[] configLocations, ApplicationContext parent)</span><br><span class="line">        BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">        //当前容器的父级容器存在，且当前容器中不存在指定名称的 Bean</span><br><span class="line">        if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            // Not found -&gt; check parent.</span><br><span class="line">            //解析指定 Bean 名称的原始名称</span><br><span class="line">            // 因为有可能是通过别名去获取bean</span><br><span class="line">            String nameToLookup = originalBeanName(name);</span><br><span class="line">            if (args != null) &#123;</span><br><span class="line">                // Delegation to parent with explicit args.</span><br><span class="line">                //委派父级容器根据指定名称和显式的参数查找</span><br><span class="line">                // 为什么不传类型再去校验一次？</span><br><span class="line">                // 因为这一步是强转成T ， 如果类型不一样, 在后续的调用中会报错ClassCastException</span><br><span class="line">                return (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                // No args -&gt; delegate to standard getBean method.</span><br><span class="line">                //委派父级容器根据指定名称和类型查找</span><br><span class="line">                return parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //创建的 Bean 是否需要进行类型验证，一般不需要</span><br><span class="line">        if (!typeCheckOnly) &#123;</span><br><span class="line">            //向容器标记指定的 Bean 已经被创建</span><br><span class="line">            markBeanAsCreated(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //根据指定 Bean 名称获取其父级的 Bean 定义</span><br><span class="line">            //主要解决 Bean 继承时子类合并父类公共属性问题</span><br><span class="line">            final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            // Guarantee initialization of beans that the current bean depends on.</span><br><span class="line">            //获取当前 Bean 所有依赖 Bean 的名称</span><br><span class="line">            String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            //如果当前 Bean 有依赖 Bean</span><br><span class="line">            if (dependsOn != null) &#123;</span><br><span class="line">                for (String dependsOnBean : dependsOn) &#123;</span><br><span class="line">                    //递归调用 getBean 方法，获取当前 Bean 的依赖 Bean</span><br><span class="line">                    getBean(dependsOnBean);</span><br><span class="line">                    //把被依赖 Bean 注册给当前依赖的 Bean</span><br><span class="line">                    registerDependentBean(dependsOnBean, beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Create bean instance.</span><br><span class="line">            //创建单例模式 Bean 的实例对象</span><br><span class="line">            if (mbd.isSingleton()) &#123;</span><br><span class="line">                //这里使用了一个匿名内部类，创建 Bean 实例对象，并且注册给所依赖的对象</span><br><span class="line">                sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                    public Object getObject() throws BeansException &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            //创建一个指定 Bean 实例对象，如果有父级继承，则合并子类和父类的定义</span><br><span class="line">                            // AbstractAutowireCapableBeanFactory 中实现了该方法</span><br><span class="line">                            return createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        catch (BeansException ex) &#123;</span><br><span class="line">                            // Explicitly remove instance from singleton cache: It might have been put there</span><br><span class="line">                            // eagerly by the creation process, to allow for circular reference resolution.</span><br><span class="line">                            // Also remove any beans that received a temporary reference to the bean.</span><br><span class="line">                            //显式地从容器单例模式 Bean 缓存中清除实例对象</span><br><span class="line">                            // 其实就是从各种map中吧这个对象给remove掉</span><br><span class="line">                            destroySingleton(beanName);</span><br><span class="line">                            throw ex;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                //获取给定 Bean 的实例对象</span><br><span class="line">                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            //IOC 容器创建原型模式 Bean 实例对象</span><br><span class="line">            else if (mbd.isPrototype()) &#123;</span><br><span class="line">                // It&apos;s a prototype -&gt; create a new instance.</span><br><span class="line">                //原型模式(Prototype)是每次都会创建一个新的对象</span><br><span class="line">                Object prototypeInstance = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //回调 beforePrototypeCreation 方法，默认的功能是注册当前创建的原型对象</span><br><span class="line">                    beforePrototypeCreation(beanName);</span><br><span class="line">                    //创建指定 Bean 对象实例</span><br><span class="line">                    prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">                &#125;</span><br><span class="line">                finally &#123;</span><br><span class="line">                    //回调 afterPrototypeCreation 方法，默认的功能告诉 IoC 容器指定 Bean 的原型对象不再创建了</span><br><span class="line">                    //就是该bean已经从ing状态变成了ed状态</span><br><span class="line">                    afterPrototypeCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                //获取给定 Bean 的实例对象</span><br><span class="line">                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            //要创建的 Bean 既不是单例模式，也不是原型模式，则根据 Bean 定义资源中</span><br><span class="line">            //配置的生命周期范围，选择实例化 Bean 的合适方法，这种在 Web 应用程序中</span><br><span class="line">            //比较常用，如：request、session、application 等生命周期</span><br><span class="line">            else &#123;</span><br><span class="line">                String scopeName = mbd.getScope();</span><br><span class="line">                //其实scopt也是用map去管理的, 这样的很多地方就能理解通了</span><br><span class="line">                final Scope scope = this.scopes.get(scopeName);</span><br><span class="line">                //Bean 定义资源中没有配置生命周期范围，则 Bean 定义不合法</span><br><span class="line">                if (scope == null) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;No Scope registered for scope &apos;&quot; + scopeName + &quot;&apos;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //这里又使用了一个匿名内部类，获取一个指定生命周期范围的实例</span><br><span class="line">                    Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                        public Object getObject() throws BeansException &#123;</span><br><span class="line">                            beforePrototypeCreation(beanName);</span><br><span class="line">                            try &#123;</span><br><span class="line">                                // AbstractAutowireCapableBeanFactory 中实现了该方法</span><br><span class="line">                                return createBean(beanName, mbd, args);</span><br><span class="line">                            &#125;</span><br><span class="line">                            finally &#123;</span><br><span class="line">                                afterPrototypeCreation(beanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    //获取给定 Bean 的实例对象</span><br><span class="line">                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (IllegalStateException ex) &#123;</span><br><span class="line">                    throw new BeanCreationException(beanName,</span><br><span class="line">                            &quot;Scope &apos;&quot; + scopeName + &quot;&apos; is not active for the current thread; &quot; +</span><br><span class="line">                            &quot;consider defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,</span><br><span class="line">                            ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (BeansException ex) &#123;</span><br><span class="line">            cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">            throw ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Check if required type matches the type of the actual bean instance.</span><br><span class="line">    //对创建的 Bean 实例对象进行类型检查</span><br><span class="line">    if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (TypeMismatchException ex) &#123;</span><br><span class="line">            if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(&quot;Failed to convert bean &apos;&quot; + name + &quot;&apos; to required type [&quot; +</span><br><span class="line">                        ClassUtils.getQualifiedName(requiredType) + &quot;]&quot;, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">//获取给定 Bean 的实例对象，主要是完成 FactoryBean 的相关处理</span><br><span class="line">protected Object getObjectForBeanInstance(</span><br><span class="line">        Object beanInstance, String name, String beanName, RootBeanDefinition mbd) &#123;</span><br><span class="line"></span><br><span class="line">    //容器已经得到了 Bean 实例对象，这个实例对象可能是一个普通的 Bean，</span><br><span class="line">    //也可能是一个工厂 Bean，如果是一个工厂 Bean，则使用它创建一个 Bean 实例对象，</span><br><span class="line">    //如果调用本身就想获得一个容器的引用，则指定返回这个工厂 Bean 实例对象</span><br><span class="line">    //如果指定的名称是容器的解引用(dereference，即是对象本身而非内存地址)，</span><br><span class="line">    //且 Bean 实例也不是创建 Bean 实例对象的工厂 Bean</span><br><span class="line">    // Don&apos;t let calling code try to dereference the factory if the bean isn&apos;t a factory.</span><br><span class="line">    // name 是否是工厂bean标记</span><br><span class="line">    // beanInstance 是否继承factoryBean</span><br><span class="line">    if (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance instanceof FactoryBean)) &#123;</span><br><span class="line">        throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Now we have the bean instance, which may be a normal bean or a FactoryBean.</span><br><span class="line">    // If it&apos;s a FactoryBean, we use it to create a bean instance, unless the</span><br><span class="line">    // caller actually wants a reference to the factory.</span><br><span class="line">    // 1、true || false 普通类 纯的普通类</span><br><span class="line">    // 2、false || true  工厂类 纯的工厂</span><br><span class="line">    // 3、false || false 普通类 没有定义为工厂的普通工厂类</span><br><span class="line">    //如果 Bean 实例不是工厂 Bean，或者指定名称是容器的解引用，</span><br><span class="line">    //调用者向获取对容器的引用，则直接返回当前的 Bean 实例</span><br><span class="line">    if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">        return beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    //处理指定名称不是容器的解引用，或者根据名称获取的 Bean 实例对象是一个工厂 Bean</span><br><span class="line">    //使用工厂 Bean 创建一个 Bean 的实例对象</span><br><span class="line">    Object object = null;</span><br><span class="line">    if (mbd == null) &#123;</span><br><span class="line">        // 真正的ioc容器</span><br><span class="line">        //从 Bean 工厂缓存中获取给定名称的 Bean 实例对象</span><br><span class="line">        object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    //让 Bean 工厂生产给定名称的 Bean 对象实例</span><br><span class="line">    if (object == null) &#123;</span><br><span class="line">        // Return bean instance from factory.</span><br><span class="line">        FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">        // Caches object obtained from FactoryBean if it is a singleton.</span><br><span class="line">        //如果从 Bean 工厂生产的 Bean 是单态模式的，则缓存</span><br><span class="line">        if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            //从容器中获取指定名称的 Bean 定义，如果继承基类，则合并基类相关属性</span><br><span class="line">            mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        // 是否是合成的，意思就是是否当做工具类来使用</span><br><span class="line">        // 这里的synthetic实际上是为了给用户自定义一些BeanDefinition注册到容器中以当作工具类来使用。</span><br><span class="line">        // 什么是synthetic</span><br><span class="line">        // 就是内部类，java在编译的时候内部类也会编译成单独的一个文件，那实际上，原始类及时两个类的合成类</span><br><span class="line">        // 工具类就没有必要做一些封装、代理等工作，实际上是拿来就用，没有其他处理</span><br><span class="line">        // 对于synthetic类型的BeanDefinition，getObjectFromFactoryBean中是不会对FactoryBean生成的bean用post-processor进行后置处理的。</span><br><span class="line">        // 后置处理的实现是在AbstractAutowireCapableBeanFactory.postProcessObjectFromFactoryBean中，</span><br><span class="line">        // 它会调用容器中的BeanPostProcessor.postProcessAfterInitialization,这里提供了一个扩展点对FactoryBean生成的bean进行封装，代理等</span><br><span class="line">        //如果从容器得到 Bean 定义信息，并且 Bean 定义信息不是虚构的，</span><br><span class="line">        //则让工厂 Bean 生产 Bean 实例对象</span><br><span class="line">        boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic());</span><br><span class="line">        // bean实例化的缓存</span><br><span class="line">        //调用 FactoryBeanRegistrySupport 类的 getObjectFromFactoryBean 方法，</span><br><span class="line">        //实现工厂 Bean 生产 Bean 对象实例的过程</span><br><span class="line">        object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">    &#125;</span><br><span class="line">    return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面获取给定 Bean 的实例对象的 getObjectForBeanInstance 方法中，会调用<br>FactoryBeanRegistrySupport 类的 getObjectFromFactoryBean 方法，该方法实现了 Bean 工厂生产 Bean<br>实例对象。</p><p>Dereference(解引用)：一个在 C/C<ins>中应用比较多的术语，在 C</ins>中，<code>*</code>是解引用符号，而<code>&amp;</code>是<br>引用符号，解引用是指变量指向的是所引用对象的本身数据，而不是引用对象的内存地址。</p><h2><a id="AbstractBeanFactory__Bean__81"></a><a class="header-anchor" href="#abstractbeanfactory-生产-bean-实例对象">¶</a>AbstractBeanFactory 生产 Bean 实例对象</h2><p>AbstractBeanFactory 类中生产 Bean 实例对象的主要源码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//Bean 工厂生产 Bean 实例对象</span><br><span class="line">protected Object getObjectFromFactoryBean(FactoryBean&lt;?&gt; factory, String beanName, boolean shouldPostProcess) &#123;</span><br><span class="line">    //Bean 工厂是单态模式，并且 Bean 工厂缓存中存在指定名称的 Bean 实例对象</span><br><span class="line">    if (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line">        //多线程同步，以防止数据不一致</span><br><span class="line">        synchronized (getSingletonMutex()) &#123;</span><br><span class="line">            //直接从 Bean 工厂缓存中获取指定名称的 Bean 实例对象</span><br><span class="line">            Object object = this.factoryBeanObjectCache.get(beanName);</span><br><span class="line">            if (object == null) &#123;</span><br><span class="line">                //调用 Bean 工厂的 getObject 方法生产指定 Bean 的实例对象</span><br><span class="line">                object = doGetObjectFromFactoryBean(factory, beanName, shouldPostProcess);</span><br><span class="line">                //将生产的实例对象添加到 Bean 工厂缓存中</span><br><span class="line">                this.factoryBeanObjectCache.put(beanName, (object != null ? object : NULL_OBJECT));</span><br><span class="line">            &#125;</span><br><span class="line">            return (object != NULL_OBJECT ? object : null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //调用 Bean 工厂的 getObject 方法生产指定 Bean 的实例对象</span><br><span class="line">    else &#123;</span><br><span class="line">        return doGetObjectFromFactoryBean(factory, beanName, shouldPostProcess);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//调用 Bean 工厂的 getObject 方法生产指定 Bean 的实例对象</span><br><span class="line">private Object doGetObjectFromFactoryBean(</span><br><span class="line">        final FactoryBean&lt;?&gt; factory, final String beanName, final boolean shouldPostProcess)</span><br><span class="line">        throws BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    Object object;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (System.getSecurityManager() != null) &#123;</span><br><span class="line">            AccessControlContext acc = getAccessControlContext();</span><br><span class="line">            try &#123;</span><br><span class="line">                //实现 PrivilegedExceptionAction 接口的匿名内置类</span><br><span class="line">                //根据 JVM 检查权限，然后决定 BeanFactory 创建实例对象</span><br><span class="line">                object = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line">                    public Object run() throws Exception &#123;</span><br><span class="line">                            //调用 BeanFactory 接口实现类的创建对象方法</span><br><span class="line">                            return factory.getObject();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, acc);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (PrivilegedActionException pae) &#123;</span><br><span class="line">                throw pae.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            //调用 BeanFactory 接口实现类的创建对象方法</span><br><span class="line">            object = factory.getObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (FactoryBeanNotInitializedException ex) &#123;</span><br><span class="line">        throw new BeanCurrentlyInCreationException(beanName, ex.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable ex) &#123;</span><br><span class="line">        throw new BeanCreationException(beanName, &quot;FactoryBean threw exception on object creation&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Do not accept a null value for a FactoryBean that&apos;s not fully</span><br><span class="line">    // initialized yet: Many FactoryBeans just return null then.</span><br><span class="line">    //创建出来的实例对象为 null，或者因为单态对象正在创建而返回 null</span><br><span class="line">    if (object == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        throw new BeanCurrentlyInCreationException(</span><br><span class="line">                beanName, &quot;FactoryBean which is currently in creation returned null from getObject&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //为创建出来的 Bean 实例对象添加 BeanPostProcessor 后置处理器</span><br><span class="line">    if (object != null &amp;&amp; shouldPostProcess) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable ex) &#123;</span><br><span class="line">            throw new BeanCreationException(beanName, &quot;Post-processing of the FactoryBean&apos;s object failed&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的源码分析中，我们可以看出，BeanFactory 接口调用其实现类的 getObject 方法来实现创建 Bean<br>实例对象的功能</p><h2><a id="_Bean__getObject__Bean__88"></a><a class="header-anchor" href="#工厂-bean-的实现类-getobject-方法创建-bean-实例对象">¶</a>工厂 Bean 的实现类 getObject 方法创建 Bean 实例对象</h2><p>FactoryBean的实现类有非常多，比如：Proxy、RMI、JNDI、ServletContextFactoryBean等等，FactoryBean<br>接口为 Spring 容器提供了一个很好的封装机制，具体的 getObject 有不同的实现类根据不同的实现策<br>略来具体提供，我们分析一个最简单的 AnnotationTestFactoryBean 的实现源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class AnnotationTestBeanFactory implements FactoryBean&lt;FactoryCreatedAnnotationTestBean&gt; &#123;</span><br><span class="line"></span><br><span class="line">	private final FactoryCreatedAnnotationTestBean instance = new FactoryCreatedAnnotationTestBean();</span><br><span class="line"></span><br><span class="line">	public AnnotationTestBeanFactory() &#123;</span><br><span class="line">		this.instance.setName(&quot;FACTORY&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	//AnnotationTestBeanFactory 产生 Bean 实例对象的实现</span><br><span class="line">	public FactoryCreatedAnnotationTestBean getObject() throws Exception &#123;</span><br><span class="line">		return this.instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Class&lt;? extends IJmxTestBean&gt; getObjectType() &#123;</span><br><span class="line">		return FactoryCreatedAnnotationTestBean.class;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public boolean isSingleton() &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的 Proxy，RMI，JNDI 等等，都是根据相应的策略提供 getObject 的实现。这里不做一一分析，这<br>已经不是 Spring 的核心功能，有需要的时候再去深入研究。</p><h1><a id="BeanPostProcessor__96"></a>BeanPostProcessor 后置处理器的实现</h1><p>BeanPostProcessor 后置处理器是 Spring IOC 容器经常使用到的一个特性，这个 Bean 后置处理器是一<br>个监听器，可以监听容器触发的 Bean 声明周期事件。后置处理器向容器注册以后，容器中管理的 Bean<br>就具备了接收 IOC 容器事件回调的能力。</p><p>BeanPostProcessor 的使用非常简单，只需要提供一个实现接口 BeanPostProcessor 的实现类，然后在<br>Bean 的配置文件中设置即可。</p><h2><a id="BeanPostProcessor__104"></a><a class="header-anchor" href="#beanpostprocessor-的源码如下">¶</a>BeanPostProcessor 的源码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.beans.factory.config;</span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">public interface BeanPostProcessor &#123;</span><br><span class="line">    //为在 Bean 的初始化前提供回调入口</span><br><span class="line">    Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;</span><br><span class="line">    //为在 Bean 的初始化之后提供回调入口</span><br><span class="line">    Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个回调的入口都是和容器管理的 Bean 的生命周期事件紧密相关，可以为用户提供在 Spring IOC<br>容器初始化 Bean 过程中自定义的处理操作。</p><h2><a id="AbstractAutowireCapableBeanFactory__Bean__109"></a><a class="header-anchor" href="#abstractautowirecapablebeanfactory-类对容器生成的-bean-添加后置处理器">¶</a>AbstractAutowireCapableBeanFactory 类对容器生成的 Bean 添加后置处理器</h2><p>BeanPostProcessor后置处理器的调用发生在Spring IOC容器完成对Bean实例对象的创建和属性的依<br>赖注入完成之后，在对 Spring 依赖注入的源码分析过程中我们知道，当应用程序第一次调用 getBean<br>方法(lazy-init 预实例化除外)向 Spring IOC 容器索取指定 Bean 时触发 Spring IOC 容器创建 Bean<br>实例对象并进行依赖注入的过程，其中真正实现创建 Bean 对象并进行依赖注入的方法是<br>AbstractAutowireCapableBeanFactory 类的 doCreateBean 方法，主要源码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//真正创建 Bean 的方法</span><br><span class="line">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) &#123;</span><br><span class="line">	//创建 Bean 实例对象</span><br><span class="line">	……</span><br><span class="line">	try &#123;</span><br><span class="line">		//对 Bean 属性进行依赖注入</span><br><span class="line">		populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">		if (exposedObject != null) &#123;</span><br><span class="line">			//在对 Bean 实例对象生成和依赖注入完成以后，开始对 Bean 实例对象</span><br><span class="line">			//进行初始化 ，为 Bean 实例对象应用 BeanPostProcessor 后置处理器</span><br><span class="line">			exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException)</span><br><span class="line">				ex).getBeanName())) &#123;</span><br><span class="line">			throw (BeanCreationException) ex;</span><br><span class="line">	&#125;</span><br><span class="line">	……</span><br><span class="line">	//为应用返回所需要的实例对象</span><br><span class="line">	return exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中我们知道，为 Bean 实例对象添加 BeanPostProcessor 后置处理器的入口的是<br>initializeBean 方法。</p><h2><a id="initializeBean__Bean__BeanPostProcessor__119"></a><a class="header-anchor" href="#initializebean-方法为容器产生的-bean-实例对象添加-beanpostprocessor-后置处理器">¶</a>initializeBean 方法为容器产生的 Bean 实例对象添加 BeanPostProcessor 后置处理器</h2><p>同样在 AbstractAutowireCapableBeanFactory 类中，initializeBean 方法实现为容器创建的 Bean 实例<br>对象添加 BeanPostProcessor 后置处理器，源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//初始容器创建的 Bean 实例对象，为其添加 BeanPostProcessor 后置处理器</span><br><span class="line">protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123;</span><br><span class="line">    //JDK 的安全机制验证权限</span><br><span class="line">    if (System.getSecurityManager() != null) &#123;</span><br><span class="line">        //实现 PrivilegedAction 接口的匿名内部类</span><br><span class="line">        AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">            public Object run() &#123;</span><br><span class="line">                invokeAwareMethods(beanName, bean);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        //为 Bean 实例对象包装相关属性，如名称，类加载器，所属容器等信息</span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    //对 BeanPostProcessor 后置处理器的 postProcessBeforeInitialization</span><br><span class="line">    //回调方法的调用，为 Bean 实例初始化前做一些处理</span><br><span class="line">    if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    //调用 Bean 实例对象初始化的方法，这个初始化方法是在 Spring Bean 定义配置</span><br><span class="line">    //文件中通过 init-method 属性指定的</span><br><span class="line">    try &#123;</span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable ex) &#123;</span><br><span class="line">        throw new BeanCreationException(</span><br><span class="line">                (mbd != null ? mbd.getResourceDescription() : null),</span><br><span class="line">                beanName, &quot;Invocation of init method failed&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    //对 BeanPostProcessor 后置处理器的 postProcessAfterInitialization</span><br><span class="line">    //回调方法的调用，为 Bean 实例初始化之后做一些处理</span><br><span class="line">    if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    return wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//调用 BeanPostProcessor 后置处理器实例对象初始化之前的处理方法</span><br><span class="line">public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)</span><br><span class="line">        throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">    Object result = existingBean;</span><br><span class="line">    //遍历容器为所创建的 Bean 添加的所有 BeanPostProcessor 后置处理器</span><br><span class="line">    for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">        //调用 Bean 实例所有的后置处理中的初始化前处理方法，为 Bean 实例对象在</span><br><span class="line">        //初始化之前做一些自定义的处理操作</span><br><span class="line">        result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">        if (result == null) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用 BeanPostProcessor 后置处理器实例对象初始化之后的处理方法</span><br><span class="line">public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)</span><br><span class="line">        throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">    Object result = existingBean;</span><br><span class="line">    //遍历容器为所创建的 Bean 添加的所有 BeanPostProcessor 后置处理器</span><br><span class="line">    for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">        //调用 Bean 实例所有的后置处理中的初始化后处理方法，为 Bean 实例对象在</span><br><span class="line">        //初始化之后做一些自定义的处理操作</span><br><span class="line">        result = beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">        if (result == null) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanPostProcessor 是一个接口，其初始化前的操作方法和初始化后的操作方法均委托其实现子类来实<br>现，在 Spring 中，BeanPostProcessor 的实现子类非常的多，分别完成不同的操作，如：AOP 面向切面<br>编程的注册通知适配器、Bean 对象的数据校验、Bean 继承属性/方法的合并等等，我们以最简单的 AOP<br>切面织入来简单了解其主要的功能。</p><h2><a id="AdvisorAdapterRegistrationManager__Bean__129"></a><a class="header-anchor" href="#advisoradapterregistrationmanager-在-bean-对象初始化后注册通知适配器">¶</a>AdvisorAdapterRegistrationManager 在 Bean 对象初始化后注册通知适配器</h2><p>AdvisorAdapterRegistrationManager 是 BeanPostProcessor 的一个实现类，其主要的作用为容器中管<br>理的 Bean 注册一个面向切面编程的通知适配器，以便在 Spring 容器为所管理的 Bean 进行面向切面编<br>程时提供方便，其源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//为容器中管理的 Bean 注册一个面向切面编程的通知适配器</span><br><span class="line">public class AdvisorAdapterRegistrationManager implements BeanPostProcessor &#123;</span><br><span class="line">	//容器中负责管理切面通知适配器注册的对象</span><br><span class="line">	private AdvisorAdapterRegistry advisorAdapterRegistry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Specify the AdvisorAdapterRegistry to register AdvisorAdapter beans with.</span><br><span class="line">	 * Default is the global AdvisorAdapterRegistry.</span><br><span class="line">	 * @see GlobalAdvisorAdapterRegistry</span><br><span class="line">	 */</span><br><span class="line">	public void setAdvisorAdapterRegistry(AdvisorAdapterRegistry advisorAdapterRegistry) &#123;</span><br><span class="line">		this.advisorAdapterRegistry = advisorAdapterRegistry;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//BeanPostProcessor 在 Bean 对象初始化前的操作</span><br><span class="line">	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">		//没有做任何操作，直接返回容器创建的 Bean 对象</span><br><span class="line">		return bean;</span><br><span class="line">	&#125;</span><br><span class="line">	//BeanPostProcessor 在 Bean 对象初始化后的操作</span><br><span class="line">	public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">		if (bean instanceof AdvisorAdapter)&#123;</span><br><span class="line">			//如果容器创建的 Bean 实例对象是一个切面通知适配器，则向容器的注册</span><br><span class="line">			this.advisorAdapterRegistry.registerAdvisorAdapter((AdvisorAdapter) bean);</span><br><span class="line">		&#125;</span><br><span class="line">		return bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的 BeanPostProcessor 接口实现类的也类似，都是对 Bean 对象使用到的一些特性进行处理，或者<br>向 IOC 容器中注册，为创建的 Bean 实例对象做一些自定义的功能增加，这些操作是容器初始化 Bean 时<br>自动触发的，不需要认为的干预。</p><h1><a id="Spring_IOC__autowiring__138"></a>Spring IOC 容器 autowiring 实现原理</h1><p>Spring IOC 容器提供了两种管理 Bean 依赖关系的方式：</p><ul><li>显式管理：通过 BeanDefinition 的属性值和构造方法实现 Bean 依赖关系管理。</li><li>autowiring：Spring IOC 容器的依赖自动装配功能，不需要对 Bean 属性的依赖关系做显式的声明，只需要在配置好 autowiring 属性，IOC 容器会自动使用反射查找属性的类型和名称，然后基于属性的类型或者名称来自动匹配容器中管理的 Bean，从而自动地完成依赖注入。</li></ul><p>通过对 autowiring 自动装配特性的理解，我们知道容器对 Bean 的自动装配发生在容器对 Bean 依赖注<br>入的过程中。在前面对 Spring IOC 容器的依赖注入过程源码分析中，我们已经知道了容器对 Bean 实<br>例对象的属性注入的处理发生在 AbstractAutoWireCapableBeanFactory 类中的 populateBean 方法中，<br>我们通过程序流程分析 autowiring 的实现原理</p><h2><a id="AbstractAutoWireCapableBeanFactory__Bean__148"></a><a class="header-anchor" href="#abstractautowirecapablebeanfactory-对-bean-实例进行属性依赖注入">¶</a>AbstractAutoWireCapableBeanFactory 对 Bean 实例进行属性依赖注入</h2><p>应用第一次通过 getBean 方法(配置了 lazy-init 预实例化属性的除外)向 IoC 容器索取 Bean 时，容器<br>创建 Bean 实例对象，并且对 Bean 实例对象进行属性依赖注入，AbstractAutoWireCapableBeanFactory<br>的 populateBean 方法就是实现 Bean 属性依赖注入的功能，其主要源码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected void populateBean(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw) &#123;</span><br><span class="line">//获取 Bean 定义的属性值，并对属性值进行处理</span><br><span class="line">PropertyValues pvs = mbd.getPropertyValues();</span><br><span class="line">……</span><br><span class="line">    //对依赖注入处理，首先处理 autowiring 自动装配的依赖注入</span><br><span class="line">    if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">        mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">        </span><br><span class="line">        MutablePropertyValues newPvs = new MutablePropertyValues(pvs);</span><br><span class="line">        //根据 Bean 名称进行 autowiring 自动装配处理</span><br><span class="line">        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">            autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line">        //根据 Bean 类型进行 autowiring 自动装配处理</span><br><span class="line">        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">            autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //对非 autowiring 的属性进行依赖注入处理</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><a id="Spring_IOC__Bean__autowiring__154"></a><a class="header-anchor" href="#spring-ioc-容器根据-bean-名称或者类型进行-autowiring-自动依赖注入：">¶</a>Spring IOC 容器根据 Bean 名称或者类型进行 autowiring 自动依赖注入：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">//根据名称对属性进行自动依赖注入</span><br><span class="line">protected void autowireByName(</span><br><span class="line">        String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) &#123;</span><br><span class="line">    //对 Bean 对象中非简单属性(不是简单继承的对象，如 8 中原始类型，字符串，URL 等都是简单属性)进行处理</span><br><span class="line">    String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">    for (String propertyName : propertyNames) &#123;</span><br><span class="line">        //如果 Spring IOC 容器中包含指定名称的 Bean</span><br><span class="line">        if (containsBean(propertyName)) &#123;</span><br><span class="line">            //使用当前Bean的属性名，在IoC容器中获取对应的bean，让将获取的bean设置为当前的Bean的属性值</span><br><span class="line">            //调用 getBean 方法向 IoC 容器索取指定名称的 Bean 实例，迭代触发属性的初始化和依赖注入</span><br><span class="line">            Object bean = getBean(propertyName);</span><br><span class="line">            //为指定名称的属性赋予属性值</span><br><span class="line">            pvs.add(propertyName, bean);</span><br><span class="line">            //指定名称属性注册依赖 Bean 名称，进行属性依赖注入</span><br><span class="line">            registerDependentBean(propertyName, beanName);</span><br><span class="line">            if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(&quot;Added autowiring by name from bean name &apos;&quot; + beanName +</span><br><span class="line">                        &quot;&apos; via property &apos;&quot; + propertyName + &quot;&apos; to bean named &apos;&quot; + propertyName + &quot;&apos;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            if (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(&quot;Not autowiring property &apos;&quot; + propertyName + &quot;&apos; of bean &apos;&quot; + beanName +</span><br><span class="line">                        &quot;&apos; by name: no matching bean found&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//根据类型对属性进行自动依赖注入</span><br><span class="line">protected void autowireByType(</span><br><span class="line">        String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) &#123;</span><br><span class="line">    //获取用户定义的类型转换器</span><br><span class="line">    TypeConverter converter = getCustomTypeConverter();</span><br><span class="line">    if (converter == null) &#123;</span><br><span class="line">        converter = bw;</span><br><span class="line">    &#125;</span><br><span class="line">    //存放解析的要注入的属性</span><br><span class="line">    Set&lt;String&gt; autowiredBeanNames = new LinkedHashSet&lt;String&gt;(4);</span><br><span class="line">    //对 Bean 对象中非简单属性(不是简单继承的对象，如 8 中原始类型，字符</span><br><span class="line">    //URL 等都是简单属性)进行处理</span><br><span class="line">    String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">    for (String propertyName : propertyNames) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //获取指定属性名称的属性描述器</span><br><span class="line">            PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);</span><br><span class="line">            // Don&apos;t try autowiring by type for type Object: never makes sense,</span><br><span class="line">            // even if it technically is a unsatisfied, non-simple property.</span><br><span class="line">            //不对 Object 类型的属性进行 autowiring 自动依赖注入</span><br><span class="line">            if (!Object.class.equals(pd.getPropertyType())) &#123;</span><br><span class="line">                //获取属性的 setter 方法</span><br><span class="line">                MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);</span><br><span class="line">                // Do not allow eager init for type matching in case of a prioritized post-processor.</span><br><span class="line">                //检查指定类型是否可以被转换为目标对象的类型</span><br><span class="line">                boolean eager = !PriorityOrdered.class.isAssignableFrom(bw.getWrappedClass());</span><br><span class="line">                //创建一个要被注入的依赖描述</span><br><span class="line">                DependencyDescriptor desc = new AutowireByTypeDependencyDescriptor(methodParam, eager);</span><br><span class="line">                //根据容器的 Bean 定义解析依赖关系，返回所有要被注入的 Bean 对象</span><br><span class="line">                Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);</span><br><span class="line">                if (autowiredArgument != null) &#123;</span><br><span class="line">                    //为属性赋值所引用的对象</span><br><span class="line">                    pvs.add(propertyName, autowiredArgument);</span><br><span class="line">                &#125;</span><br><span class="line">                for (String autowiredBeanName : autowiredBeanNames) &#123;</span><br><span class="line">                    //指定名称属性注册依赖 Bean 名称，进行属性依赖注入</span><br><span class="line">                    registerDependentBean(autowiredBeanName, beanName);</span><br><span class="line">                    if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                        logger.debug(&quot;Autowiring by type from bean name &apos;&quot; + beanName + &quot;&apos; via property &apos;&quot; +</span><br><span class="line">                                propertyName + &quot;&apos; to bean named &apos;&quot; + autowiredBeanName + &quot;&apos;&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //释放已自动注入的属性</span><br><span class="line">                autowiredBeanNames.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (BeansException ex) &#123;</span><br><span class="line">            throw new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的源码分析，我们可以看出来通过属性名进行自动依赖注入的相对比通过属性类型进行自动依<br>赖注入要稍微简单一些，但是真正实现属性注入的是 DefaultSingletonBeanRegistry 类的<br>registerDependentBean 方法。</p><h2><a id="DefaultSingletonBeanRegistry__registerDependentBean__160"></a><a class="header-anchor" href="#defaultsingletonbeanregistry-的-registerdependentbean-方法对属性注入">¶</a>DefaultSingletonBeanRegistry 的 registerDependentBean 方法对属性注入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//为指定的 Bean 注入依赖的 Bean</span><br><span class="line">public void registerDependentBean(String beanName, String dependentBeanName) &#123;</span><br><span class="line">    //处理 Bean 名称，将别名转换为规范的 Bean 名称</span><br><span class="line">    String canonicalName = canonicalName(beanName);</span><br><span class="line">    // 翻译一下就是：set里的bean都要依赖 key</span><br><span class="line">    //先从容器中：bean 名称--&gt;全部依赖 Bean 名称集合找查找给定名称 Bean 的依赖 Bean</span><br><span class="line">    //多线程同步，保证容器内数据的一致性</span><br><span class="line">    synchronized (this.dependentBeanMap) &#123;</span><br><span class="line">        //获取给定名称 Bean 的所有依赖 Bean 名称</span><br><span class="line">        Set&lt;String&gt; dependentBeans = this.dependentBeanMap.get(canonicalName);</span><br><span class="line">        if (dependentBeans == null) &#123;</span><br><span class="line">            //为 Bean 设置依赖 Bean 信息</span><br><span class="line">            dependentBeans = new LinkedHashSet&lt;String&gt;(8);</span><br><span class="line">            this.dependentBeanMap.put(canonicalName, dependentBeans);</span><br><span class="line">        &#125;</span><br><span class="line">        //向容器中：bean 名称--&gt;全部依赖 Bean 名称集合添加 Bean 的依赖信息</span><br><span class="line">        //即，将 Bean 所依赖的 Bean 添加到容器的集合中</span><br><span class="line">        dependentBeans.add(dependentBeanName);</span><br><span class="line">    &#125;</span><br><span class="line">    // 翻译一下就是：key需要依赖set中的bean</span><br><span class="line">    //从容器中：bean 名称--&gt;指定名称 Bean 的依赖 Bean 集合找查找给定名称 Bean 的依赖 Bean</span><br><span class="line">    synchronized (this.dependenciesForBeanMap) &#123;</span><br><span class="line">        Set&lt;String&gt; dependenciesForBean = this.dependenciesForBeanMap.get(dependentBeanName);</span><br><span class="line">        if (dependenciesForBean == null) &#123;</span><br><span class="line">            dependenciesForBean = new LinkedHashSet&lt;String&gt;(8);</span><br><span class="line">            this.dependenciesForBeanMap.put(dependentBeanName, dependenciesForBean);</span><br><span class="line">        &#125;</span><br><span class="line">        //向容器中：bean 名称--&gt;指定 Bean 的依赖 Bean 名称集合添加 Bean 的依赖信息</span><br><span class="line">        //即，将 Bean 所依赖的 Bean 添加到容器的集合中</span><br><span class="line">        dependenciesForBean.add(canonicalName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对 autowiring 的源码分析，我们可以看出，autowiring 的实现过程：</p><ul><li>对 Bean 的属性代调用 getBean 方法，完成依赖 Bean 的初始化和依赖注入。</li><li>将依赖 Bean 的属性引用设置到被依赖的 Bean 属性上。</li><li>将依赖 Bean 的名称和被依赖 Bean 的名称存储在 IOC 容器的集合中。</li></ul><p>Spring IOC 容器的 autowiring 属性自动依赖注入是一个很方便的特性，可以简化开发时的配置，但是凡是都有两面性，<br>自动属性依赖注入也有不足，首先，Bean 的依赖关系在配置文件中无法很清楚地看出来，对于维护造成一定困难。其<br>次，由于自动依赖注入是 Spring 容器自动执行的，容器是不会智能判断的，如果配置不当，将会带来无法预料的后果，<br>所以自动依赖注入特性在使用时还是综合考虑。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jeff-eric.github.com/blog/blog/2019/10/22/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jeff-Eric"><meta itemprop="description" content=""><meta itemprop="image" content="/blog/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="纯天然绿色学渣"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/blog/2019/10/22/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/" class="post-title-link" itemprop="url">软件架构设计的七大原则</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-22 18:51:56" itemprop="dateCreated datePublished" datetime="2019-10-22T18:51:56+08:00">2019-10-22</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-10-31 12:11:12" itemprop="dateModified" datetime="2019-10-31T12:11:12+08:00">2019-10-31</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/blog/2019/10/22/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/2019/10/22/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/" itemprop="commentCount"></span> </a></span><span id="/blog/2019/10/22/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/" class="leancloud_visitors" data-flag-title="软件架构设计的七大原则"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body han-init-context" itemprop="articleBody"><h1><a id="_1"></a>开闭原则</h1><p>开闭原则（Open-Closed Principle, OCP）是指一个软件实体如类、模块和函数应该对<br>扩展开放，对修改关闭。所谓的开闭，也正是对扩展和修改两个行为的一个原则。强调<br>的是用抽象构建框架，用实现扩展细节。可以提高软件系统的可复用性及可维护性。开<br>闭原则，是面向对象设计中最基础的设计原则。它指导我们如何建立稳定灵活的系统，<br>例如：我们版本更新，我尽可能不修改源代码，但是可以增加新功能。<br>在现实生活中对于开闭原则也有体现。比如，很多互联网公司都实行弹性制作息时间，<br>规定每天工作 8 小时。意思就是说，对于每天工作 8 小时这个规定是关闭的，但是你什<br>么时候来，什么时候走是开放的。早来早走，晚来晚走。</p><p>实现开闭原则的核心思想就是面向抽象编程，接下来我们来看一段代码<br>首先创建一个课程接口 ICourse：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface ICourse &#123;</span><br><span class="line">    Integer getId();</span><br><span class="line">    String getName();</span><br><span class="line">    Double getPrice();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个课程生态有 Java 架构、大数据、人工智能、前端、软件测试等，我们来创建一个 Java<br>架构课程的类 JavaCourse：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class JavaCourse implements ICourse&#123;</span><br><span class="line">    private Integer Id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Double price;</span><br><span class="line">    public JavaCourse(Integer id, String name, Double price) &#123;</span><br><span class="line">        this.Id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return this.Id;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">    public Double getPrice() &#123;</span><br><span class="line">        return this.price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们要给 Java 架构课程做活动，价格优惠。如果修改 JavaCourse 中的 getPrice()<br>方法，则会存在一定的风险，可能影响其他地方的调用结果。我们如何在不修改原有代<br>码前提前下，实现价格优惠这个功能呢？现在，我们再写一个处理优惠逻辑的类，<br>JavaDiscountCourse 类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class JavaDiscountCourse extends JavaCourse &#123;</span><br><span class="line">    public JavaDiscountCourse(Integer id, String name, Double price) &#123;</span><br><span class="line">        super(id, name, price);</span><br><span class="line">    &#125;</span><br><span class="line">    public Double getOriginPrice()&#123;</span><br><span class="line">        return super.getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">    public Double getPrice()&#123;</span><br><span class="line">        return super.getPrice() * 0.61;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾一下，简单一下类结构图：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191031104504.png" alt></p><h1><a id="_25"></a>依赖倒置原则</h1></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jeff-eric.github.com/blog/blog/2019/10/22/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jeff-Eric"><meta itemprop="description" content=""><meta itemprop="image" content="/blog/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="纯天然绿色学渣"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/blog/2019/10/22/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">常用的设计模式</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-22 18:51:56" itemprop="dateCreated datePublished" datetime="2019-10-22T18:51:56+08:00">2019-10-22</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-11-08 20:20:32" itemprop="dateModified" datetime="2019-11-08T20:20:32+08:00">2019-11-08</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/blog/2019/10/22/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/2019/10/22/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="commentCount"></span> </a></span><span id="/blog/2019/10/22/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="leancloud_visitors" data-flag-title="常用的设计模式"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body han-init-context" itemprop="articleBody"><h1><a id="_1"></a>代理模式</h1><p>关心的执行的过程<br>主语对象是被代理对象（就是被调方）<br>或者说代理模式代理的开头和结尾，因为可以动态的<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191031221753.png" alt></p><h1><a id="_7"></a>委派模式</h1><p>区别于代理模式<br>关心的是结果，不关心过程<br>主语对象是委托人（就是调用方）<br>或者说委派模式代理的中间过程，因为中间过程可以是动态的<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191102002621.png" alt><br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191102003019.png" alt><br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191102003419.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public interface IExector &#123;</span><br><span class="line">	void doing();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ExectorA implements IExector &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void doing() &#123;</span><br><span class="line">		System.out.println(&quot;A开始执行任务&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ExectorB implements IExector&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void doing() &#123;</span><br><span class="line">		System.out.println(&quot;B开始执行任务&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Dispatcher implements IExector&#123;</span><br><span class="line">	IExector exector;</span><br><span class="line">	Dispatcher(IExector exector)&#123;</span><br><span class="line">		this.exector = exector;</span><br><span class="line">	&#125;</span><br><span class="line">	public void doing() &#123;</span><br><span class="line">		this.exector.doing();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><a id="_17"></a>工厂模式</h1><p>主语对象是公共的方法或公共的行为 和 某个具体的bean<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191101114319.png" alt></p><ul><li>结果论：把实现过程封装起来，对于调用者来说，只关心结果<br>就比如使用ofo：使用的人只关心我能用到车，至于这个车怎么造的，谁造的，什么时间造的等等，你是不关心的</li><li>便于扩展</li></ul><h1><a id="_24"></a>策略模式</h1><p>强调：最终的目的都是一样的<br>主语对象是策略<br>比如解决一道数学问题，可以有多种解答方式，但是最终的结果都是一样的，这几种方式可以任意切换<br>再比如超市搞优惠，可以使用会员积分，优惠券、满减等不能优惠方式，但最终结果都是优惠价格<br>区别于委派模式，策略模式更注重的策略的多样性，委派模式注重的某一种策略<br>委派模式注重：谁来做<br>测试模式注重：有多少方式来做</p><h2><a id="_33"></a><a class="header-anchor" href="#简单工厂">¶</a>简单工厂</h2><p>内容大而全，所有的创建方法都在这个类里面<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191101224304.png" alt></p><h2><a id="_36"></a><a class="header-anchor" href="#工厂方法">¶</a>工厂方法</h2><p>其实就是对简单工厂的一个抽象封装，将各自不同创建内容进行单独封装，并抽象成接口形式<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191101224334.png" alt><br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191101224349.png" alt><br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191101224414.png" alt><br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191101224426.png" alt></p><h2><a id="_42"></a><a class="header-anchor" href="#抽象工厂">¶</a>抽象工厂</h2><p>其实就是对工厂方法的一个再封装，将公共的东西封装成抽象类，将不同的部分由各自子工厂自行实现<br>其实就是变相的静态代理<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191101224719.png" alt><br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191101224748.png" alt><br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191101224804.png" alt><br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191101224838.png" alt></p><h1><a id="_50"></a>单例模式</h1><p>1.保证系统启动到停止，只产生一个实例（节省资源）<br>2.在应用中遇到功能性冲突的时候，需要使用单例模式（保证功能不冲突）</p><ul><li>配置文件<br>针对某一种功能，如果两个配置文件是相同的，那其中有一个就是浪费的，如果不一样，就不知道该用哪个</li><li>直系领导<br>两个领导给你发命令，你都不知道该听谁的</li><li>公历<br>是为了和国际同步，如果不同步，那就会有时间差问题<br>等等…</li></ul><h2><a id="_61"></a><a class="header-anchor" href="#单例的几种写法">¶</a>单例的几种写法</h2><ul><li>饿汉模式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton implements java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">	public static Singleton INSTANCE = new Singleton();</span><br><span class="line"></span><br><span class="line">	protected Singleton() &#123;  &#125;</span><br><span class="line"></span><br><span class="line">	private Object getInstance() &#123;</span><br><span class="line">		return INSTANCE;   </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>懒汉模式 (线程不安全)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton1 &#123;</span><br><span class="line">	private Singleton1() &#123;&#125;</span><br><span class="line">	private static Singleton1 single = null;</span><br><span class="line">	</span><br><span class="line">	public static Singleton1 getInstance() &#123;</span><br><span class="line">		if (single == null) &#123;</span><br><span class="line">			single = new Singleton1();</span><br><span class="line">		&#125;</span><br><span class="line">		return single;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>饿汉模式（静态代码块）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pubic class Singleton &#123;</span><br><span class="line">   private Singleton instance = null;</span><br><span class="line">   static &#123;</span><br><span class="line">      instance = new Singleton;</span><br><span class="line">   &#125;</span><br><span class="line">   private Singleton () &#123;&#125;;</span><br><span class="line">   public static Singleton getInstance() &#123;</span><br><span class="line">      return this.instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 从上往下(必须声明在前，使用在后)</span><br><span class="line">// 先属性、后方法</span><br><span class="line">// 先静态、后动态</span><br></pre></td></tr></table></figure><ul><li>饿汉模式（线程安全，但是每次都需要上锁，大部分情况下用不到）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton2 &#123;</span><br><span class="line">	private Singleton2() &#123;&#125;</span><br><span class="line">	private static Singleton2 single=null;</span><br><span class="line">	</span><br><span class="line">	public static synchronized Singleton2 getInstance() &#123;</span><br><span class="line">		if (single == null) &#123;</span><br><span class="line">			single = new Singleton2();</span><br><span class="line">		&#125;</span><br><span class="line">		return single;  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>懒汉模式（双重锁检查）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton3 &#123;</span><br><span class="line">	//1、第一步先将构造方法私有化</span><br><span class="line">	private Singleton3() &#123;&#125;</span><br><span class="line">	//2、然后声明一个静态变量保存单例的引用</span><br><span class="line">	private static Singleton3 single=null;</span><br><span class="line">	//3、通过提供一个静态方法来获得单例的引用</span><br><span class="line">	//为了保证多线程环境下的另一种实现方式，双重锁检查</span><br><span class="line">	//性能，第一次的时候</span><br><span class="line">	public static Singleton3 getInstance() &#123;  </span><br><span class="line">	  if (single == null) &#123;</span><br><span class="line">	      synchronized (Singleton3.class) &#123;</span><br><span class="line">	          if (single == null) &#123;    </span><br><span class="line">	              single = new Singleton3();</span><br><span class="line">	          &#125;    </span><br><span class="line">	      &#125;    </span><br><span class="line">	  &#125;    </span><br><span class="line">	   return single;   </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>内部类方式 (既解决了线程安全问题，有解决的性能问题，因为是有classLoad保证线程安装的)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton4 &#123;</span><br><span class="line">	//1、先声明一个静态内部类</span><br><span class="line">	//private 私有的保证别人不能修改</span><br><span class="line">	//static 保证全局唯一</span><br><span class="line">	private static class LazyHolder &#123;</span><br><span class="line">		//final 为了防止内部误操作，代理模式，GgLib的代理模式</span><br><span class="line">		private static final Singleton4 INSTANCE = new Singleton4();</span><br><span class="line">	&#125;</span><br><span class="line">	//2、将默认构造方法私有化</span><br><span class="line">	private Singleton4 ()&#123;&#125;</span><br><span class="line">	//相当于有一个默认的public的无参的构造方法，就意味着在代码中随时都可以new出来</span><br><span class="line">		</span><br><span class="line">	//3、同样提供静态方法获取实例</span><br><span class="line">	//final 确保别人不能覆盖</span><br><span class="line">	public static final Singleton4 getInstance() &#123;  </span><br><span class="line">		</span><br><span class="line">		//方法中的逻辑，是要在用户调用的时候才开始执行的</span><br><span class="line">		//方法中实现逻辑需要分配内存，也是调用时才分配的</span><br><span class="line">		return LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>枚举</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">    Singleton()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><a id="_78"></a>原型模式</h1><p>区别于多例，基于拷贝（深拷贝、浅拷贝，反射）<br>能够直接拷贝其实际内容的数据类型，只支持8个基本数据类型和string，其余都是复制的地址引用。<br>克隆实际上是一种字节码克隆，而不是重新new一个对象,不走构造方法<br>反射：性能并不高，一般用在初始化，不会再运行时使用<br>浅拷贝：只是复制了地址引用，不复制实际的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//默认浅克隆，只克隆八大基本数据类型和String</span><br><span class="line">super.clone();</span><br></pre></td></tr></table></figure><h4><a id="_85"></a><a class="header-anchor" href="#字节码克隆">¶</a>字节码克隆</h4><p><font color="red">克隆是不走构造方法的，直接是字节码复制</font></p><p><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191105175126.png" alt></p><h1><a id="_90"></a>模板模式</h1><p>template 就是一个固定的模板，就类似：</p><ul><li>spring mvc的RestTemplate, restful请求接口的流程是一样的，都是基于http的。</li><li>java jdbc也定义了一套模板<br>1.加载驱动类DriverManager<br>2.建立连接<br>3.创建语句集（标准语句集、预处理语句集）(Mysql/Oracle/SqlServer等等)<br>4.执行语句集<br>5.获取结果集ResultSet<br>6.ORM</li></ul><p>说白了就是对一个东西整个流程的抽象和封装</p><p><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191105202816.png" alt><br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191105203340.png" alt></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jeff-eric.github.com/blog/blog/2019/10/22/%E7%BA%BF%E7%A8%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jeff-Eric"><meta itemprop="description" content=""><meta itemprop="image" content="/blog/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="纯天然绿色学渣"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/blog/2019/10/22/%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">线程</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-22 18:51:56" itemprop="dateCreated datePublished" datetime="2019-10-22T18:51:56+08:00">2019-10-22</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-10-24 11:37:50" itemprop="dateModified" datetime="2019-10-24T11:37:50+08:00">2019-10-24</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/blog/2019/10/22/%E7%BA%BF%E7%A8%8B/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/2019/10/22/%E7%BA%BF%E7%A8%8B/" itemprop="commentCount"></span> </a></span><span id="/blog/2019/10/22/%E7%BA%BF%E7%A8%8B/" class="leancloud_visitors" data-flag-title="线程"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body han-init-context" itemprop="articleBody"><h1><a id="_1"></a>线程的状态</h1><p><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191023105600.png" alt></p><h3><a id="new_3"></a><a class="header-anchor" href="#新建初始状态-new">¶</a>新建初始状态（new）</h3><p>实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。</p><h3><a id="runnable_5"></a><a class="header-anchor" href="#就绪状态-runnable">¶</a>就绪状态（runnable）</h3><p>也被称为“可执行状态”。线程对象被创建后，其他线程调用了该对象的start()方法，从而启动该线程。如：thread.start(); 处于就绪状态的线程随时可能被CPU调度执行。</p><ul><li>就绪状态只是说你资格运行，调度程序没有挑选到你，你就永远是就绪状态。</li><li>调用线程的start()方法，此线程进入就绪状态。</li><li>当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。</li><li>当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态。</li></ul><h3><a id="Blocked_12"></a><a class="header-anchor" href="#阻塞状态-blocked">¶</a>阻塞状态（Blocked）</h3><p>阻塞状态是线程因为某种原因放弃CPU使用权限，暂时停止运行。直到线程进入就绪状态，才有机会进入运行状态。阻塞的三种情况：</p><ul><li><h4><a id="_14"></a><a class="header-anchor" href="#等待阻塞">¶</a>等待阻塞</h4></li></ul><p>处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。通过调用线程的wait()方法，让线程等待某工作的完成。</p><ul><li><h4><a id="_16"></a><a class="header-anchor" href="#同步阻塞">¶</a>同步阻塞</h4></li></ul><p>线程在获取synchronized同步锁失败（因为锁被其他线程占用），它会进入同步阻塞状态。</p><ul><li><h4><a id="_18"></a><a class="header-anchor" href="#其他阻塞">¶</a>其他阻塞</h4></li></ul><p>通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或超时、或者I/O处理完毕时，线程重新转入就绪状态。</p><h3><a id="Dead_21"></a><a class="header-anchor" href="#死亡状态-dead">¶</a>死亡状态（Dead）</h3><p>线程执行完了或因异常退出了run()方法，该线程结束生命周期。</p><h1><a id="_24"></a>每个对象都有的方法（机制）</h1><p>synchronized, wait, notify 是任何对象都具有的同步工具。让我们先来了解他们</p><h3><a id="monitor_26"></a><a class="header-anchor" href="#monitor">¶</a>monitor</h3><p>他们是应用于同步问题的人工线程调度工具。讲其本质，首先就要明确monitor的概念，Java中的每个对象都有一个监视器，来监测并发代码的重入。在非多线程编码时该监视器不发挥作用，反之如果在synchronized 范围内，监视器发挥作用。<br>wait/notify必须存在于synchronized块中。并且，这三个关键字针对的是同一个监视器（某对象的监视器）。这意味着wait之后，其他线程可以进入同步块执行。<br>当某代码并不持有监视器的使用权时（如图中5的状态，即脱离同步块）去wait或notify，会抛出java.lang.IllegalMonitorStateException。也包括在synchronized块中去调用另一个对象的wait/notify，因为不同对象的监视器不同，同样会抛出此异常。</p><h3><a id="volatile_30"></a><a class="header-anchor" href="#volatile">¶</a>volatile</h3><p>多线程的内存模型：main memory（主存）、working memory（线程栈），在处理数据时，线程会把值从主存load到本地栈，完成操作后再save回去(volatile关键词的作用：每次针对该变量的操作都激发一次load and save)。<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191023115955.png" alt><br>针对多线程使用的变量如果不是volatile或者final修饰的，很有可能产生不可预知的结果（另一个线程修改了这个值，但是之后在某线程看到的是修改之前的值）。其实道理上讲同一实例的同一属性本身只有一个副本。但是多线程是会缓存值的，本质上，volatile就是不去缓存，直接取值。在线程安全的情况下加volatile会牺牲性能。</p><h1><a id="_35"></a>基本线程类</h1><p>基本线程类指的是Thread类，Runnable接口，Callable接口</p><h3><a id="Thread_37"></a><a class="header-anchor" href="#thread">¶</a>Thread</h3><p>Thread 类实现了Runnable接口<br>Thread类相关方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//当前线程可转让cpu控制权，让别的就绪状态线程运行（切换）</span><br><span class="line">public static Thread.yield() </span><br><span class="line">//暂停一段时间</span><br><span class="line">public static Thread.sleep()  </span><br><span class="line">//在一个线程中调用other.join(),将等待other执行完后才继续本线程。　　　　</span><br><span class="line">public join()</span><br><span class="line">//中断线程</span><br><span class="line">public interrupte()</span><br></pre></td></tr></table></figure><p>关于中断：<br>它并不像stop方法那样会中断一个正在运行的线程。线程会不时地检测中断标识位，以判断线程是否应该被中断（中断标识值是否为true）。终端只会影响到wait状态、sleep状态和join状态。被打断的线程会抛出InterruptedException。<br>Thread.interrupted()检查当前线程是否发生中断，返回boolean<br>synchronized在获锁的过程中是不能被中断的。<br>中断是一个状态！interrupt()方法只是将这个状态置为true而已。所以说正常运行的程序不去检测状态，就不会终止，而wait等阻塞方法会去检查并抛出异常。如果在正常运行的程序中添加while(!Thread.interrupted()) ，则同样可以在中断后离开代码体</p><h2><a id="join_47"></a><a class="header-anchor" href="#join实现原理">¶</a>join实现原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line">    ...</span><br><span class="line">    public final void join() throws InterruptedException &#123;</span><br><span class="line">        join(0);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    public final synchronized void join(long millis) throws InterruptedException &#123;</span><br><span class="line">        long base = System.currentTimeMillis();</span><br><span class="line">        long now = 0;</span><br><span class="line">        if (millis &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (millis == 0) &#123; //判断是否携带阻塞的超时时间，等于0表示没有设置超时时间</span><br><span class="line">            while (isAlive()) &#123;//isAlive获取线程状态，无线等待直到previousThread线程结束</span><br><span class="line">                wait(0); //调用Object中的wait方法实现线程的阻塞</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123; //阻塞直到超时</span><br><span class="line">            while (isAlive()) &#123; </span><br><span class="line">                long delay = millis - now;</span><br><span class="line">                if (delay &lt;= 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>我们需要知道的是，调用wait方法必须要获取锁，所以join方法是被synchronized修饰的，synchronized修饰在方法层面相当于synchronized(this),this就是previousThread本身的实例。</p><p>join为什么阻塞的是主线程呢? 不理解的原因是阻塞主线程的方法是放在previousThread这个实例作用，让大家误以为应该阻塞previousThread线程。实际上主线程会持有previousThread这个对象的锁，然后调用wait方法去阻塞，而这个方法的调用者是在主线程中的。所以造成主线程阻塞。</p><p>为什么previousThread线程执行完毕就能够唤醒住线程呢？或者说是在什么时候唤醒的？<br>要了解这个问题，我们又得翻jdk的源码，但是如果大家对线程有一定的基本了解的话，通过wait方法阻塞的线程，需要通过notify或者notifyall来唤醒。所以在线程执行完毕以后会有一个唤醒的操作，只是我们不需要关心。</p><p>接下来在hotspot的源码中找到 thread.cpp，看看线程退出以后有没有做相关的事情来证明我们的猜想.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void JavaThread::exit(bool destroy_vm, ExitType exit_type) &#123;</span><br><span class="line">  assert(this == JavaThread::current(),  &quot;thread consistency check&quot;);</span><br><span class="line">  ...</span><br><span class="line">  // Notify waiters on thread object. This has to be done after exit() is called</span><br><span class="line">  // on the thread (if the thread is the last thread in a daemon ThreadGroup the</span><br><span class="line">  // group should have the destroyed bit set before waiters are notified).</span><br><span class="line">  ensure_join(this); </span><br><span class="line">  assert(!this-&gt;has_pending_exception(), &quot;ensure_join should have cleared&quot;);</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>观察一下 ensure_join(this)这行代码上的注释，唤醒处于等待的线程对象，这个是在线程终止之后做的清理工作，这个方法的定义代码片段如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static void ensure_join(JavaThread* thread) &#123;</span><br><span class="line">  // We do not need to grap the Threads_lock, since we are operating on ourself.</span><br><span class="line">  Handle threadObj(thread, thread-&gt;threadObj());</span><br><span class="line">  assert(threadObj.not_null(), &quot;java thread object must exist&quot;);</span><br><span class="line">  ObjectLocker lock(threadObj, thread);</span><br><span class="line">  // Ignore pending exception (ThreadDeath), since we are exiting anyway</span><br><span class="line">  thread-&gt;clear_pending_exception();</span><br><span class="line">  // Thread is exiting. So set thread_status field in  java.lang.Thread class to TERMINATED.</span><br><span class="line">  java_lang_Thread::set_thread_status(threadObj(), java_lang_Thread::TERMINATED);</span><br><span class="line">  // Clear the native thread instance - this makes isAlive return false and allows the join()</span><br><span class="line">  // to complete once we&apos;ve done the notify_all below</span><br><span class="line">  //这里是清除native线程，这个操作会导致isAlive()方法返回false</span><br><span class="line">  java_lang_Thread::set_thread(threadObj(), NULL);</span><br><span class="line">  lock.notify_all(thread);//注意这里</span><br><span class="line">  // Ignore pending exception (ThreadDeath), since we are exiting anyway</span><br><span class="line">  thread-&gt;clear_pending_exception();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ensure_join方法中，调用 lock.notify_all(thread); 唤醒所有等待thread锁的线程，意味着调用了join方法被阻塞的主线程会被唤醒； 到目前为止，我们基本上对join的原理做了一个比较详细的分析</p><p>总结，Thread.join其实底层是通过wait/notifyall来实现线程的通信达到线程阻塞的目的；当线程执行结束以后，会触发两个事情，第一个是设置native线程对象为null、第二个是通过notifyall方法，让等待在previousThread对象锁上的wait方法被唤醒。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Test test = new Test();</span><br><span class="line">        test.test();</span><br><span class="line"></span><br><span class="line">        System.out.println(10000);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test()&#123;</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void print()&#123;</span><br><span class="line">        System.out.println(&quot;aaaaaaaaaaaaa&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">//            Thread.sleep(2000);</span><br><span class="line">            wait();</span><br><span class="line">            wait();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread类最佳实践：<br>写的时候最好要设置线程名称 <a href="http://Thread.name" target="_blank" rel="noopener">Thread.name</a>，并设置线程组 ThreadGroup，目的是方便管理。在出现问题的时候，打印线程栈 (jstack -pid) 一眼就可以看出是哪个线程出的问题，这个线程是干什么的。</p><p>如何获取线程中的异常<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191023164110.png" alt></p><h3><a id="Runnable_72"></a><a class="header-anchor" href="#runnable">¶</a>Runnable</h3><p>与Thread类似</p><h3><a id="Callable_75"></a><a class="header-anchor" href="#callable">¶</a>Callable</h3><p>future模式：并发模式的一种，可以有两种形式，即无阻塞和阻塞，分别是isDone和get。其中Future对象用来存放该线程的返回值以及状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService e = Executors.newFixedThreadPool(3);</span><br><span class="line"> //submit方法有多重参数版本，及支持callable也能够支持runnable接口类型.</span><br><span class="line">Future future = e.submit(new myCallable());</span><br><span class="line">future.isDone() //return true,false 无阻塞</span><br><span class="line">future.get() // return 返回值，阻塞直到该线程运行结束</span><br></pre></td></tr></table></figure><h1><a id="_79"></a>高级多线程控制类</h1><h2><a id="ThreadLocal_80"></a><a class="header-anchor" href="#threadlocal类">¶</a>ThreadLocal类</h2><p>用处：保存线程的独立变量。对一个线程类（继承自Thread)<br>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。常用于用户登录控制，如记录session信息。</p><p>实现：每个Thread都持有一个TreadLocalMap类型的变量（该类是一个轻量级的Map，功能与map一样，区别是桶里放的是entry而不是entry的链表。功能还是一个map。）以本身为key，以目标为value。</p><p>主要方法是get()和set(T a)，set之后在map里维护一个threadLocal -&gt; a，get时将a返回。ThreadLocal是一个特殊的容器。</p><h2><a id="AtomicIntegerAtomicBoolean_88"></a><a class="header-anchor" href="#原子类-atomicinteger-atomicboolean">¶</a>原子类（AtomicInteger、AtomicBoolean……）</h2><p>如果使用atomic wrapper class如atomicInteger，或者使用自己保证原子的操作，则等同于synchronized<br>该方法可用于实现乐观锁，考虑文中最初提到的如下场景：a给b付款10元，a扣了10元，b要加10元。此时c给b2元，但是b的加十元代码约为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(b.value.compareAndSet(old, value))&#123;</span><br><span class="line">   return ;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">   //try again</span><br><span class="line">   // if that fails, rollback and log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><a id="Lock_93"></a><a class="header-anchor" href="#lock">¶</a>Lock</h2><p>lock: 在java.util.concurrent包内。共有三个实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock</span><br><span class="line">ReentrantReadWriteLock.ReadLock</span><br><span class="line">ReentrantReadWriteLock.WriteLock</span><br></pre></td></tr></table></figure><p>主要目的是和synchronized一样， 两者都是为了解决同步问题，处理资源争端而产生的技术。功能类似但有一些区别。</p><p>区别如下：</p><ul><li>lock更灵活，可以自由定义多把锁的枷锁解锁顺序（synchronized要按照先加的后解顺序）</li><li>提供多种加锁方案，lock 阻塞式, trylock 无阻塞式, lockInterruptily 可打断式， 还有trylock的带超时时间版本。</li><li>本质上和监视器锁（即synchronized是一样的）</li><li>能力越大，责任越大，必须控制好加锁和解锁，否则会导致灾难。</li><li>和Condition类的结合。</li><li>性能更高，对比如下图：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191023164858.png" alt><br>具体请看：<a href="https://jeff-eric.github.io/blog/2019/10/22/synchronized-%E5%92%8C-Lock/" target="_blank" rel="noopener">synchronized 和 Lock</a></li></ul><h2><a id="_108"></a><a class="header-anchor" href="#容器类">¶</a>容器类</h2><p>这里就讨论比较常用的两个：</p><ul><li>BlockingQueue</li><li>ConcurrentHashMap</li></ul><h3><a id="BlockingQueue_113"></a><a class="header-anchor" href="#blockingqueue">¶</a>BlockingQueue</h3><p>阻塞队列。该类是java.util.concurrent包下的重要类，通过对Queue的学习可以得知，这个queue是单向队列，可以在队列头添加元素和在队尾删除或取出元素。类似于一个管　　道，特别适用于先进先出策略的一些应用场景。普通的queue接口主要实现有PriorityQueue（优先队列）</p><p>BlockingQueue在队列的基础上添加了多线程协作的功能：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191023165233.png" alt></p><p>除了传统的queue功能（表格左边的两列）之外，还提供了阻塞接口put和take，带超时功能的阻塞接口offer和poll。put会在队列满的时候阻塞，直到有空间时被唤醒；take在队　列空的时候阻塞，直到有东西拿的时候才被唤醒。用于生产者-消费者模型尤其好用，堪称神器。</p><p>常见的阻塞队列有：</p><ul><li>ArrayListBlockingQueue</li><li>LinkedListBlockingQueue</li><li>DelayQueue</li><li>SynchronousQueue</li></ul><h3><a id="ConcurrentHashMap_127"></a><a class="header-anchor" href="#concurrenthashmap">¶</a>ConcurrentHashMap</h3><p>高效的线程安全哈希map。请对比hashTable , concurrentHashMap, HashMap</p><h2><a id="_130"></a><a class="header-anchor" href="#管理类">¶</a>管理类</h2><p>管理类的概念比较泛，用于管理线程，本身不是多线程的，但提供了一些机制来利用上述的工具做一些封装。<br>了解到的值得一提的管理类：ThreadPoolExecutor和 JMX框架下的系统级管理类 ThreadMXBean</p><h3><a id="ThreadPoolExecutor_133"></a><a class="header-anchor" href="#threadpoolexecutor">¶</a>ThreadPoolExecutor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService e = Executors.newCachedThreadPool();</span><br><span class="line">ExecutorService e = Executors.newSingleThreadExecutor();</span><br><span class="line">ExecutorService e = Executors.newFixedThreadPool(3);</span><br><span class="line">// 第一种是可变大小线程池，按照任务数来分配线程，</span><br><span class="line">// 第二种是单线程池，相当于FixedThreadPool(1)</span><br><span class="line">// 第三种是固定大小线程池。</span><br><span class="line">// 然后运行</span><br><span class="line">e.execute(new MyRunnableImpl());</span><br></pre></td></tr></table></figure><p>该类内部是通过ThreadPoolExecutor实现的，掌握该类有助于理解线程池的管理，本质上，他们都是ThreadPoolExecutor类的各种实现版本。请参见javadoc：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191023165614.png" alt><br>ThreadPoolExecutor参数解释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">corePoolSize:池内线程初始值与最小值，就算是空闲状态，也会保持该数量线程。</span><br><span class="line"></span><br><span class="line">maximumPoolSize:线程最大值，线程的增长始终不会超过该值。</span><br><span class="line"></span><br><span class="line">keepAliveTime：当池内线程数高于corePoolSize时，经过多少时间多余的空闲线程才会被回收。回收前处于wait状态</span><br><span class="line"></span><br><span class="line">unit：时间单位，可以使用TimeUnit的实例，如TimeUnit.MILLISECONDS　</span><br><span class="line"></span><br><span class="line">workQueue:待入任务（Runnable）的等待场所，该参数主要影响调度策略，如公平与否，是否产生饿死(starving)</span><br><span class="line"></span><br><span class="line">threadFactory:线程工厂类，有默认实现，如果有自定义的需要则需要自己实现</span><br><span class="line">ThreadFactory接口并作为参数传入。</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jeff-eric.github.com/blog/blog/2019/10/22/git%E5%92%8Csvn%E5%8C%BA%E5%88%AB/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jeff-Eric"><meta itemprop="description" content=""><meta itemprop="image" content="/blog/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="纯天然绿色学渣"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/blog/2019/10/22/git%E5%92%8Csvn%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">git和svn的区别</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-22 18:51:56" itemprop="dateCreated datePublished" datetime="2019-10-22T18:51:56+08:00">2019-10-22</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-10-31 17:26:46" itemprop="dateModified" datetime="2019-10-31T17:26:46+08:00">2019-10-31</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/blog/2019/10/22/git%E5%92%8Csvn%E5%8C%BA%E5%88%AB/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/2019/10/22/git%E5%92%8Csvn%E5%8C%BA%E5%88%AB/" itemprop="commentCount"></span> </a></span><span id="/blog/2019/10/22/git%E5%92%8Csvn%E5%8C%BA%E5%88%AB/" class="leancloud_visitors" data-flag-title="git和svn的区别"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body han-init-context" itemprop="articleBody"><h1><a id="svn_1"></a>svn</h1><ul><li>在提交版本的时候，version1保存第一版，但是version2的时候保存的就是在前一个版本上的变化内容，如果没有变化就不会保存</li><li>如果svn的磁盘损坏了，那就导致push和pull的操作无法实现</li><li>svn实现的CVCS(centralized version control server) 集中式的版本控制</li></ul><h1><a id="git_7"></a>git</h1><ul><li>git的原作者是linux的开发者，而liunx是一个全球性的组织，很多人都会在push和pull代码</li><li>git实现的是DVCS(distributed version control server) 分布式的版本控制</li><li>version1保存第一版，但是version2的时候保存的是version1变化后的内容，如果没有变化那存储的是version1的指针引用</li><li>实现了去中心</li><li>每个操作者本地都存有该仓库所有版本迭代和操作数据<br>git的实现，类似区块链的存储、分布式账本等一些数据的存储</li></ul><h2><a id="merge_15"></a><a class="header-anchor" href="#merge">¶</a>merge</h2><p>对比代码的时候比较繁琐，因为有多个线路，但是保存的所有的数据<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191031170319.png" alt></p><h2><a id="rebase_19"></a><a class="header-anchor" href="#rebase">¶</a>rebase</h2><p>对比分支的是后会很清晰，因为只有一条线，但是部分分支数据就会丢失<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191031171130.png" alt></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jeff-eric.github.com/blog/blog/2019/10/22/spring%20-%20AOP/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jeff-Eric"><meta itemprop="description" content=""><meta itemprop="image" content="/blog/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="纯天然绿色学渣"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/blog/2019/10/22/spring%20-%20AOP/" class="post-title-link" itemprop="url">spring - AOP</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-22 18:51:56" itemprop="dateCreated datePublished" datetime="2019-10-22T18:51:56+08:00">2019-10-22</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-11-26 14:06:17" itemprop="dateModified" datetime="2019-11-26T14:06:17+08:00">2019-11-26</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/blog/2019/10/22/spring%20-%20AOP/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/2019/10/22/spring%20-%20AOP/" itemprop="commentCount"></span> </a></span><span id="/blog/2019/10/22/spring%20-%20AOP/" class="leancloud_visitors" data-flag-title="spring - AOP"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body han-init-context" itemprop="articleBody"><h1><a id="Spring_P_AOP___1"></a>Spring P AOP 设计原理及具体实践</h1><h2><a id="SpringAOP___2"></a><a class="header-anchor" href="#springaop-应用示例">¶</a>SpringAOP 应用示例</h2><p>AOP 是 OOP 的延续，是 Aspect Oriented Programming 的缩写，意思是面向切面编程。可以通过预编译方式和运行期动态代<br>理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。AOP 设计模式孜孜不倦追求的是调用者和被调用者之<br>间的解耦，AOP 可以说也是这种目标的一种实现。</p><p>我们现在做的一些非业务，如：日志、事务、安全等都会写在业务代码中(也即是说，这些非业务类横切于业务类)，但这些<br>代码往往是重复，复制——粘贴式的代码会给程序的维护带来不便，AOP 就实现了把这些业务需求与系统需求分开来做。这<br>种解决的方式也称代理机制。</p><p>先来了解一下 AOP 的相关概念</p><ul><li>切面（Aspect ）：官方的抽象定义为“一个关注点的模块化，这个关注点可能会横切多个对象”。“切面”在 ApplicationContext 中&lt;aop:aspect&gt;来配置。</li><li>连接点（ （Joinpoint ）：程序执行过程中的某一行为，例如，MemberService .get 的调用或者 MemberService .delete抛出异常等行为。</li><li>通知（Advice） ） ：“切面”对于某个“连接点”所产生的动作。其中，一个“切面”可以包含多个“Advice”。</li><li>切入点（ （Pointcut ） ：匹配连接点的断言，在 AOP 中通知和一个切入点表达式关联。切面中的所有通知所关注的连接点，都由切入点表达式来决定。</li><li>目标对象（Target Object） ） ：被一个或者多个切面所通知的对象。例如，AServcieImpl 和 BServiceImpl，当然在实际运行时，Spring AOP 采用代理实现，实际 AOP 操作的是 TargetObject 的代理对象。</li><li>AOP 理 代理（ （AOP Proxy ）：在 Spring AOP 中有两种代理方式，JDK 动态代理和 CGLIB 代理。默认情况下，TargetObject实现了接口时，则采用 JDK 动态代理，例如，AServiceImpl；反之，采用 CGLIB 代理，例如，BServiceImpl。强制使用 CGLIB 代理需要将 &lt;aop:config&gt;的 proxy-target-class 属性设为 true。</li></ul><p>通知（Advice ）类型：</p><ul><li>前置通知（Before advice ）：在某连接点（JoinPoint）之前执行的通知，但这个通知不能阻止连接点前的执行。ApplicationContext 中在&lt;aop:aspect&gt;里面使用&lt;aop:before&gt;元素进行声明。例如，TestAspect 中的 doBefore 方法。</li><li>后置通知（ （After advice） ）： ：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。ApplicationContext中在&lt;aop:aspect&gt;里面使用&lt;aop:after&gt;元素进行声明。例如，ServiceAspect 中的 returnAfter 方法，所以 Teser 中调用UserService.delete 抛出异常时，returnAfter 方法仍然执行。</li><li>返回后通知（ （After return advice） ）： ：在某连接点正常完成后执行的通知，不包括抛出异常的情况。ApplicationContext中在&lt;aop:aspect&gt;里面使用<after-returning>元素进行声明。</after-returning></li><li>环绕通知（ （Around advice） ）： ：包围一个连接点的通知，类似 Web 中 Servlet 规范中的 Filter 的 doFilter 方法。可以在方法的调用前后完成自定义的行为，也可以选择不执行。ApplicationContext 中在&lt;aop:aspect&gt;里面使用&lt;aop:around&gt;元素进行声明。例如，ServiceAspect 中的 around 方法。</li><li>抛出异常后通知（ （After throwing advice） ）： ：在方法抛出异常退出时执行的通知。ApplicationContext 中在&lt;aop:aspect&gt;里面使用&lt;aop:after-throwing&gt;元素进行声明。例如，ServiceAspect 中的 returnThrow 方法。</li></ul><p>可以将多个通知应用到一个目标对象上，即可以将多个切面织入到同一目标对象。</p><p>使用 Spring AOP 可以基于两种方式，一种是比较方便和强大的注解方式，另一种则是中规中矩的 xml 配置方式。<br>先说注解，使用注解配置 Spring AOP 总体分为两步，第一步是在 xml 文件中声明激活自动扫描组件功能，同时激活自动代理功能（来测试 AOP 的注解功能）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//声明这是一个组件</span><br><span class="line">@Component</span><br><span class="line">//声明这是一个切面Bean</span><br><span class="line">@Aspect</span><br><span class="line">public class AnnotaionAspect &#123;</span><br><span class="line">	private final static Logger log = Logger.getLogger(AnnotaionAspect.class);</span><br><span class="line">	//配置切入点,该方法无方法体,主要为方便同类中其他方法使用此处配置的切入点</span><br><span class="line">	@Pointcut(&quot;execution(* com.jphoebe.aop.service..*(..))&quot;)</span><br><span class="line">	public void aspect()&#123; &#125;</span><br><span class="line">	/*</span><br><span class="line">	 * 配置前置通知,使用在方法aspect()上注册的切入点</span><br><span class="line">	 * 同时接受JoinPoint切入点对象,可以没有该参数</span><br><span class="line">	 */</span><br><span class="line">	@Before(&quot;aspect()&quot;)</span><br><span class="line">	public void before(JoinPoint joinPoint)&#123;</span><br><span class="line">		log.info(&quot;before &quot; + joinPoint);</span><br><span class="line">	&#125;</span><br><span class="line">	//配置后置通知,使用在方法aspect()上注册的切入点</span><br><span class="line">	@After(&quot;aspect()&quot;)</span><br><span class="line">	public void after(JoinPoint joinPoint)&#123;</span><br><span class="line">		log.info(&quot;after &quot; + joinPoint);</span><br><span class="line">	&#125;</span><br><span class="line">	//配置环绕通知,使用在方法aspect()上注册的切入点</span><br><span class="line">	@Around(&quot;aspect()&quot;)</span><br><span class="line">	public void around(JoinPoint joinPoint)&#123;</span><br><span class="line">		long start = System.currentTimeMillis();</span><br><span class="line">		try &#123;</span><br><span class="line">			((ProceedingJoinPoint) joinPoint).proceed();</span><br><span class="line">			long end = System.currentTimeMillis();</span><br><span class="line">			log.info(&quot;around &quot; + joinPoint + &quot;\tUse time : &quot; + (end - start) + &quot; ms!&quot;);</span><br><span class="line">		&#125; catch (Throwable e) &#123;</span><br><span class="line">			long end = System.currentTimeMillis();</span><br><span class="line">			log.info(&quot;around &quot; + joinPoint + &quot;\tUse time : &quot; + (end - start) + &quot; ms with exception : &quot; +</span><br><span class="line">					e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//配置后置返回通知,使用在方法aspect()上注册的切入点</span><br><span class="line">	@AfterReturning(&quot;aspect()&quot;)</span><br><span class="line">	public void afterReturn(JoinPoint joinPoint)&#123;</span><br><span class="line">		log.info(&quot;afterReturn &quot; + joinPoint);</span><br><span class="line">	&#125;</span><br><span class="line">	//配置抛出异常后通知,使用在方法aspect()上注册的切入点</span><br><span class="line">	@AfterThrowing(pointcut=&quot;aspect()&quot;, throwing=&quot;ex&quot;)</span><br><span class="line">	public void afterThrow(JoinPoint joinPoint, Exception ex)&#123;</span><br><span class="line">		log.info(&quot;afterThrow &quot; + joinPoint + &quot;\t&quot; + ex.getMessage());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果可以看到，正如我们预期的那样，虽然我们并没有对 Service 类包括其调用方式做任何改变，但是 Spring 仍然拦截到了其中方法的调用，或许这正是 AOP 的魔力所在。</p><p>应该说学习 Spring AOP 有两个难点，第一点在于理解 AOP 的理念和相关概念，第二点在于灵活掌握和使用切入点表达式。<br>概念的理解通常不在一朝一夕，慢慢浸泡的时间长了，自然就明白了，下面我们简单地介绍一下切入点表达式的配置规则吧。</p><p>通常情况下，表达式中使用”execution“就可以满足大部分的要求。表达式格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?</span><br></pre></td></tr></table></figure><ul><li>modifiers-pattern：方法的操作权限</li><li>ret-type-pattern：返回值</li><li>declaring-type-pattern：方法所在的包</li><li>name-pattern：方法名</li><li>parm-pattern：参数名</li><li>throws-pattern：异常</li></ul><p>其中，除 ret-type-pattern 和 name-pattern 之外，其他都是可选的。上例中，execution(* com.spring.service.<code>*.*</code>(…))表示<br>com.spring.service 包下，返回值为任意类型；方法名任意；参数不作限制的所有方法。</p><p>每个通知方法第一个参数都是 JoinPoint。其实，在 Spring 中，任何通知（Advice）方法都可以将第一个参数定义为 org.aspectj.lang.JoinPoint 类型用以接受当前连接点对象。JoinPoint 接口提供了一系列有用的方法， 比如</p><ul><li>getArgs() （返回方法参数）</li><li>getThis() （返回代理对象）</li><li>getTarget() （返回目标）</li><li>getSignature() （返回正在被通知的方法相关信息） * toString() （打印出正在被通知的方法的有用信息）</li></ul><h1><a id="SpringAOP___54"></a>SpringAOP 设计原理及源码分析</h1><p>先看看 Spring 中主要的 AOP 组件<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191117161144.png" alt><br><img src="/blog/.com//20191126020541166.png" alt></p><p>Spring 提供了两种方式来生成代理对象: JDKProxy 和 Cglib，具体使用哪种方式生成由 AopProxyFactory 根据<br>AdvisedSupport 对象的配置来决定。默认的策略是如果目标类是接口，则使用 JDK 动态代理技术，否则使用 Cglib 来生成代理。下面我们来研究一下 Spring 如何使用 JDK 来生成代理对象，具体的生成代码放在JdkDynamicAopProxy 这个类中，直接上相关代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * &lt;ol&gt;</span><br><span class="line"> * &lt;li&gt;获取代理类要实现的接口,除了 Advised 对象中配置的,还会加上 SpringProxy, Advised(opaque=false)</span><br><span class="line"> * &lt;li&gt;检查上面得到的接口中有没有定义 equals 或者 hashcode 的接口</span><br><span class="line"> * &lt;li&gt;调用 Proxy.newProxyInstance 创建代理对象</span><br><span class="line"> * &lt;/ol&gt;</span><br><span class="line"> */</span><br><span class="line">public Object getProxy(ClassLoader classLoader) &#123;</span><br><span class="line">    if (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(&quot;Creating JDK dynamic proxy: target source is &quot; + this.advised.getTargetSource());</span><br><span class="line">    &#125;</span><br><span class="line">    Class[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised);</span><br><span class="line">    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">    return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那这个其实很明了，注释上我也已经写清楚了，不再赘述。</p><p>下面的问题是，代理对象生成了，那切面是如何织入的？</p><p>我们知道 InvocationHandler 是 JDK 动态代理的核心，生成的代理对象的方法调用都会委托到 InvocationHandler.invoke()<br>方法。而通过 JdkDynamicAopProxy 的签名我们可以看到这个类其实也实现了 InvocationHandler，下面我们就通过分析这个类中实现的 invoke()方法来具体看下 Spring AOP 是如何织入切面的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    MethodInvocation invocation;</span><br><span class="line">    Object oldProxy = null;</span><br><span class="line">    boolean setProxyContext = false;</span><br><span class="line"></span><br><span class="line">    TargetSource targetSource = this.advised.targetSource;</span><br><span class="line">    Class targetClass = null;</span><br><span class="line">    Object target = null;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        //eqauls()方法，具目标对象未实现此方法</span><br><span class="line">        if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">            // The target does not implement the equals(Object) method itself.</span><br><span class="line">            return equals(args[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        //hashCode()方法，具目标对象未实现此方法</span><br><span class="line">        if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">            // The target does not implement the hashCode() method itself.</span><br><span class="line">            return hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        //Advised 接口或者其父接口中定义的方法,直接反射调用,不应用通知</span><br><span class="line">        if (!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">                method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">            // Service invocations on ProxyConfig with the proxy config...</span><br><span class="line">            return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object retVal;</span><br><span class="line"></span><br><span class="line">        if (this.advised.exposeProxy) &#123;</span><br><span class="line">            // Make invocation available if necessary.</span><br><span class="line">            oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">            setProxyContext = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // May be null. Get as late as possible to minimize the time we &quot;own&quot; the target,</span><br><span class="line">        // in case it comes from a pool.</span><br><span class="line">        //获得目标对象的类</span><br><span class="line">        target = targetSource.getTarget();</span><br><span class="line">        if (target != null) &#123;</span><br><span class="line">            targetClass = target.getClass();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获取可以应用到此方法上的 Interceptor 列表</span><br><span class="line">        // Get the interception chain for this method.</span><br><span class="line">        List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">        // Check whether we have any advice. If we don&apos;t, we can fallback on direct</span><br><span class="line">        // reflective invocation of the target, and avoid creating a MethodInvocation.</span><br><span class="line">        //如果没有可以应用到此方法的通知(Interceptor)，此直接反射调用 method.invoke(target, args)</span><br><span class="line">        if (chain.isEmpty()) &#123;</span><br><span class="line">            // We can skip creating a MethodInvocation: just invoke the target directly</span><br><span class="line">            // Note that the final invoker must be an InvokerInterceptor so we know it does</span><br><span class="line">            // nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span><br><span class="line">            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, args);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // We need to create a method invocation...</span><br><span class="line">            //创建 MethodInvocation</span><br><span class="line">            invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">            // Proceed to the joinpoint through the interceptor chain.</span><br><span class="line">            retVal = invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Massage return value if necessary.</span><br><span class="line">        Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">        if (retVal != null &amp;&amp; retVal == target &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">                !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">            // Special case: it returned &quot;this&quot; and the return type of the method</span><br><span class="line">            // is type-compatible. Note that we can&apos;t help if the target sets</span><br><span class="line">            // a reference to itself in another returned object.</span><br><span class="line">            retVal = proxy;</span><br><span class="line">        &#125; else if (retVal == null &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">            throw new AopInvocationException(&quot;Null return value from advice does not match primitive return type for: &quot; + method);</span><br><span class="line">        &#125;</span><br><span class="line">        return retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        if (target != null &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">            // Must have come from TargetSource.</span><br><span class="line">            targetSource.releaseTarget(target);</span><br><span class="line">        &#125;</span><br><span class="line">        if (setProxyContext) &#123;</span><br><span class="line">            // Restore old proxy.</span><br><span class="line">            AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主流程可以简述为：获取可以应用到此方法上的通知链（Interceptor Chain）,如果有,则应用通知,并执行 joinpoint; 如<br>果没有,则直接反射执行 joinpoint。而这里的关键是通知链是如何获取的以及它又是如何执行的，下面逐一分析下。</p><p>首先，从上面的代码可以看到，通知链是通过 Advised.getInterceptorsAndDynamicInterceptionAdvice()这个方法来获取的,我们来看下这个方法的实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(Method method, Class targetClass) &#123;</span><br><span class="line">    MethodCacheKey cacheKey = new MethodCacheKey(method);</span><br><span class="line">    List&lt;Object&gt; cached = this.methodCache.get(cacheKey);</span><br><span class="line">    if (cached == null) &#123;</span><br><span class="line">        cached = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(</span><br><span class="line">                this, method, targetClass);</span><br><span class="line">        this.methodCache.put(cacheKey, cached);</span><br><span class="line">    &#125;</span><br><span class="line">    return cached;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到实际的获取工作其实是由 AdvisorChainFactory. getInterceptorsAndDynamicInterceptionAdvice()这个方法来完成的，获取到的结果会被缓存。</p><p>下面来分析下这个方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从提供的配置实例 config 中获取 advisor 列表,遍历处理这些 advisor.如果是 IntroductionAdvisor,</span><br><span class="line"> * 则判断此 Advisor 能否应用到目标类 targetClass 上.如果是 PointcutAdvisor,则判断</span><br><span class="line"> * 此 Advisor 能否应用到目标方法 method 上.将满足条件的 Advisor 通过 AdvisorAdaptor 转化成 Interceptor</span><br><span class="line"> 列表返回.</span><br><span class="line"> */</span><br><span class="line">public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(</span><br><span class="line">        Advised config, Method method, Class targetClass) &#123;</span><br><span class="line"></span><br><span class="line">    // This is somewhat tricky... we have to process introductions first,</span><br><span class="line">    // but we need to preserve order in the ultimate list.</span><br><span class="line">    List&lt;Object&gt; interceptorList = new ArrayList&lt;Object&gt;(config.getAdvisors().length);</span><br><span class="line">    //查看是否包含 IntroductionAdvisor</span><br><span class="line">    boolean hasIntroductions = hasMatchingIntroductions(config, targetClass);</span><br><span class="line">    //这里实际上注册一系列 AdvisorAdapter,用于将 Advisor 转化成 MethodInterceptor</span><br><span class="line">    AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line">    for (Advisor advisor : config.getAdvisors()) &#123;</span><br><span class="line">        if (advisor instanceof PointcutAdvisor) &#123;</span><br><span class="line">            // Add it conditionally.</span><br><span class="line">            PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;</span><br><span class="line">            if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">                //这个地方这两个方法的位置可以互换下</span><br><span class="line">                //将 Advisor 转化成 Interceptor</span><br><span class="line">                MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">                //检查当前 advisor 的 pointcut 是否可以匹配当前方法</span><br><span class="line">                MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();</span><br><span class="line">                if (MethodMatchers.matches(mm, method, targetClass, hasIntroductions)) &#123;</span><br><span class="line">                    if (mm.isRuntime()) &#123;</span><br><span class="line">                        // Creating a new object instance in the getInterceptors() method</span><br><span class="line">                        // isn&apos;t a problem as we normally cache created chains.</span><br><span class="line">                        for (MethodInterceptor interceptor : interceptors) &#123;</span><br><span class="line">                            interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (advisor instanceof IntroductionAdvisor) &#123;</span><br><span class="line">            IntroductionAdvisor ia = (IntroductionAdvisor) advisor;</span><br><span class="line">            if (config.isPreFiltered() || ia.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">                Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">                interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">            interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return interceptorList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法执行完成后，Advised 中配置能够应用到连接点或者目标类的 Advisor 全部被转化成了 MethodInterceptor.接下来我们再看下得到的拦截器链是怎么起作用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">//如果没有可以应用到此方法的通知(Interceptor)，此直接反射调用 method.invoke(target, args)</span><br><span class="line">if (chain.isEmpty()) &#123;</span><br><span class="line">    // We can skip creating a MethodInvocation: just invoke the target directly</span><br><span class="line">    // Note that the final invoker must be an InvokerInterceptor so we know it does</span><br><span class="line">    // nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span><br><span class="line">    retVal = AopUtils.invokeJoinpointUsingReflection(target, method, args);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    // We need to create a method invocation...</span><br><span class="line">    //创建 MethodInvocation</span><br><span class="line">    invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">    // Proceed to the joinpoint through the interceptor chain.</span><br><span class="line">    retVal = invocation.proceed();</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>从这段代码可以看出，如果得到的拦截器链为空，则直接反射调用目标方法，否则创建 MethodInvocation，调用其 proceed方法，触发拦截器链的执行，来看下具体代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public Object proceed() throws Throwable &#123;</span><br><span class="line">    //	We start with an index of -1 and increment early.</span><br><span class="line">    //如果 Interceptor 执行完了，则执行 joinPoint</span><br><span class="line">    if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123;</span><br><span class="line">        return invokeJoinpoint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object interceptorOrInterceptionAdvice =</span><br><span class="line">            this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);</span><br><span class="line">    //如果要动态匹配 joinPoint</span><br><span class="line">    if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">        // Evaluate dynamic method matcher here: static part will already have</span><br><span class="line">        // been evaluated and found to match.</span><br><span class="line">        InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">                (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">        //动态匹配：运行时参数是否满足匹配条件</span><br><span class="line">        if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) &#123;</span><br><span class="line">            //执行当前 Intercetpor</span><br><span class="line">            return dm.interceptor.invoke(this);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // Dynamic matching failed.</span><br><span class="line">            // Skip this interceptor and invoke the next in the chain.</span><br><span class="line">            //动态匹配失败时,略过当前 Intercetpor,调用下一个 Interceptor</span><br><span class="line">            return proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // It&apos;s an interceptor, so we just invoke it: The pointcut will have</span><br><span class="line">        // been evaluated statically before this object was constructed.</span><br><span class="line">        //执行当前 Intercetpor</span><br><span class="line">        return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><a id="Spring_C_JDBC___86"></a>Spring C JDBC 设计原理及二次开发</h1></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article></section><nav class="pagination"><span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/5/">5</a><a class="extend next" rel="next" href="/blog/page/2/">&lt;i class=&quot;fa fa-angle-right&quot; aria-label=&quot;下一页&quot;&gt;&lt;&#x2F;i&gt;</a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><div class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/blog/uploads/avatar.jpg" alt="Jeff-Eric"><p class="site-author-name" itemprop="name">Jeff-Eric</p><div class="site-description motion-element" itemprop="description"></div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/blog/archives/%20%7C%7C%20archive"><span class="site-state-item-count">42</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/blog/categories/%20%7C%7C%20th"><span class="site-state-item-count">12</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/blog/tags/%20%7C%7C%20tags"><span class="site-state-item-count">28</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/jeff-eric" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;jeff-eric" rel="noopener" target="_blank">&lt;i class=&quot;fa fa-fw fa-github&quot;&gt;&lt;&#x2F;i&gt;GitHub</a> </span><span class="links-of-author-item"><a href="/blog/jphoebe4086824@gmail.com" title="E-Mail &amp;rarr; jphoebe4086824@gmail.com">&lt;i class=&quot;fa fa-fw fa-envelope&quot;&gt;&lt;&#x2F;i&gt;E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank">&lt;img src=&quot;&#x2F;blog&#x2F;images&#x2F;cc-by-nc-sa.svg&quot; alt=&quot;Creative Commons&quot;&#x2F;&gt;</a></div></div></div><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Jeff-Eric</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0</div><span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.0.1</div></div></footer><div id="needsharebutton-float"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script><script id="ribbon" size="300" alpha="0.6" zindex="-1" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@2/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/npm/fastclick@1/lib/fastclick.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery-lazyload@1/jquery.lazyload.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three-waves.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_lines.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_sphere.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-reading-progress@1/reading_progress.min.js"></script><script src="/blog/js/src/utils.js?v=7.0.1"></script><script src="/blog/js/src/motion.js?v=7.0.1"></script><script src="/blog/js/src/affix.js?v=7.0.1"></script><script src="/blog/js/src/schemes/pisces.js?v=7.0.1"></script><script src="/blog/js/src/next-boot.js?v=7.0.1"></script><script src="/blog/js/src/js.cookie.js?v=7.0.1"></script><script src="/blog/js/src/scroll-cookie.js?v=7.0.1"></script><script src="//cdn.jsdelivr.net/npm/quicklink@1.0.0/dist/quicklink.umd.js"></script><script>window.addEventListener('load', () => {
      
        quicklink({
          timeout: 3000,
          priority: true,
          ignores: [uri => uri.includes('#'),uri => uri == 'https://jeff-eric.github.com/blog/',]
        });
      
        });</script><script src="//cdn.jsdelivr.net/npm/leancloud-storage@3/dist/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js"></script><script>var GUEST=["nick","mail","link"],guest="nick,mail,link";guest=guest.split(",").filter(function(e){return GUEST.indexOf(e)>-1}),new Valine({el:"#comments",verify:!0,notify:!1,appId:"MKGyMx7EafphCr9hAbMPAwAc-gzGzoHsz",appKey:"4SB8MPoE51bFPHDoKtPM8vLG",placeholder:"Just go go",avatar:"mm",meta:guest,pageSize:"10",visitor:!0})</script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var e=$("#local-search-input");e.attr("autocapitalize","none"),e.attr("autocorrect","off"),e.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/blog/"+search_path,onPopupClose=function(e){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(e,t,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:e,dataType:isXml?"xml":"json",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,r=document.getElementById(t),s=document.getElementById(o),a=function(){var e=r.value.trim().toLowerCase(),t=e.split(/[\s\-]+/);t.length>1&&t.push(e);var o=[];if(e.length>0&&n.forEach(function(n){function r(t,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===e&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(e,t){var o="",n=t.start;return t.hits.forEach(function(t){o+=e.substring(n,t.position);var r=t.position+t.length;o+='<b class="search-keyword">'+e.substring(t.position,r)+"</b>",n=r}),o+=e.substring(n,t.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url).replace(/\/{2,}/g,"/"),d=[],g=[];if(""!=l&&(t.forEach(function(e){function t(e,t,o){var n=e.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(t=t.toLowerCase(),e=e.toLowerCase());(s=t.indexOf(e,r))>-1;)a.push({position:s,word:e}),r=s+n;return a}d=d.concat(t(e,h,!1)),g=g.concat(t(e,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(e){e.sort(function(e,t){return t.position!==e.position?t.position-e.position:e.word.length-t.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hits.length!==t.hits.length?t.hits.length-e.hits.length:e.start-t.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(e){b+="<a href='"+f+'\'><p class="search-result">'+s(p,e)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===t.length&&""===t[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x"></i></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>';else{o.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hitCount!==t.hitCount?t.hitCount-e.hitCount:t.id-e.id});var a='<ul class="search-result-list">';o.forEach(function(e){a+=e.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(e){e.stopPropagation()}),$(document).on("keyup",function(e){var t=27===e.which&&$(".search-popup").is(":visible");t&&onPopupClose()})</script><script src="https://www.gstatic.com/firebasejs/4.6.0/firebase.js"></script><script src="https://www.gstatic.com/firebasejs/4.6.0/firebase-firestore.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/bluebird/3.5.1/bluebird.core.min.js"></script><script>!function(){function getCount(t,e){return t.get().then(function(s){var i;return s.exists?(i=s.data().count,e&&(window.localStorage&&window.localStorage.getItem(title)||(t.set({count:i+1}),i++))):e?(t.set({count:1}),i=1):i=0,window.localStorage&&e&&localStorage.setItem(title,!0),i})}function appendCountTo(t){return function(e){$(t).append($("<span>").addClass("post-visitors-count").append($("<span>").addClass("post-meta-divider").text("|")).append($("<span>").addClass("post-meta-item-icon").append($("<i>").addClass("fa fa-users"))).append($("<span>").text("阅读次数 "+e)))}}firebase.initializeApp({apiKey:"AIzaSyD-BIMnFQcvrv1utthoP5z5shcYP8JMKmY",projectId:"blog-6cbe0"});var db=firebase.firestore(),articles=db.collection("articles"),isPost="".length>0,isArchive=!1,isCategory="".length>0,isTag="".length>0;if(isPost){var title="",doc=articles.doc(title);getCount(doc,!0).then(appendCountTo($(".post-meta")))}else if(!isArchive&&!isCategory&&!isTag){var titles=[],postsstr='titles.push("AbstractQueuedSynchronizer 原理分析 - 独占/共享模式");titles.push("AbstractQueuedSynchronizer 原理分析 - 独占模式");titles.push("spring - IOC");titles.push("fq软件安装");titles.push("spring - IOC高级特性");titles.push("软件架构设计的七大原则");titles.push("常用的设计模式");titles.push("线程");titles.push("git和svn的区别");titles.push("spring - AOP");';eval(postsstr);var promises=titles.map(function(t){return articles.doc(t)}).map(function(t){return getCount(t)});Promise.all(promises).then(function(t){var e=$(".post-meta");t.forEach(function(t,s){appendCountTo(e[s])(t)})})}}()</script><style>.pdfobject-container{position:relative;overflow:auto;width:100%}</style><script>$("body").find("div.pdf").length&&$.ajax({type:"GET",url:"//cdn.jsdelivr.net/npm/pdfobject@2.1.1/pdfobject.min.js",dataType:"script",cache:!0,success:function(){$("body").find("div.pdf").each(function(e,t){PDFObject.embed($(t).attr("target"),$(t),{pdfOpenParams:{navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"},PDFJS_URL:"/lib/pdf/web/viewer.html",height:$(t).attr("height")||"500px"})})}})</script><script>$("body").find("pre.mermaid").length&&$.ajax({type:"GET",url:"//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js",dataType:"script",cache:!0,success:function(){mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})}})</script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script><script>pbOptions={},pbOptions.iconStyle="box",pbOptions.boxForm="horizontal",pbOptions.position="bottomCenter",pbOptions.networks="Weibo,Wechat,Douban,QQZone,Twitter,Facebook",new needShareButton("#needsharebutton-postbottom",pbOptions),flOptions={},flOptions.iconStyle="box",flOptions.boxForm="horizontal",flOptions.position="middleRight",flOptions.networks="Weibo,Wechat,Douban,QQZone,Twitter,Facebook",new needShareButton("#needsharebutton-float",flOptions)</script><script src="//cdn.jsdelivr.net/npm/pangu@3/dist/browser/pangu.min.js"></script><script>pangu.spacingPage()</script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@1/bookmark.min.js"></script><script>bookmark.loadBookmark()</script><style>.copy-btn{display:inline-block;padding:6px 12px;font-size:13px;font-weight:700;line-height:20px;color:#333;white-space:nowrap;vertical-align:middle;cursor:pointer;background-color:#eee;background-image:linear-gradient(#fcfcfc,#eee);border:1px solid #d5d5d5;border-radius:3px;user-select:none;outline:0}.highlight-wrap .copy-btn{transition:opacity .3s ease-in-out;opacity:0;padding:2px 6px;position:absolute;right:4px;top:8px}.highlight-wrap .copy-btn:focus,.highlight-wrap:hover .copy-btn{opacity:1}.highlight-wrap{position:relative}</style><script>$(".highlight").each(function(t,e){var n=$("<div>").addClass("highlight-wrap");$(e).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(t){var e=$(this).parent().find(".code").find(".line").map(function(t,e){return $(e).text()}).toArray().join("\n"),n=document.createElement("textarea"),o=window.pageYOffset||document.documentElement.scrollTop;n.style.top=o+"px",n.style.position="absolute",n.style.opacity="0",n.readOnly=!0,n.value=e,document.body.appendChild(n),n.select(),n.setSelectionRange(0,e.length),n.readOnly=!1;var a=document.execCommand("copy");a?$(this).text("复制成功"):$(this).text("复制失败"),n.blur(),$(this).blur()})).on("mouseleave",function(t){var e=$(this).find(".copy-btn");setTimeout(function(){e.text("复制")},300)}).append(e)})</script></body></html><!-- rebuild by neat -->