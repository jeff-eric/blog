<!-- build time:Tue Nov 26 2019 14:32:21 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-CN,zh-HK,zh-TW,en,default"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/han-css@3/dist/han.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css"><link rel="stylesheet" href="/blog/css/main.css?v=7.0.1"><link rel="apple-touch-icon" sizes="180x180" href="/blog/uploads/avatar.jpg?v=7.0.1"><link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/avatar.jpg?v=7.0.1"><link rel="icon" type="image/png" sizes="16x16" href="/blog/blog/uploads/avatar.jpg?v=7.0.1"><link rel="mask-icon" href="/blog/uploads/avatar.jpg?v=7.0.1" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/blog/",scheme:"Gemini",version:"7.0.1",sidebar:{position:"left",display:"always",offset:12,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!0,fancybox:!0,fastclick:!0,lazyload:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="AQS 结构先来看看 AQS 有哪些属性，搞清楚这些基本就知道 AQS 是什么套路了1234567891011121314&#x2F;&#x2F; 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的private transient volatile Node head;&#x2F;&#x2F; 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表private transient volatile Node tai"><meta name="keywords" content="线程"><meta property="og:type" content="article"><meta property="og:title" content="AbstractQueuedSynchronizer 原理分析 - 独占模式"><meta property="og:url" content="https:&#x2F;&#x2F;jeff-eric.github.com&#x2F;blog&#x2F;2019&#x2F;10&#x2F;24&#x2F;AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F&#x2F;index.html"><meta property="og:site_name" content="纯天然绿色学渣"><meta property="og:description" content="AQS 结构先来看看 AQS 有哪些属性，搞清楚这些基本就知道 AQS 是什么套路了1234567891011121314&#x2F;&#x2F; 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的private transient volatile Node head;&#x2F;&#x2F; 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表private transient volatile Node tai"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191025190929.png"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191025191212.png"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191025192734.png"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191025192751.png"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191025192812.png"><meta property="og:updated_time" content="2019-10-25T11:48:56.818Z"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191025190929.png"><link rel="canonical" href="https://jeff-eric.github.com/blog/2019/10/24/AbstractQueuedSynchronizer-原理分析---独占模式/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>AbstractQueuedSynchronizer 原理分析 - 独占模式 | 纯天然绿色学渣</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?bb5d4f8207d7c2bd1aa936180430bbaa";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/blog/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">纯天然绿色学渣</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-home&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;首页</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-tags&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;标签&lt;span class=&quot;badge&quot;&gt;28&lt;&#x2F;span&gt;</a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-th&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;分类&lt;span class=&quot;badge&quot;&gt;12&lt;&#x2F;span&gt;</a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-archive&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;归档&lt;span class=&quot;badge&quot;&gt;42&lt;&#x2F;span&gt;</a></li><li class="menu-item menu-item-tools"><a href="/blog/tools/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-tree&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;工具</a></li><li class="menu-item menu-item-search"><a href="javascript:;" target="_blank" rel="noopener" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><div class="reading-progress-bar"></div><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jeff-eric.github.com/blog/blog/2019/10/24/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jeff-Eric"><meta itemprop="description" content=""><meta itemprop="image" content="/blog/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="纯天然绿色学渣"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">AbstractQueuedSynchronizer 原理分析 - 独占模式</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-24 14:13:00" itemprop="dateCreated datePublished" datetime="2019-10-24T14:13:00+08:00">2019-10-24</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-10-25 19:48:56" itemprop="dateModified" datetime="2019-10-25T19:48:56+08:00">2019-10-25</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/blog/2019/10/24/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/2019/10/24/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F/" itemprop="commentCount"></span> </a></span><span id="/blog/2019/10/24/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F/" class="leancloud_visitors" data-flag-title="AbstractQueuedSynchronizer 原理分析 - 独占模式"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body han-init-context" itemprop="articleBody"><h1><a id="AQS__1"></a>AQS 结构</h1><p>先来看看 AQS 有哪些属性，搞清楚这些基本就知道 AQS 是什么套路了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的</span><br><span class="line">private transient volatile Node head;</span><br><span class="line"></span><br><span class="line">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span><br><span class="line">private transient volatile Node tail;</span><br><span class="line"></span><br><span class="line">// 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁</span><br><span class="line">// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1</span><br><span class="line">private volatile int state;</span><br><span class="line"></span><br><span class="line">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span><br><span class="line">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span><br><span class="line">// if (currentThread == getExclusiveOwnerThread()) &#123;state++&#125;</span><br><span class="line">private transient Thread exclusiveOwnerThread; //继承自AbstractOwnableSynchronizer</span><br></pre></td></tr></table></figure><p>AbstractQueuedSynchronizer 的等待队列示意如下所示，注意了，之后分析过程中所说的 queue，也就是阻塞队列<br>不包含 head ！！！<br>不包含 head ！！！<br>不包含 head ！！！<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191025190929.png" alt></p><p>等待队列中每个线程被包装成一个 Node 实例，数据结构是链表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line">    // 标识节点当前在共享模式下</span><br><span class="line">    static final Node SHARED = new Node();</span><br><span class="line">    // 标识节点当前在独占模式下</span><br><span class="line">    static final Node EXCLUSIVE = null;</span><br><span class="line"></span><br><span class="line">    // ======== 下面的几个int常量是给waitStatus用的 ===========</span><br><span class="line">    /** waitStatus value to indicate thread has cancelled */</span><br><span class="line">    // 代码此线程取消了争抢这个锁</span><br><span class="line">    static final int CANCELLED =  1;</span><br><span class="line">    /** waitStatus value to indicate successor&apos;s thread needs unparking */</span><br><span class="line">    // 官方的描述是，其表示当前node的后继节点对应的线程需要被唤醒</span><br><span class="line">    static final int SIGNAL    = -1;</span><br><span class="line">    /** waitStatus value to indicate thread is waiting on condition */</span><br><span class="line">    // 本文不分析condition，所以略过吧，下一篇文章会介绍这个</span><br><span class="line">    static final int CONDITION = -2;</span><br><span class="line">    /**</span><br><span class="line">     * waitStatus value to indicate the next acquireShared should</span><br><span class="line">     * unconditionally propagate</span><br><span class="line">     */</span><br><span class="line">    // 同样的不分析，略过吧</span><br><span class="line">    static final int PROPAGATE = -3;</span><br><span class="line">    // =====================================================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 取值为上面的1、-1、-2、-3，或者0(以后会讲到)</span><br><span class="line">    // 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待，</span><br><span class="line">    //    ps: 半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的。。。</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line">    // 前驱节点的引用</span><br><span class="line">    volatile Node prev;</span><br><span class="line">    // 后继节点的引用</span><br><span class="line">    volatile Node next;</span><br><span class="line">    // 这个就是线程本尊</span><br><span class="line">    volatile Thread thread;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node 的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已，大家先要有这个概念在心里。<br>上面的是基础知识，后面会多次用到，心里要时刻记着它们，心里想着这个结构图就可以了。下面，我们开始说 ReentrantLock 的公平锁。再次强调，我说的阻塞队列不包含 head 节点。<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191025191212.png" alt></p><p>首先，我们先看下 ReentrantLock 的使用方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 我用个web开发中的service概念吧</span><br><span class="line">public class OrderService &#123;</span><br><span class="line">    // 使用static，这样每个线程拿到的是同一把锁，当然，spring mvc中service默认就是单例，别纠结这个</span><br><span class="line">    private static ReentrantLock reentrantLock = new ReentrantLock(true);</span><br><span class="line"></span><br><span class="line">    public void createOrder() &#123;</span><br><span class="line">        // 比如我们同一时间，只允许一个线程创建订单</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        // 通常，lock 之后紧跟着 try 语句</span><br><span class="line">        try &#123;</span><br><span class="line">            // 这块代码同一时间只能有一个线程进来(获取到锁的线程)，</span><br><span class="line">            // 其他的线程在lock()方法上阻塞，等待获取到锁，再进来</span><br><span class="line">            // 执行代码...</span><br><span class="line">            // 执行代码...</span><br><span class="line">            // 执行代码...</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 释放锁</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock 在内部用了内部类 Sync 来管理锁，所以真正的获取锁和释放锁是由 Sync 的实现类来控制的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sync 有两个实现，分别为 NonfairSync（非公平锁）和 FairSync（公平锁），我们看 FairSync 部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><a id="_25"></a>线程强锁</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID = -3000897897090466540L;</span><br><span class="line">      // 争锁</span><br><span class="line">    final void lock() &#123;</span><br><span class="line">        acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line">      // 来自父类AQS，我直接贴过来这边，下面分析的时候同样会这样做，不会给读者带来阅读压力</span><br><span class="line">    // 我们看到，这个方法，如果tryAcquire(arg) 返回true, 也就结束了。</span><br><span class="line">    // 否则，acquireQueued方法会将线程压到队列中</span><br><span class="line">    public final void acquire(int arg) &#123; // 此时 arg == 1</span><br><span class="line">        // 首先调用tryAcquire(1)一下，名字上就知道，这个只是试一试</span><br><span class="line">        // 因为有可能直接就成功了呢，也就不需要进队列排队了，</span><br><span class="line">        // 对于公平锁的语义就是：本来就没人持有锁，根本没必要进队列等待(又是挂起，又是等待被唤醒的)</span><br><span class="line">        if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            // tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;</span><br><span class="line">              selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Fair version of tryAcquire.  Don&apos;t grant access unless</span><br><span class="line">     * recursive call or no waiters or is first.</span><br><span class="line">     */</span><br><span class="line">    // 尝试直接获取锁，返回值是boolean，代表是否获取到锁</span><br><span class="line">    // 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取</span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        final Thread current = Thread.currentThread();</span><br><span class="line">        int c = getState();</span><br><span class="line">        // state == 0 此时此刻没有线程持有锁</span><br><span class="line">        if (c == 0) &#123;</span><br><span class="line">            // 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span><br><span class="line">            // 看看有没有别人在队列中等了半天了</span><br><span class="line">            if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                // 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span><br><span class="line">                // 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=</span><br><span class="line">                // 因为刚刚还没人的，我判断过了</span><br><span class="line">                compareAndSetState(0, acquires)) &#123;</span><br><span class="line"></span><br><span class="line">                // 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          // 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span><br><span class="line">        // 这里不存在并发问题</span><br><span class="line">        else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            int nextc = c + acquires;</span><br><span class="line">            if (nextc &lt; 0)</span><br><span class="line">                throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁</span><br><span class="line">        // 回到上面一个外层调用方法继续看:</span><br><span class="line">        // if (!tryAcquire(arg) </span><br><span class="line">        //        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span><br><span class="line">        //     selfInterrupt();</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 假设tryAcquire(arg) 返回false，那么代码将执行：</span><br><span class="line">      //        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，</span><br><span class="line">    // 这个方法，首先需要执行：addWaiter(Node.EXCLUSIVE)</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates and enqueues node for current thread and given mode.</span><br><span class="line">     *</span><br><span class="line">     * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span><br><span class="line">     * @return the new node</span><br><span class="line">     */</span><br><span class="line">    // 此方法的作用是把线程包装成node，同时进入到队列中</span><br><span class="line">    // 参数mode此时是Node.EXCLUSIVE，代表独占模式</span><br><span class="line">    private Node addWaiter(Node mode) &#123;</span><br><span class="line">        Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">        // Try the fast path of enq; backup to full enq on failure</span><br><span class="line">        // 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后</span><br><span class="line">        Node pred = tail;</span><br><span class="line"></span><br><span class="line">        // tail!=null =&gt; 队列不为空(tail==head的时候，其实队列是空的，不过不管这个吧)</span><br><span class="line">        if (pred != null) &#123; </span><br><span class="line">            // 将当前的队尾节点，设置为自己的前驱 </span><br><span class="line">            node.prev = pred; </span><br><span class="line">            // 用CAS把自己设置为队尾, 如果成功后，tail == node 了，这个节点成为阻塞队列新的尾巴</span><br><span class="line">            if (compareAndSetTail(pred, node)) &#123; </span><br><span class="line">                // 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，</span><br><span class="line">                // 上面已经有 node.prev = pred，加上下面这句，也就实现了和之前的尾节点双向连接了</span><br><span class="line">                pred.next = node;</span><br><span class="line">                // 线程入队了，可以返回了</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 仔细看看上面的代码，如果会到这里，</span><br><span class="line">        // 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)</span><br><span class="line">        // 读者一定要跟上思路，如果没有跟上，建议先不要往下读了，往回仔细看，否则会浪费时间的</span><br><span class="line">        enq(node);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Inserts node into queue, initializing if necessary. See picture above.</span><br><span class="line">     * @param node the node to insert</span><br><span class="line">     * @return node&apos;s predecessor</span><br><span class="line">     */</span><br><span class="line">    // 采用自旋的方式入队</span><br><span class="line">    // 之前说过，到这个方法只有两种可能：等待队列为空，或者有线程竞争入队，</span><br><span class="line">    // 自旋在这边的语义是：CAS设置tail过程中，竞争一次竞争不到，我就多次竞争，总会排到的</span><br><span class="line">    private Node enq(final Node node) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            // 之前说过，队列为空也会进来这里</span><br><span class="line">            if (t == null) &#123; // Must initialize</span><br><span class="line">                // 初始化head节点</span><br><span class="line">                // 细心的读者会知道原来 head 和 tail 初始化的时候都是 null 的</span><br><span class="line">                // 还是一步CAS，你懂的，现在可能是很多线程同时进来呢</span><br><span class="line">                if (compareAndSetHead(new Node()))</span><br><span class="line">                    // 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了</span><br><span class="line"></span><br><span class="line">                    // 这个时候有了head，但是tail还是null，设置一下，</span><br><span class="line">                    // 把tail指向head，放心，马上就有线程要来了，到时候tail就要被抢了</span><br><span class="line">                    // 注意：这里只是设置了tail=head，这里可没return哦，没有return，没有return</span><br><span class="line">                    // 所以，设置完了以后，继续for循环，下次就到下面的else分支了</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 下面几行，和上一个方法 addWaiter 是一样的，</span><br><span class="line">                // 只是这个套在无限循环里，反正就是将当前线程排到队尾，有线程竞争的话排不上重复排</span><br><span class="line">                node.prev = t;</span><br><span class="line">                if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    return t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 现在，又回到这段代码了</span><br><span class="line">    // if (!tryAcquire(arg) </span><br><span class="line">    //        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span><br><span class="line">    //     selfInterrupt();</span><br><span class="line"></span><br><span class="line">    // 下面这个方法，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列</span><br><span class="line">    // 注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，</span><br><span class="line">    // 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false</span><br><span class="line">    // 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了</span><br><span class="line">    final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">        boolean failed = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean interrupted = false;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                final Node p = node.predecessor();</span><br><span class="line">                // p == head 说明当前节点虽然进到了阻塞队列，但是是阻塞队列的第一个，因为它的前驱是head</span><br><span class="line">                // 注意，阻塞队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为阻塞队列</span><br><span class="line">                // 所以当前节点可以去试抢一下锁</span><br><span class="line">                // 这里我们说一下，为什么可以去试试：</span><br><span class="line">                // 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，</span><br><span class="line">                // enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程</span><br><span class="line">                // 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，</span><br><span class="line">                // tryAcquire已经分析过了, 忘记了请往前看一下，就是简单用CAS试操作一下state</span><br><span class="line">                if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                // 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，</span><br><span class="line">                // 要么就是tryAcquire(arg)没有抢赢别人，继续往下看</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 什么时候 failed 会为 true???</span><br><span class="line">            // tryAcquire() 方法抛异常的情况</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Checks and updates status for a node that failed to acquire.</span><br><span class="line">     * Returns true if thread should block. This is the main signal</span><br><span class="line">     * control in all acquire loops.  Requires that pred == node.prev</span><br><span class="line">     *</span><br><span class="line">     * @param pred node&apos;s predecessor holding status</span><br><span class="line">     * @param node the node</span><br><span class="line">     * @return &#123;@code true&#125; if thread should block</span><br><span class="line">     */</span><br><span class="line">    // 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是：&quot;当前线程没有抢到锁，是否需要挂起当前线程？&quot;</span><br><span class="line">    // 第一个参数是前驱节点，第二个参数才是代表当前线程的节点</span><br><span class="line">    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">        int ws = pred.waitStatus;</span><br><span class="line">        // 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span><br><span class="line">        if (ws == Node.SIGNAL)</span><br><span class="line">            /*</span><br><span class="line">             * This node has already set status asking a release</span><br><span class="line">             * to signal it, so it can safely park.</span><br><span class="line">             */</span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        // 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。</span><br><span class="line">        // 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。</span><br><span class="line">        // 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，</span><br><span class="line">        // 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，</span><br><span class="line">        // 找前驱节点的前驱节点做爹，往前遍历总能找到一个好爹的</span><br><span class="line">        if (ws &gt; 0) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">             * indicate retry.</span><br><span class="line">             */</span><br><span class="line">            do &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /*</span><br><span class="line">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">             * need a signal, but don&apos;t park yet.  Caller will need to</span><br><span class="line">             * retry to make sure it cannot acquire before parking.</span><br><span class="line">             */</span><br><span class="line">            // 仔细想想，如果进入到这个分支意味着什么</span><br><span class="line">            // 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3</span><br><span class="line">            // 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0</span><br><span class="line">            // 正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0</span><br><span class="line">            // 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)</span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        // 这个方法返回 false，那么会再走一次 for 循序，</span><br><span class="line">        //     然后再次进来此方法，此时会从第一个分支返回 true</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // private static boolean shouldParkAfterFailedAcquire(Node pred, Node node)</span><br><span class="line">    // 这个方法结束根据返回值我们简单分析下：</span><br><span class="line">    // 如果返回true, 说明前驱节点的waitStatus==-1，是正常情况，那么当前线程需要被挂起，等待以后被唤醒</span><br><span class="line">    //        我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了</span><br><span class="line">    // 如果返回false, 说明当前不需要被挂起，为什么呢？往后看</span><br><span class="line"></span><br><span class="line">    // 跳回到前面是这个方法</span><br><span class="line">    // if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    //                parkAndCheckInterrupt())</span><br><span class="line">    //                interrupted = true;</span><br><span class="line"></span><br><span class="line">    // 1. 如果shouldParkAfterFailedAcquire(p, node)返回true，</span><br><span class="line">    // 那么需要执行parkAndCheckInterrupt():</span><br><span class="line"></span><br><span class="line">    // 这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的</span><br><span class="line">    // 这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒=======</span><br><span class="line">    private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        return Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2. 接下来说说如果shouldParkAfterFailedAcquire(p, node)返回false的情况</span><br><span class="line"></span><br><span class="line">   // 仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的，原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。</span><br><span class="line"></span><br><span class="line">    // 解释下为什么shouldParkAfterFailedAcquire(p, node)返回false的时候不直接挂起线程：</span><br><span class="line">    // =&gt; 是为了应对在经过这个方法后，node已经是head的直接后继节点了。剩下的读者自己想想吧。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说到这里，也就明白了，多看几遍 final boolean acquireQueued(final Node node, int arg) 这个方法吧。自己推演下各个分支怎么走，哪种情况下会发生什么，走到哪里。</p><h1><a id="_29"></a>解锁操作</h1><p>最后，就是还需要介绍下唤醒的动作了。我们知道，正常情况下，如果线程没获取到锁，线程会被 LockSupport.park(this); 挂起停止，等待被唤醒。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// 唤醒的代码还是比较简单的，你如果上面加锁的都看懂了，下面都不需要看就知道怎么回事了</span><br><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    // 往后看吧</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 回到ReentrantLock看tryRelease方法</span><br><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    int c = getState() - releases;</span><br><span class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    // 是否完全释放锁</span><br><span class="line">    boolean free = false;</span><br><span class="line">    // 其实就是重入的问题，如果c==0，也就是说没有嵌套锁了，可以释放了，否则还不能释放掉</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        free = true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Wakes up node&apos;s successor, if one exists.</span><br><span class="line"> *</span><br><span class="line"> * @param node the node</span><br><span class="line"> */</span><br><span class="line">// 唤醒后继节点</span><br><span class="line">// 从上面调用处知道，参数node是head头结点</span><br><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    /*</span><br><span class="line">     * If status is negative (i.e., possibly needing signal) try</span><br><span class="line">     * to clear in anticipation of signalling.  It is OK if this</span><br><span class="line">     * fails or if status is changed by waiting thread.</span><br><span class="line">     */</span><br><span class="line">    int ws = node.waitStatus;</span><br><span class="line">    // 如果head节点当前waitStatus&lt;0, 将其修改为0</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line">    /*</span><br><span class="line">     * Thread to unpark is held in successor, which is normally</span><br><span class="line">     * just the next node.  But if cancelled or apparently null,</span><br><span class="line">     * traverse backwards from tail to find the actual</span><br><span class="line">     * non-cancelled successor.</span><br><span class="line">     */</span><br><span class="line">    // 下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待（waitStatus==1）</span><br><span class="line">    // 从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s = null;</span><br><span class="line">        // 从后往前找，仔细看代码，不必担心中间有节点取消(waitStatus==1)的情况</span><br><span class="line">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            if (t.waitStatus &lt;= 0)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    if (s != null)</span><br><span class="line">        // 唤醒线程</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唤醒线程以后，被唤醒的线程将从以下代码中继续往前走：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this); // 刚刚线程被挂起在这里了</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line">// 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了</span><br></pre></td></tr></table></figure><h1><a id="_35"></a>总结</h1><p>总结一下吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在并发环境下，加锁和解锁需要以下三个部件的协调：</span><br><span class="line"></span><br><span class="line">锁状态。我们要知道锁是不是被别的线程占有了，这个就是 state 的作用，它为 0 的时候代表没有线程占有锁，可以去争抢这个锁，用 CAS 将 state 设为 1，如果 CAS 成功，说明抢到了锁，这样其他线程就抢不到了，如果锁重入的话，state进行 +1 就可以，解锁就是减 1，直到 state 又变为 0，代表释放锁，所以 lock() 和 unlock() 必须要配对啊。然后唤醒等待队列中的第一个线程，让其来占有锁。</span><br><span class="line">线程的阻塞和解除阻塞。AQS 中采用了 LockSupport.park(thread) 来挂起线程，用 unpark 来唤醒线程。</span><br><span class="line">阻塞队列。因为争抢锁的线程可能很多，但是只能有一个线程拿到锁，其他的线程都必须等待，这个时候就需要一个 queue 来管理这些线程，AQS 用的是一个 FIFO 的队列，就是一个链表，每个 node 都持有后继节点的引用。AQS 采用了 CLH 锁的变体来实现，感兴趣的读者可以参考这篇文章关于CLH的介绍，写得简单明了。</span><br></pre></td></tr></table></figure><h1><a id="_39"></a>示例图解析</h1><p>下面属于回顾环节，用简单的示例来说一遍，如果上面的有些东西没看懂，这里还有一次帮助你理解的机会。</p><p>首先，第一个线程调用 reentrantLock.lock()，翻到最前面可以发现，tryAcquire(1) 直接就返回 true 了，结束。只是设置了 state=1，连 head 都没有初始化，更谈不上什么阻塞队列了。要是线程 1 调用 unlock() 了，才有线程 2 来，那世界就太太太平了，完全没有交集嘛，那我还要 AQS 干嘛。</p><p>如果线程 1 没有调用 unlock() 之前，线程 2 调用了 lock(), 想想会发生什么？</p><p>线程 2 会初始化 head【new Node()】，同时线程 2 也会插入到阻塞队列并挂起 (注意看这里是一个 for 循环，而且设置 head 和 tail 的部分是不 return 的，只有入队成功才会跳出循环)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        if (t == null) &#123; // Must initialize</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，是线程 2 初始化 head 节点，此时 head==tail, waitStatus==0<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191025192734.png" alt><br>然后线程 2 入队：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191025192751.png" alt><br>同时我们也要看此时节点的 waitStatus，我们知道 head 节点是线程 2 初始化的，此时的 waitStatus 没有设置， java 默认会设置为 0，但是到 shouldParkAfterFailedAcquire 这个方法的时候，线程 2 会把前驱节点，也就是 head 的waitStatus设置为 -1。</p><p>那线程 2 节点此时的 waitStatus 是多少呢，由于没有设置，所以是 0；</p><p>如果线程 3 此时再进来，直接插到线程 2 的后面就可以了，此时线程 3 的 waitStatus 是 0，到 shouldParkAfterFailedAcquire 方法的时候把前驱节点线程 2 的 waitStatus 设置为 -1。<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191025192812.png" alt></p><p>这里可以简单说下 waitStatus 中 SIGNAL(-1) 状态的意思，Doug Lea 注释的是：代表后继节点需要被唤醒。也就是说这个 waitStatus 其实代表的不是自己的状态，而是后继节点的状态，我们知道，每个 node 在入队的时候，都会把前驱节点的状态改为 SIGNAL，然后阻塞，等待被前驱唤醒。这里涉及的是两个问题：有线程取消了排队、唤醒操作。其实本质是一样的，读者也可以顺着 “waitStatus代表后继节点的状态” 这种思路去看一遍源码。</p><h1><a id="_62"></a>疑问</h1><h2><a id="headnew_Nodehead_63"></a><a class="header-anchor" href="#保留head为刚开始的new-node-不好吗？为什么要重新设置一下head呢？">¶</a>保留head为刚开始的new Node()不好吗？为什么要重新设置一下head呢？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final Node p = node.predecessor();</span><br><span class="line">if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">     setHead(node); </span><br><span class="line">     p.next = null; // help GC</span><br><span class="line">     failed = false;</span><br><span class="line">     return interrupted;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>假设不调用 setHead(node)，我们假设此时 A 持有这个锁，head 是 new Node() 那个空节点。</p><p>A 持有的锁用完了，释放锁，唤醒后继节点 B。后继节点 B 从 parkAndCheckInterrupt() 这个方法返回，注意这里的 for 循环。然后调用 final Node p = node.predecessor(); 这个方法，那么这个时候，p == head 就不成立了，也就进不到 tryAcquire(arg) 这里去获取锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for (;;) &#123;</span><br><span class="line">    final Node p = node.predecessor();</span><br><span class="line">    if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">        // 进到这里，说明获取到锁了</span><br><span class="line">        setHead(node);</span><br><span class="line">        p.next = null; // help GC</span><br><span class="line">        failed = false;</span><br><span class="line">        return interrupted;</span><br><span class="line">    &#125;</span><br><span class="line">    if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">        parkAndCheckInterrupt())</span><br><span class="line">        interrupted = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一处。既然当前线程获取到了锁，它就不应该再是阻塞队列的一员。如果没有 setHead 这一步，下面这个方法就不准确了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final Collection&lt;Thread&gt; getQueuedThreads() &#123;</span><br><span class="line">    ArrayList&lt;Thread&gt; list = new ArrayList&lt;Thread&gt;();</span><br><span class="line">    for (Node p = tail; p != null; p = p.prev) &#123;</span><br><span class="line">        Thread t = p.thread;</span><br><span class="line">        if (t != null) // 注意这里</span><br><span class="line">            list.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><a id="finallycancelAcquire_tailCANCELheadCANCEL_72"></a><a class="header-anchor" href="#这个finally里的cancelacquire-似乎永远都不会被执行吧-为什么都是要从tail往前找第一个状态是非cancel的节点呢-如果从head往后找第一个状态是非cancel的话效率会不会高一点">¶</a>这个finally里的cancelAcquire 似乎永远都不会被执行吧?为什么都是要从tail往前找第一个状态是非CANCEL的节点呢，如果从head往后找第一个状态是非CANCEL的话效率会不会高一点?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">boolean failed = true;</span><br><span class="line">try &#123;</span><br><span class="line">    boolean interrupted = false;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        final Node p = node.predecessor();</span><br><span class="line">        if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">            setHead(node);</span><br><span class="line">            p.next = null; // help GC</span><br><span class="line">            failed = false;</span><br><span class="line">            return interrupted;</span><br><span class="line">        &#125;</span><br><span class="line">        if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">            parkAndCheckInterrupt())</span><br><span class="line">            interrupted = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    if (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个问题：这里的 failed 确实永远都不会为 true，cancelAcquire() 永远不会得到执行。那为什么要这么写呢，如果你看了后面的两篇，可能会有些体会，这部分其实是用于响应中断或超时的，你可以参考 doAcquireNanos(int arg, long nanosTimeout) 或 doAcquireInterruptibly(int arg)。在这个方法中确实是没用的，这更像是模板代码吧。<br>这段代码的异常可能发生在 tryAcquire(arg) 这里，因为这是依赖于子类来实现的。</p><p>第二个问题：应该说的是 unparkSuccessor(Node node) 这个方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Node s = node.next;</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s = null;</span><br><span class="line">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            if (t.waitStatus &lt;= 0)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    if (s != null)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br></pre></td></tr></table></figure><p>首先，第一行代码先检测 head 的后继节点，只有当此时的后继节点不存在或者这个后继节点取消了才开始从后往前找，所以大部分情况下，其实不会发生从后往前遍历整个队列的情况。（后继节点取消很正常，但是某节点在入队的时候，如果发现前驱是取消状态，前驱节点是会被请出队列的）</p><p>这个问题的答案在 addWaiter(Node mode)方法中，看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Node pred = tail;</span><br><span class="line">    if (pred != null) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        // 1. 先设置的 tail</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            // 2. 设置前驱节点的后继节点为当前节点</span><br><span class="line">            pred.next = node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以，这里存在并发问题：从前往后寻找不一定能找到刚刚加入队列的后继节点。</p><h2><a id="JavamonitorAQSAQS_85"></a><a class="header-anchor" href="#感觉java的monitor和aqs的目的和实现思路很相似-为什么还要再实现一遍aqs呢？">¶</a>感觉Java的monitor和AQS的目的和实现思路很相似，为什么还要再实现一遍AQS呢？</h2><p>monitor 功能太单一了，就是获取独占锁，</p><p>AQS 相比 monitor，功能要丰富很多，比如我们可以设置超时时间，可以用线程中断进行退出，可以选择公平/非公平模式等, 采用 AQS 可以实现很多灵活的场景</p><h2><a id="acquireQueuedshouldParkAfterFailedAcquirep_nodewaitStatus01falseacquireQueuedshouldParkAfterFailedAcquiretrueparkAndCheckInterruptBAwaitStatus1unparkB_90"></a><a class="header-anchor" href="#acquirequeued方法里面-第一次调用shouldparkafterfailedacquire-p-node-的时候-把前驱节点waitstatus从0改为-1-然后返回false-回到acquirequeued方法-再尝试拿一次锁-然后第二次调用shouldparkafterfailedacquire返回true-调用parkandcheckinterrupt-挂起线程-那么-如果在某线程b还没有挂起之前-前驱节点的线程a发现自己waitstatus为-1直接unpark-然后刚刚的线程b才挂起-那不就没人能唤醒它了吗？它是怎么保证被唤醒的？">¶</a>acquireQueued方法里面，第一次调用shouldParkAfterFailedAcquire(p, node)的时候，把前驱节点waitStatus从0改为-1，然后返回false，回到acquireQueued方法，再尝试拿一次锁，然后第二次调用shouldParkAfterFailedAcquire返回true，调用parkAndCheckInterrupt()挂起线程。那么，如果在某线程B还没有挂起之前，前驱节点的线程A发现自己waitStatus为-1直接unpark，然后刚刚的线程B才挂起。那不就没人能唤醒它了吗？它是怎么保证被唤醒的？</h2><p>你应该已经把流程摸清楚了，我就说一点就可以了，你的疑问其实在 unpark() 方法上。<br>1、如果一个线程 park 了，那么调用 unpark(thread) 这个线程会被唤醒；<br>2、如果一个线程先被调用了 unpark，那么下一个 park(thread) 操作不会挂起线程。</p><h2><a id="tailheadtailnull_95"></a><a class="header-anchor" href="#为什么要先读tail-再读head-我猜是为了增加tail为null的可能性-可是增加这种可能性的目的呢？">¶</a>为什么要先读tail，再读head，我猜是为了增加tail为null的可能性，可是增加这种可能性的目的呢？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">    // The correctness of this depends on head being initialized</span><br><span class="line">    // before tail and on head.next being accurate if the current</span><br><span class="line">    // thread is first in queue.</span><br><span class="line">    Node t = tail; // Read fields in reverse initialization order</span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    return h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == null || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下面这段代码，如果是第一个 node 进队列的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        if (t == null) &#123;</span><br><span class="line">            // 1. 设置 head </span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                // 2. 设置 tail</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，先有 head 然后才有 tail。</p><p>回到 hasQueuedPredecessors：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    return h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == null || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有可能的情况就是 t 为 null，h 不为 null 对吧，这个时候返回值取决于 h.next。<br>如果调换一下 Node t = tail; 和 Node h = head; 那么可能出现 h 为 null，t 不为 null，这个方法会返回 false。<br>但是其实不对的，很可能这个间隙是有节点 enq 成功的。</p><h2><a id="nodenewnull_107"></a><a class="header-anchor" href="#为什么共享锁的node节点是new了一个节点-独占是null呢">¶</a>为什么共享锁的node节点是new了一个节点，独占是null呢?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">其实我也不知道是为什么???</span><br><span class="line">大神 Doug Lea 的想法应该是(我怎么知道他到底怎么想的)：nextWaiter 这个属性在这个时候是没用的，因为它用来实现 Condition，那么不用白不用，虽然不好理解，可是充分利用资源呀，不然还得自己额外定义一个用来标识模式的属性。</span><br></pre></td></tr></table></figure><h2><a id="tryAcquireargaddWaiterNodeEXCLUSIVE__selfInterrupt_selfInterruptacquireint_arg_110"></a><a class="header-anchor" href="#请问这个里如果同步状态tryacquire-arg-获取失败-就构造一个同步节点通过addwaiter-node-exclusive-将节点添加到尾部-如果条件成立执行-selfinterrupt-会中断当前线程吗-selfinterrupt-的用途不是太明白-有的书籍上说acquire-int-arg-方法对中断不敏感-不会将获取同步状态失败的线程从同步队列中移除">¶</a>请问这个里如果同步状态tryAcquire(arg)获取失败，就构造一个同步节点通过addWaiter(Node.EXCLUSIVE)将节点添加到尾部，如果条件成立执行 selfInterrupt()会中断当前线程吗 selfInterrupt()的用途不是太明白，有的书籍上说acquire(int arg)方法对中断不敏感，不会将获取同步状态失败的线程从同步队列中移除</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acquireQueued 返回值代表的是：是否被中断过。但是，不管是否被中断过，acquireQueued 出来以后，线程的中断状态一定是 false，所以如果发生过中断，要重新设置中断状态。<br>虽然 acquire(int arg) 确实是不关心中断的，但是它会保持这个状态，如果客户端想要知道是否发生过中断的话，还是可以知道的。因为中断情况下，中断状态虽然中间丢过，但是 selfInterrupt() 会设置回去。<br>会实际受到中断影响的是另一个方法 acquireInterruptibly(int arg)，这个方法会通过抛出异常的方式告诉客户端。</p><p>acquireQueued 返回值代表的是：是否被中断过。但是，不管是否被中断过，acquireQueued 出来以后，线程的中断状态一定是 false。<br>请问为什么说：acquireQueued 出来以后，线程的中断状态一定是 false ？</p><p>看一下 Thread.interrupted() 这个方法，这个方法用于检测中断状态，同时会清除中断状态。</p><h2><a id="head_head_head_121"></a><a class="header-anchor" href="#不是很明白head-节点是当前独占锁的持有者的意思-注释也说到head一般指的是占有锁的线程-请问从何作出这个判断？-看代码感觉整个阻塞队列-包括head节点-都没有当前占有锁线程的信息">¶</a>不是很明白head 节点是当前独占锁的持有者的意思(注释也说到head一般指的是占有锁的线程)，请问从何作出这个判断？ 看代码感觉整个阻塞队列（包括head节点）都没有当前占有锁线程的信息。</h2><p>这是隐含的信息，ReentrantLock 具有排他性，lock() 方法要么阻塞，要么顺利拿到锁返回。<br>当 lock() 返回的时候，我们说当前线程持有了独占锁，而此时的 head 就是当前线程。<br>（这里说的情况不考虑连 head 都没有初始化的场景）</p><p>这样的说法很容易让人混淆，应该是得分两种情况考虑:<br>1、当前已有别的线程持有锁的时候，head是指向(head.next)下次解锁时即将能持有锁的线程。<br>2、当持有锁的线程unlock时， head 指向的就是当前持有锁的线程 ，但这个时间非常短，因为head马上又会指向一下个即将能持有锁的线程。</p><p>AcquireQueue()里，如果tryacquire()成功，会用setHead(node)将当前获得锁的Node设为Head。</p><h2><a id="_133"></a><a class="header-anchor" href="#为什么如果不满足条件就唤醒下一位">¶</a>为什么如果不满足条件就唤醒下一位</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void cancelAcquire(Node node) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // If we are the tail, remove ourselves.</span><br><span class="line">    if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, null);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int ws;</span><br><span class="line">        /* 这里为什么如果不满足条件就唤醒下一位</span><br><span class="line">         * 第一个条件我是理解的 如果pred是head 那么需要唤醒下一位</span><br><span class="line">         * 因为如果前面是pred ==head 那么这个cancel的线程定时醒来后</span><br><span class="line">         * 如果还没有执行赋值，那么此时持有锁的线程正好开始释放锁，</span><br><span class="line">         * 那么会唤醒第一个阻塞的线程，假设这个线程正好是上面的线程</span><br><span class="line">         * 那么如果此时这个cancel的线程不传递这个唤醒，就会造成</span><br><span class="line">         * 其他线程醒不来， 但是为什么下面两个条件的失败也会唤醒后面的线程？</span><br><span class="line">         */</span><br><span class="line">        if (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != null) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化一下，如果要进入到 else，需要满足：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(ws = pred.waitStatus) != Node.SIGNAL</span><br><span class="line">&amp;&amp;</span><br><span class="line">ws &gt; 0 || (ws &lt;=0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))</span><br></pre></td></tr></table></figure><p>HongJie 2018-04-24 08:00:26<br>转化一下，如果要进入到 else，需要满足：</p><p>(ws = pred.waitStatus) != Node.SIGNAL<br>&amp;&amp;<br>ws &gt; 0 || (ws &lt;=0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))<br>再将其转化为下面两种情况：</p><p>(ws = pred.waitStatus != Node.SIGNAL) &amp;&amp; ws &gt; 0<br>前驱节点处于 CANCELLED 状态，显然是需要唤醒后继节点的，这条很简单</p><p>(ws = pred.waitStatus != Node.SIGNAL) &amp;&amp; (ws &lt;= 0) &amp;&amp; (!compareAndSetWaitStatus(pred, ws, Node.SIGNAL))<br>这种情况下，在将前驱设置为 SIGNAL 的时候失败了，我想到的一种情况是，在 CAS 之前前驱设置为了 CANCELLED</p><p>结合 acquireQueued 方法来看，假设里面的 tryAcquire 抛出异常的场景。</p><h2><a id="predthread__null_154"></a><a class="header-anchor" href="#pred-thread-null">¶</a>pred.thread == null</h2><p>head 是 new Node() 的“空节点”，要是不做唤醒后继节点的话，那。。。你懂的</p><h2><a id="VMmonitormutexAQSReentrantLock_157"></a><a class="header-anchor" href="#vm的monitor最终是使用了-如果升级为重量锁-mutex-操作系统级的支持；能否这样理解-基于aqs的reentrantlock不需要操作系统的锁支持了-所以比较轻？而且也不会升级为重量级锁-本身只是个等待队列而已">¶</a>VM的monitor最终是使用了（如果升级为重量锁）mutex，操作系统级的支持；能否这样理解，基于AQS的ReentrantLock不需要操作系统的锁支持了，所以比较轻？而且也不会升级为重量级锁，本身只是个等待队列而已。</h2><p>我里理解的ReetrantLock 公平锁 和 synchronized 的原理差不多，也有重量级锁，也有升级的步骤。<br>ReetrantLock 首先会采用自旋获取锁（偏向锁），之后的线程进来发现获取不到锁，就加入队列中，如果前驱节点是 head，就会尝试获取一次错，如果没有获取成功，就线程挂起（锁膨胀）。涉及到上下文切换，系统调用。</p><h2><a id="12head_true_h__t__s__hnext__null__161"></a><a class="header-anchor" href="#1队列非空-2队列第一个节点-非head-非当前线程-满足两个条件返回true-那么h-t-s-h-next-null-这样一种场景怎么理解">¶</a>1队列非空，2队列第一个节点（非head）非当前线程 满足两个条件返回true， 那么h != t &amp;&amp; (s = h.next) == null 这样一种场景怎么理解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">    Node t = tail; // Read fields in reverse initialization order</span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    return h != t &amp;&amp;</span><br><span class="line">        ( (s = h.next) == null || s.thread != Thread.currentThread() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你的问题需要到 enq 找答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        if (t == null) &#123;</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                // 看这里</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节点入队时，先成为 tail 然后才设置前驱的 next 属性。<br>那么对应于你的问题，h != t &amp;&amp; h.next == null 对应的就是某个节点现在已经是 tail 了，但是 head.next 还是 null。</p><p>虽然文中没有分析到这个分支，不过还是有些细心的读者对这个很感兴趣的，你也可以往前看下另一个读者的问题，也是针对这个方法的。<br>这里肯定是不会为 null 的，你可以把你认为它可能会为 null 的分析过程描述得详细一些，这样我们比较容易在一个频道上。</p><h2><a id="_171"></a><a class="header-anchor" href="#这个不是个死循环嘛？这么循环怎么能成立的呀？麻烦大神给解释一下">¶</a>这个不是个死循环嘛？这么循环怎么能成立的呀？麻烦大神给解释一下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do &#123; node.prev = pred = pred.prev;  &#125; while (pred.waitStatus &gt; 0);&lt;br&gt;pred = pred.prev</span><br></pre></td></tr></table></figure><p>这里没有死循环呀，一直在沿着队列往前走，找到一个 waitStatus&lt;=0 的节点</p><h2><a id="_175"></a><a class="header-anchor" href="#阻塞队列的头结点是什么时候初始化的呢？">¶</a>阻塞队列的头结点是什么时候初始化的呢？</h2><ol><li>当前队列为空</li><li>2.当有线程阻塞的时候</li></ol><h2><a id="_179"></a><a class="header-anchor" href="#为什么不在锁的构造器里就先建一个阻塞队列的头结点呢？">¶</a>为什么不在锁的构造器里就先建一个阻塞队列的头结点呢？</h2><p>如果没有线程竞争锁的话就是浪费一个节点的空间，Doug Lea大师的注释如下。可见大师的代码一点一滴都体现水平。</p><ul><li>CLH queues need a dummy header node to get started. But</li><li>we don’t create them on construction, because it would be wasted</li><li>effort if there is never contention. Instead, the node</li><li>is constructed and head and tail pointers are set upon first</li><li>contention. ``` 问：阻塞队列的头结点什么时候会被GC呢？ 答：当队列里第一个Node节点得到锁后，该节点会被设置成新的头结点。那么原来“老”的头结点由于没有任何引用指向它，就会被GC回收。</li></ul><h2><a id="nodenodeheadheadprednullhead_187"></a><a class="header-anchor" href="#队列中的线程节点node被唤醒后-node直接变为head-指向原head的指针pred没有被置null-原head节点没法回收吧">¶</a>队列中的线程节点node被唤醒后，node直接变为head，指向原head的指针pred没有被置null，原head节点没法回收吧</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    ...</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                // 拿到锁进来这里</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = null; // help GC</span><br><span class="line">                failed = false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 setHead(node) 方法里面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void setHead(Node node) &#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = null;</span><br><span class="line">    // 这个</span><br><span class="line">    node.prev = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><a id="headstatestatenodewaitStatus_192"></a><a class="header-anchor" href="#head节点的属性是不是state-这个state表示当前锁已经被占用几次了-阻塞队列里的node的属性是waitstatus-代表着阻塞队列里节点的状态-这是两个枚举值完全不相关的属性吗？">¶</a>head节点的属性是不是state，这个state表示当前锁已经被占用几次了。阻塞队列里的node的属性是waitStatus，代表着阻塞队列里节点的状态。这是两个枚举值完全不相关的属性吗？</h2><p>head节点和阻塞队列其它的node都是waitStatus，state是AQS的属性，不相关的</p><h2><a id="_fifo_hnew_Node_t__null__h__t__s__hnext__null__true__hnext__null__Predecessors_Predecessors__true___195"></a><a class="header-anchor" href="#刚初始化-fifo-的时候-h-new-node-t-null-这样子-h-t-s-h-next-null-不是为-true-吗-h-next-null-因为是刚初始化的节点-这样子不是没有-predecessors-嘛-那这个明明没有predecessors-却返回-true-；不是错了吗-是我理解错误吗">¶</a>刚初始化 fifo 的时候，h=new Node(); t = null; 这样子 h != t &amp;&amp; (s = h.next) == null 不是为 true 吗， h.next == null; 因为是刚初始化的节点，这样子不是没有 Predecessors 嘛。那这个明明没有Predecessors 却返回 true ；不是错了吗 是我理解错误吗?</h2><p>只要 head!=tail 就说明有新的节点进来到队列的尾部了，如果 h.next == null, 说明正在初始化节点中，如果不是初始化中的话，只要 Head 的下一个节点不是 刚进来的 thread 的 的Node,如果是的话就说明没有正在等待的节点，<br>对了先补充下这个方法的意思，查询是否有任何线程等待获取比当前线程更长的时间。<br>true如果有排队线前面的当前线程，并 false如果当前线程在队列或队列的头部是空的</p><h2><a id="_cancelAcquire__unparkSuccessornode___pred__head_pred____unparkSuccessornode___nodenext___unpark__unpark__park___unpark__unpark__condition__waiter___201"></a><a class="header-anchor" href="#对于-cancelacquire-的-unparksuccessor-node-会不会唤醒两次呢-如果-pred-head；然后又刚好-pred-线程也要出同步块了-也调用了-unparksuccessor-node-那这个时候-node-next-是不是-会两次-unpark-呢-因为-unpark-会抵消-park-所以-在第一次-unpark-将线程唤醒了-第二次-unpark-将许可证置为可用的-那么下次-condition-的-waiter-会不会-被抵消掉呢">¶</a>对于 cancelAcquire() 的 unparkSuccessor(node); 会不会唤醒两次呢。 如果 pred == head；然后又刚好 pred 线程也要出同步块了 也调用了 unparkSuccessor(node); 那这个时候 node.next 是不是 会两次 unpark() 呢，因为 unpark 会抵消 park() ，所以 在第一次 unpark 将线程唤醒了，第二次 unpark 将许可证置为可用的.那么下次 condition 的 waiter 会不会 被抵消掉呢?</h2><p>你的问题挺有趣的，我没有仔细去推演每一步，不过我觉得其实这也不是什么大问题。仔细想想，即使真的是两次 unpark 了（假设真的如此），大不了就是后面会出现一次 park 直接返回。<br>对于 park 方法，我们本来就是要假设它有可能会无故返回的，被中断或者系统的假唤醒，所以这些代码往往都在循环体中。</p><h2><a id="NodeNode_205"></a><a class="header-anchor" href="#获取锁-释放锁-阻塞队列的node数量不会减少吗？好像没看到在哪里减少阻塞队列里面node的数量？">¶</a>获取锁、释放锁，阻塞队列的Node数量不会减少吗？好像没看到在哪里减少阻塞队列里面Node的数量？</h2><p>因为我们通常并不关心阻塞队列中到底有多少 Node<br>获取到锁的节点会变成head，在那里会把原来的head移出队列<br>在acquireQueued里面获取到同步状态，下面两条语句让Head出列。<br>setHead(node);<br>p.next = null;</p><h2><a id="acquireQueuedheadhead__head_212"></a><a class="header-anchor" href="#在acquirequeued里会做自旋操作-如果前边节点是head就尝试获取锁-如果前面节点不是head-做后面的挂起或者不挂起-这样的话-只有一个节点-就是head后面的那个节点-才会尝试获取锁-这样何来竞争锁的说法呢">¶</a>在acquireQueued里会做自旋操作,如果前边节点是head就尝试获取锁,如果前面节点不是head,做后面的挂起或者不挂起. 这样的话,只有一个节点(就是head后面的那个节点)才会尝试获取锁,这样何来竞争锁的说法呢?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为非公平锁的实现里面，每个新来的线程，是不管队列是否为空，都会先去做一次抢锁的。</span><br></pre></td></tr></table></figure><h2><a id="unparkSuccessors__null__swaitStatus__0waitStatus__1acquireQueuedNode_node_int_argforheadnodepredecessor__headtryAcquireheadnodepredecessor__headtrue_215"></a><a class="header-anchor" href="#在unparksuccessor-方法中-如果s-null-s-waitstatus-0-会从阻塞队列的尾部开始一直向前找-找到最前面一个waitstatus-1的节点-将其唤醒-我的问题是-唤醒之后-该线程从acquirequeued-node-node-int-arg-方法的for循环中醒过来-继续循环-只有当自己的前驱节点为head节点即node-predecessor-head时-才会去tryacquire-抢锁-可是在从后往前找的过程中-并没有看到把当前找寻的目标节点和head节点链接上的步骤啊-这样不就不能判断node-predecessor-head为true吗？也就不能抢锁了">¶</a>在unparkSuccessor（）方法中，如果s == null || s.waitStatus &gt; 0，会从阻塞队列的尾部开始一直向前找，找到最前面一个waitStatus == -1的节点，将其唤醒。我的问题是，唤醒之后，该线程从acquireQueued（Node node, int arg）方法的for循环中醒过来，继续循环，只有当自己的前驱节点为head节点即node.predecessor() == head时，才会去tryAcquire（）抢锁，可是在从后往前找的过程中，并没有看到把当前找寻的目标节点和head节点链接上的步骤啊，这样不就不能判断node.predecessor() == head为true吗？也就不能抢锁了…</h2><p>问题在 acquireQueued 这个方法中。<br>我不清楚你具体的疑惑在哪里，但是你可以看看嵌套在死循环中的 shouldParkAfterFailedAcquire。<br>我觉得 AQS 里面有个比较重要的点是，它总是先保证节点能安全进入到队列中，至于你说的这种边界问题，都在“被动”发现 waitStatus 不对的时候去“纠正”它。</p></div><div id="wechat_subscriber" style="display:block;padding:10px 0;margin:20px auto;width:100%;text-align:center"><img id="wechat_subscriber_qcode" src="/blog/uploads/wechat-qcode.png" alt="Jeff-Eric wechat" style="width:200px;max-width:100%"><div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Jeff-Eric</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://jeff-eric.github.com/blog/2019/10/24/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F/" title="AbstractQueuedSynchronizer 原理分析 - 独占模式">https:&#x2F;&#x2F;jeff-eric.github.com&#x2F;blog&#x2F;2019&#x2F;10&#x2F;24&#x2F;AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F&#x2F;</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank">&lt;i class=&quot;fa fa-fw fa-creative-commons&quot;&gt;&lt;&#x2F;i&gt;BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/blog/tags/%E7%BA%BF%E7%A8%8B/" rel="tag"># 线程</a></div><div class="post-widgets"><div class="social_share"><div id="needsharebutton-postbottom"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/blog/2019/10/22/spring%20-%20IOC/" rel="next" title="spring - IOC"><i class="fa fa-chevron-left"></i> spring - IOC</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/blog/2019/10/24/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/" rel="prev" title="AbstractQueuedSynchronizer 原理分析 - 独占/共享模式">AbstractQueuedSynchronizer 原理分析 - 独占/共享模式 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/blog/uploads/avatar.jpg" alt="Jeff-Eric"><p class="site-author-name" itemprop="name">Jeff-Eric</p><div class="site-description motion-element" itemprop="description"></div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/blog/archives/%20%7C%7C%20archive"><span class="site-state-item-count">42</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/blog/categories/%20%7C%7C%20th"><span class="site-state-item-count">12</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/blog/tags/%20%7C%7C%20tags"><span class="site-state-item-count">28</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/jeff-eric" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;jeff-eric" rel="noopener" target="_blank">&lt;i class=&quot;fa fa-fw fa-github&quot;&gt;&lt;&#x2F;i&gt;GitHub</a> </span><span class="links-of-author-item"><a href="/blog/jphoebe4086824@gmail.com" title="E-Mail &amp;rarr; jphoebe4086824@gmail.com">&lt;i class=&quot;fa fa-fw fa-envelope&quot;&gt;&lt;&#x2F;i&gt;E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank">&lt;img src=&quot;&#x2F;blog&#x2F;images&#x2F;cc-by-nc-sa.svg&quot; alt=&quot;Creative Commons&quot;&#x2F;&gt;</a></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">1.</span> <span class="nav-text">AQS 结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">2.</span> <span class="nav-text">线程强锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">3.</span> <span class="nav-text">解锁操作</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">5.</span> <span class="nav-text">示例图解析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">6.</span> <span class="nav-text">疑问</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">6.1.</span> <span class="nav-text">¶保留head为刚开始的new Node()不好吗？为什么要重新设置一下head呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">6.2.</span> <span class="nav-text">¶这个finally里的cancelAcquire 似乎永远都不会被执行吧?为什么都是要从tail往前找第一个状态是非CANCEL的节点呢，如果从head往后找第一个状态是非CANCEL的话效率会不会高一点?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">6.3.</span> <span class="nav-text">¶感觉Java的monitor和AQS的目的和实现思路很相似，为什么还要再实现一遍AQS呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">6.4.</span> <span class="nav-text">¶acquireQueued方法里面，第一次调用shouldParkAfterFailedAcquire(p, node)的时候，把前驱节点waitStatus从0改为-1，然后返回false，回到acquireQueued方法，再尝试拿一次锁，然后第二次调用shouldParkAfterFailedAcquire返回true，调用parkAndCheckInterrupt()挂起线程。那么，如果在某线程B还没有挂起之前，前驱节点的线程A发现自己waitStatus为-1直接unpark，然后刚刚的线程B才挂起。那不就没人能唤醒它了吗？它是怎么保证被唤醒的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">6.5.</span> <span class="nav-text">¶为什么要先读tail，再读head，我猜是为了增加tail为null的可能性，可是增加这种可能性的目的呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">6.6.</span> <span class="nav-text">¶为什么共享锁的node节点是new了一个节点，独占是null呢?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">6.7.</span> <span class="nav-text">¶请问这个里如果同步状态tryAcquire(arg)获取失败，就构造一个同步节点通过addWaiter(Node.EXCLUSIVE)将节点添加到尾部，如果条件成立执行 selfInterrupt()会中断当前线程吗 selfInterrupt()的用途不是太明白，有的书籍上说acquire(int arg)方法对中断不敏感，不会将获取同步状态失败的线程从同步队列中移除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">6.8.</span> <span class="nav-text">¶不是很明白head 节点是当前独占锁的持有者的意思(注释也说到head一般指的是占有锁的线程)，请问从何作出这个判断？ 看代码感觉整个阻塞队列（包括head节点）都没有当前占有锁线程的信息。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">6.9.</span> <span class="nav-text">¶为什么如果不满足条件就唤醒下一位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">6.10.</span> <span class="nav-text">¶pred.thread == null</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">6.11.</span> <span class="nav-text">¶VM的monitor最终是使用了（如果升级为重量锁）mutex，操作系统级的支持；能否这样理解，基于AQS的ReentrantLock不需要操作系统的锁支持了，所以比较轻？而且也不会升级为重量级锁，本身只是个等待队列而已。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">6.12.</span> <span class="nav-text">¶1队列非空，2队列第一个节点（非head）非当前线程 满足两个条件返回true， 那么h != t &amp;&amp; (s = h.next) == null 这样一种场景怎么理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">6.13.</span> <span class="nav-text">¶这个不是个死循环嘛？这么循环怎么能成立的呀？麻烦大神给解释一下</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">6.14.</span> <span class="nav-text">¶阻塞队列的头结点是什么时候初始化的呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">6.15.</span> <span class="nav-text">¶为什么不在锁的构造器里就先建一个阻塞队列的头结点呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">6.16.</span> <span class="nav-text">¶队列中的线程节点node被唤醒后，node直接变为head，指向原head的指针pred没有被置null，原head节点没法回收吧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">6.17.</span> <span class="nav-text">¶head节点的属性是不是state，这个state表示当前锁已经被占用几次了。阻塞队列里的node的属性是waitStatus，代表着阻塞队列里节点的状态。这是两个枚举值完全不相关的属性吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">6.18.</span> <span class="nav-text">¶刚初始化 fifo 的时候，h=new Node(); t = null; 这样子 h != t &amp;&amp; (s = h.next) == null 不是为 true 吗， h.next == null; 因为是刚初始化的节点，这样子不是没有 Predecessors 嘛。那这个明明没有Predecessors 却返回 true ；不是错了吗 是我理解错误吗?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">6.19.</span> <span class="nav-text">¶对于 cancelAcquire() 的 unparkSuccessor(node); 会不会唤醒两次呢。 如果 pred == head；然后又刚好 pred 线程也要出同步块了 也调用了 unparkSuccessor(node); 那这个时候 node.next 是不是 会两次 unpark() 呢，因为 unpark 会抵消 park() ，所以 在第一次 unpark 将线程唤醒了，第二次 unpark 将许可证置为可用的.那么下次 condition 的 waiter 会不会 被抵消掉呢?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">6.20.</span> <span class="nav-text">¶获取锁、释放锁，阻塞队列的Node数量不会减少吗？好像没看到在哪里减少阻塞队列里面Node的数量？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">6.21.</span> <span class="nav-text">¶在acquireQueued里会做自旋操作,如果前边节点是head就尝试获取锁,如果前面节点不是head,做后面的挂起或者不挂起. 这样的话,只有一个节点(就是head后面的那个节点)才会尝试获取锁,这样何来竞争锁的说法呢?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">6.22.</span> <span class="nav-text">¶在unparkSuccessor（）方法中，如果s == null || s.waitStatus &gt; 0，会从阻塞队列的尾部开始一直向前找，找到最前面一个waitStatus == -1的节点，将其唤醒。我的问题是，唤醒之后，该线程从acquireQueued（Node node, int arg）方法的for循环中醒过来，继续循环，只有当自己的前驱节点为head节点即node.predecessor() == head时，才会去tryAcquire（）抢锁，可是在从后往前找的过程中，并没有看到把当前找寻的目标节点和head节点链接上的步骤啊，这样不就不能判断node.predecessor() == head为true吗？也就不能抢锁了…</span></a></li></ol></li></ol></div></div></div><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Jeff-Eric</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0</div><span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.0.1</div></div></footer><div id="needsharebutton-float"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script><script id="ribbon" size="300" alpha="0.6" zindex="-1" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@2/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/npm/fastclick@1/lib/fastclick.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery-lazyload@1/jquery.lazyload.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three-waves.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_lines.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_sphere.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-reading-progress@1/reading_progress.min.js"></script><script src="/blog/js/src/utils.js?v=7.0.1"></script><script src="/blog/js/src/motion.js?v=7.0.1"></script><script src="/blog/js/src/affix.js?v=7.0.1"></script><script src="/blog/js/src/schemes/pisces.js?v=7.0.1"></script><script src="/blog/js/src/scrollspy.js?v=7.0.1"></script><script src="/blog/js/src/post-details.js?v=7.0.1"></script><script src="/blog/js/src/next-boot.js?v=7.0.1"></script><script src="/blog/js/src/js.cookie.js?v=7.0.1"></script><script src="/blog/js/src/scroll-cookie.js?v=7.0.1"></script><script src="//cdn.jsdelivr.net/npm/leancloud-storage@3/dist/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js"></script><script>var GUEST=["nick","mail","link"],guest="nick,mail,link";guest=guest.split(",").filter(function(e){return GUEST.indexOf(e)>-1}),new Valine({el:"#comments",verify:!0,notify:!1,appId:"MKGyMx7EafphCr9hAbMPAwAc-gzGzoHsz",appKey:"4SB8MPoE51bFPHDoKtPM8vLG",placeholder:"Just go go",avatar:"mm",meta:guest,pageSize:"10",visitor:!0})</script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var e=$("#local-search-input");e.attr("autocapitalize","none"),e.attr("autocorrect","off"),e.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/blog/"+search_path,onPopupClose=function(e){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(e,t,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:e,dataType:isXml?"xml":"json",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,r=document.getElementById(t),s=document.getElementById(o),a=function(){var e=r.value.trim().toLowerCase(),t=e.split(/[\s\-]+/);t.length>1&&t.push(e);var o=[];if(e.length>0&&n.forEach(function(n){function r(t,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===e&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(e,t){var o="",n=t.start;return t.hits.forEach(function(t){o+=e.substring(n,t.position);var r=t.position+t.length;o+='<b class="search-keyword">'+e.substring(t.position,r)+"</b>",n=r}),o+=e.substring(n,t.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url).replace(/\/{2,}/g,"/"),d=[],g=[];if(""!=l&&(t.forEach(function(e){function t(e,t,o){var n=e.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(t=t.toLowerCase(),e=e.toLowerCase());(s=t.indexOf(e,r))>-1;)a.push({position:s,word:e}),r=s+n;return a}d=d.concat(t(e,h,!1)),g=g.concat(t(e,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(e){e.sort(function(e,t){return t.position!==e.position?t.position-e.position:e.word.length-t.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hits.length!==t.hits.length?t.hits.length-e.hits.length:e.start-t.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(e){b+="<a href='"+f+'\'><p class="search-result">'+s(p,e)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===t.length&&""===t[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x"></i></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>';else{o.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hitCount!==t.hitCount?t.hitCount-e.hitCount:t.id-e.id});var a='<ul class="search-result-list">';o.forEach(function(e){a+=e.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(e){e.stopPropagation()}),$(document).on("keyup",function(e){var t=27===e.which&&$(".search-popup").is(":visible");t&&onPopupClose()})</script><script src="https://www.gstatic.com/firebasejs/4.6.0/firebase.js"></script><script src="https://www.gstatic.com/firebasejs/4.6.0/firebase-firestore.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/bluebird/3.5.1/bluebird.core.min.js"></script><script>!function(){function getCount(t,e){return t.get().then(function(a){var n;return a.exists?(n=a.data().count,e&&(window.localStorage&&window.localStorage.getItem(title)||(t.set({count:n+1}),n++))):e?(t.set({count:1}),n=1):n=0,window.localStorage&&e&&localStorage.setItem(title,!0),n})}function appendCountTo(t){return function(e){$(t).append($("<span>").addClass("post-visitors-count").append($("<span>").addClass("post-meta-divider").text("|")).append($("<span>").addClass("post-meta-item-icon").append($("<i>").addClass("fa fa-users"))).append($("<span>").text("阅读次数 "+e)))}}firebase.initializeApp({apiKey:"AIzaSyD-BIMnFQcvrv1utthoP5z5shcYP8JMKmY",projectId:"blog-6cbe0"});var db=firebase.firestore(),articles=db.collection("articles"),isPost="AbstractQueuedSynchronizer 原理分析 - 独占模式".length>0,isArchive=!1,isCategory="".length>0,isTag="".length>0;if(isPost){var title="AbstractQueuedSynchronizer 原理分析 - 独占模式",doc=articles.doc(title);getCount(doc,!0).then(appendCountTo($(".post-meta")))}else if(!isArchive&&!isCategory&&!isTag){var titles=[],postsstr="";eval(postsstr);var promises=titles.map(function(t){return articles.doc(t)}).map(function(t){return getCount(t)});Promise.all(promises).then(function(t){var e=$(".post-meta");t.forEach(function(t,a){appendCountTo(e[a])(t)})})}}()</script><style>.pdfobject-container{position:relative;overflow:auto;width:100%}</style><script>$("body").find("div.pdf").length&&$.ajax({type:"GET",url:"//cdn.jsdelivr.net/npm/pdfobject@2.1.1/pdfobject.min.js",dataType:"script",cache:!0,success:function(){$("body").find("div.pdf").each(function(e,t){PDFObject.embed($(t).attr("target"),$(t),{pdfOpenParams:{navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"},PDFJS_URL:"/lib/pdf/web/viewer.html",height:$(t).attr("height")||"500px"})})}})</script><script>$("body").find("pre.mermaid").length&&$.ajax({type:"GET",url:"//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js",dataType:"script",cache:!0,success:function(){mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})}})</script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script><script>pbOptions={},pbOptions.iconStyle="box",pbOptions.boxForm="horizontal",pbOptions.position="bottomCenter",pbOptions.networks="Weibo,Wechat,Douban,QQZone,Twitter,Facebook",new needShareButton("#needsharebutton-postbottom",pbOptions),flOptions={},flOptions.iconStyle="box",flOptions.boxForm="horizontal",flOptions.position="middleRight",flOptions.networks="Weibo,Wechat,Douban,QQZone,Twitter,Facebook",new needShareButton("#needsharebutton-float",flOptions)</script><script src="//cdn.jsdelivr.net/npm/pangu@3/dist/browser/pangu.min.js"></script><script>pangu.spacingPage()</script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@1/bookmark.min.js"></script><script>bookmark.scrollToMark("auto","#更多")</script><style>.copy-btn{display:inline-block;padding:6px 12px;font-size:13px;font-weight:700;line-height:20px;color:#333;white-space:nowrap;vertical-align:middle;cursor:pointer;background-color:#eee;background-image:linear-gradient(#fcfcfc,#eee);border:1px solid #d5d5d5;border-radius:3px;user-select:none;outline:0}.highlight-wrap .copy-btn{transition:opacity .3s ease-in-out;opacity:0;padding:2px 6px;position:absolute;right:4px;top:8px}.highlight-wrap .copy-btn:focus,.highlight-wrap:hover .copy-btn{opacity:1}.highlight-wrap{position:relative}</style><script>$(".highlight").each(function(t,e){var n=$("<div>").addClass("highlight-wrap");$(e).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(t){var e=$(this).parent().find(".code").find(".line").map(function(t,e){return $(e).text()}).toArray().join("\n"),n=document.createElement("textarea"),o=window.pageYOffset||document.documentElement.scrollTop;n.style.top=o+"px",n.style.position="absolute",n.style.opacity="0",n.readOnly=!0,n.value=e,document.body.appendChild(n),n.select(),n.setSelectionRange(0,e.length),n.readOnly=!1;var a=document.execCommand("copy");a?$(this).text("复制成功"):$(this).text("复制失败"),n.blur(),$(this).blur()})).on("mouseleave",function(t){var e=$(this).find(".copy-btn");setTimeout(function(){e.text("复制")},300)}).append(e)})</script></body></html><!-- rebuild by neat -->