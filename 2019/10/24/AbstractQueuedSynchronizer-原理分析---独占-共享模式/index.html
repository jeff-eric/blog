<!-- build time:Tue Nov 26 2019 14:32:21 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-CN,zh-HK,zh-TW,en,default"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/han-css@3/dist/han.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css"><link rel="stylesheet" href="/blog/css/main.css?v=7.0.1"><link rel="apple-touch-icon" sizes="180x180" href="/blog/uploads/avatar.jpg?v=7.0.1"><link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/avatar.jpg?v=7.0.1"><link rel="icon" type="image/png" sizes="16x16" href="/blog/blog/uploads/avatar.jpg?v=7.0.1"><link rel="mask-icon" href="/blog/uploads/avatar.jpg?v=7.0.1" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/blog/",scheme:"Gemini",version:"7.0.1",sidebar:{position:"left",display:"always",offset:12,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!0,fancybox:!0,fastclick:!0,lazyload:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="概念AbstractQueuedSynchronizer （抽象队列同步器，简称 AQS），AQS 是很多同步器的基础框架，比如 ReentrantLock、CountDownLatch 和 Semaphore 等都是基于 AQS 实现的。除此之外，我们还可以基于 AQS，定制出我们所需要的同步器。原理在 AQS 内部，通过维护一个FIFO 队列来管理多线程的排队工作。在公平竞争的情况下，无法获取"><meta name="keywords" content="线程"><meta property="og:type" content="article"><meta property="og:title" content="AbstractQueuedSynchronizer 原理分析 - 独占&#x2F;共享模式"><meta property="og:url" content="https:&#x2F;&#x2F;jeff-eric.github.com&#x2F;blog&#x2F;2019&#x2F;10&#x2F;24&#x2F;AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F&#x2F;index.html"><meta property="og:site_name" content="纯天然绿色学渣"><meta property="og:description" content="概念AbstractQueuedSynchronizer （抽象队列同步器，简称 AQS），AQS 是很多同步器的基础框架，比如 ReentrantLock、CountDownLatch 和 Semaphore 等都是基于 AQS 实现的。除此之外，我们还可以基于 AQS，定制出我们所需要的同步器。原理在 AQS 内部，通过维护一个FIFO 队列来管理多线程的排队工作。在公平竞争的情况下，无法获取"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191024151919.png"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191024152033.png"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191024174549.png"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191024181912.png"><meta property="og:updated_time" content="2019-10-25T11:03:50.332Z"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191024151919.png"><link rel="canonical" href="https://jeff-eric.github.com/blog/2019/10/24/AbstractQueuedSynchronizer-原理分析---独占-共享模式/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>AbstractQueuedSynchronizer 原理分析 - 独占/共享模式 | 纯天然绿色学渣</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?bb5d4f8207d7c2bd1aa936180430bbaa";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/blog/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">纯天然绿色学渣</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-home&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;首页</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-tags&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;标签&lt;span class=&quot;badge&quot;&gt;28&lt;&#x2F;span&gt;</a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-th&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;分类&lt;span class=&quot;badge&quot;&gt;12&lt;&#x2F;span&gt;</a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-archive&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;归档&lt;span class=&quot;badge&quot;&gt;42&lt;&#x2F;span&gt;</a></li><li class="menu-item menu-item-tools"><a href="/blog/tools/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-tree&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;工具</a></li><li class="menu-item menu-item-search"><a href="javascript:;" target="_blank" rel="noopener" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><div class="reading-progress-bar"></div><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jeff-eric.github.com/blog/blog/2019/10/24/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jeff-Eric"><meta itemprop="description" content=""><meta itemprop="image" content="/blog/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="纯天然绿色学渣"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">AbstractQueuedSynchronizer 原理分析 - 独占/共享模式</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-24 14:13:00" itemprop="dateCreated datePublished" datetime="2019-10-24T14:13:00+08:00">2019-10-24</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-10-25 19:03:50" itemprop="dateModified" datetime="2019-10-25T19:03:50+08:00">2019-10-25</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/blog/2019/10/24/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/2019/10/24/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/" itemprop="commentCount"></span> </a></span><span id="/blog/2019/10/24/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/" class="leancloud_visitors" data-flag-title="AbstractQueuedSynchronizer 原理分析 - 独占/共享模式"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body han-init-context" itemprop="articleBody"><h1><a id="_1"></a>概念</h1><p>AbstractQueuedSynchronizer （抽象队列同步器，简称 AQS），AQS 是很多同步器的基础框架，比如 ReentrantLock、CountDownLatch 和 Semaphore 等都是基于 AQS 实现的。除此之外，我们还可以基于 AQS，定制出我们所需要的同步器。</p><h1><a id="_4"></a>原理</h1><p>在 AQS 内部，通过维护一个FIFO 队列来管理多线程的排队工作。在公平竞争的情况下，无法获取同步状态的线程将会被封装成一个节点，置于队列尾部。入队的线程将会通过自旋的方式获取同步状态，若在有限次的尝试后，仍未获取成功，线程则会被阻塞住。大致示意图如下：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191024151919.png" alt></p><p>当头结点释放同步状态后，且后继节点对应的线程被阻塞，此时头结点线程将会去唤醒后继节点线程。后继节点线程恢复运行并获取同步状态后，会将旧的头结点从队列中移除，并将自己设为头结点。大致示意图如下：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191024152033.png" alt></p><h1><a id="_11"></a>常用方法</h1><p>主要介绍三组重要的方法，通过使用这三组方法即可实现一个同步组件。<br>第一组方法是用于访问/设置同步状态的，如下：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>int getState()</td><td>设置同步状态</td></tr><tr><td>void setState()</td><td>设置同步状态</td></tr><tr><td>boolean compareAndSetState(int expect, int update)</td><td>通过 CAS 设置同步状态</td></tr></tbody></table><p>第二组方<font color="red">需要由同步组件覆写</font>。如下：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean tryAcquire(int arg)</td><td>独占式获取同步状态</td></tr><tr><td>boolean tryRelease(int arg)</td><td>独占式释放同步状态</td></tr><tr><td>int tryAcquireShared(int arg)</td><td>共享式获取同步状态</td></tr><tr><td>boolean tryReleaseShared(int arg)</td><td>共享式私房同步状态</td></tr><tr><td>boolean isHeldExclusively()</td><td>检测当前线程是否获取独占锁</td></tr></tbody></table><p>第三组方法是一组模板方法，同步组件可直接调用。如下：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void acquire(int arg)</td><td>独占式获取同步状态，该方法将会调用 tryAcquire 尝试获取同步状态。获取成功则返回，获取失败，线程进入同步队列等待。</td></tr><tr><td>void acquireInterruptibly(int arg)</td><td>响应中断版的 acquire</td></tr><tr><td>boolean tryAcquireNanos(int arg,long nanos)</td><td>超时+响应中断版的 acquire</td></tr><tr><td>void acquireShared(int arg)</td><td>共享式获取同步状态，同一时刻可能会有多个线程获得同步状态。比如读写锁的读锁就是就是调用这个方法获取同步状态的。</td></tr><tr><td>void acquireSharedInterruptibly(int arg)</td><td>响应中断版的 acquireShared</td></tr><tr><td>boolean tryAcquireSharedNanos(int arg,long nanos)</td><td>超时+响应中断版的 acquireShared</td></tr><tr><td>boolean release(int arg)</td><td>独占式释放同步状态</td></tr><tr><td>boolean releaseShared(int arg)</td><td>共享式释放同步状态</td></tr></tbody></table><p>上面列举了一堆方法，看似繁杂。但稍微理一下，就会发现上面诸多方法无非就两大类：一类是独占式获取和释放独占状态，另一类是共享式获取和释放同步状态。</p><h1><a id="_46"></a>源码</h1><h2><a id="_47"></a><a class="header-anchor" href="#线程队列节点结构">¶</a>线程队列节点结构</h2><p>在并发的情况下，AQS 会将未获取同步状态的线程将会封装成节点，并将其放入同步队列尾部。同步队列中的节点除了要保存线程，还要保存等待状态。不管是独占式还是共享式，在获取状态失败时都会用到节点类。所以这里我们要先看一下节点类的实现，为后面的源码分析进行简单铺垫。源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line"></span><br><span class="line">    /** 共享类型节点，标记节点在共享模式下等待 */</span><br><span class="line">    static final Node SHARED = new Node();</span><br><span class="line">    </span><br><span class="line">    /** 独占类型节点，标记节点在独占模式下等待 */</span><br><span class="line">    static final Node EXCLUSIVE = null;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 这里的状态，我的个人理解是，对下一个对象的操作行为</span><br><span class="line">     * 如果是CANCELLED 表示：当前线程已经释放锁</span><br><span class="line">     * 如果是0（默认状态） 表示：下一个线程正在运行中，不需要唤醒</span><br><span class="line">     * 如果是SIANAL、CONDITION、propagate 表示：线程正在等待中，需要前节点释放同步状态后，来唤醒</span><br><span class="line">     */</span><br><span class="line">    /** 当前线程取消竞争 */</span><br><span class="line">    static final int CANCELLED =  1;</span><br><span class="line">    </span><br><span class="line">    /** </span><br><span class="line">     * 后置节点等待被唤醒 </span><br><span class="line">     */</span><br><span class="line">    static final int SIGNAL    = -1;</span><br><span class="line">    </span><br><span class="line">    /** 条件等待。表明节点等待在 Condition 上 */</span><br><span class="line">    static final int CONDITION = -2;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 和共享有关  </span><br><span class="line">     */</span><br><span class="line">    static final int PROPAGATE = -3;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 等待状态，取值如下：</span><br><span class="line">     *   SIGNAL,</span><br><span class="line">     *   CANCELLED,</span><br><span class="line">     *   CONDITION,</span><br><span class="line">     *   PROPAGATE,</span><br><span class="line">     *   0</span><br><span class="line">     * </span><br><span class="line">     * 初始情况下，waitStatus = 0</span><br><span class="line">     */</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 前驱节点</span><br><span class="line">     */</span><br><span class="line">    volatile Node prev;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 后继节点</span><br><span class="line">     */</span><br><span class="line">    volatile Node next;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 对应的线程</span><br><span class="line">     */</span><br><span class="line">    volatile Thread thread;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 下一个等待节点，和condition 有关，用在 ConditionObject 中</span><br><span class="line">     */</span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断节点是否是共享节点</span><br><span class="line">     */</span><br><span class="line">    final boolean isShared() &#123;</span><br><span class="line">        return nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // CLH队列的头结点，其不包含线程信息，head永远为null</span><br><span class="line">    private transient volatile Node head;</span><br><span class="line">    </span><br><span class="line">    // CLH队列的尾节点，每次新加一个节点都会尾插到最后</span><br><span class="line">    private transient volatile Node tail;</span><br><span class="line">    </span><br><span class="line">    // 当前锁被占据的次数，因为可以被一个线程重复占据，所以其值可以大于0</span><br><span class="line">    // 没有线程占据，其值就是0</span><br><span class="line">    private volatile int state;</span><br><span class="line">    </span><br><span class="line">    // 当前运行的线程，也是占据锁的线程，注意和CLH中的线程无关</span><br><span class="line">    private transient Thread exclusiveOwnerThread; </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取前驱节点</span><br><span class="line">     */</span><br><span class="line">    final Node predecessor() throws NullPointerException &#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        if (p == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        else</span><br><span class="line">            return p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    // Used to establish initial head or SHARED marker</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** addWaiter 方法会调用该构造方法 */</span><br><span class="line">    Node(Thread thread, Node mode) &#123;</span><br><span class="line">        this.nextWaiter = mode;</span><br><span class="line">        this.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Condition 中会用到此构造方法 */</span><br><span class="line">    Node(Thread thread, int waitStatus) &#123; // Used by Condition</span><br><span class="line">        this.waitStatus = waitStatus;</span><br><span class="line">        this.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><a id="_51"></a><a class="header-anchor" href="#独占模式">¶</a>独占模式</h2><h3><a id="_52"></a><a class="header-anchor" href="#获取同步状态">¶</a>获取同步状态</h3><p>独占式获取同步状态时通过 acquire 进行的，下面来分析一下该方法的源码。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 该方法将会调用子类复写的 tryAcquire 方法获取同步状态，</span><br><span class="line"> * - 获取成功：直接返回</span><br><span class="line"> * - 获取失败：将线程封装在节点中，并将节点置于同步队列尾部，</span><br><span class="line"> *     通过自旋尝试获取同步状态。如果在有限次内仍无法获取同步状态，</span><br><span class="line"> *     该线程将会被 LockSupport.park 方法阻塞住，直到被前驱节点唤醒</span><br><span class="line"> * arg 是一个扩展字段，或者说是调用发的一个信号量    </span><br><span class="line"> */</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 向同步队列尾部添加一个节点 */</span><br><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">    // 尝试以快速方式将节点添加到队列尾部</span><br><span class="line">    // tail是当前队列的尾部</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    if (pred != null) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        // 使用cas(乐观锁), 保证队列的更新</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 快速插入节点失败，调用 enq 方法，不停的尝试插入节点</span><br><span class="line">    // 初始化 或者 等待cas结果的一致</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 通过 CAS + 自旋的方式插入节点到队尾</span><br><span class="line"> */</span><br><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        if (t == null) &#123; // Must initialize</span><br><span class="line">            // 设置头结点，初始情况下，头结点是一个空节点</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 将节点插入队列尾部。这里是先将新节点的前驱设为尾节点，之后在尝试将新节点设为尾节</span><br><span class="line">             * 点，最后再将原尾节点的后继节点指向新的尾节点。除了这种方式，我们还先设置尾节点，</span><br><span class="line">             * 之后再设置前驱和后继，即：</span><br><span class="line">             * </span><br><span class="line">             *    if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">             *        node.prev = t;</span><br><span class="line">             *        t.next = node;</span><br><span class="line">             *    &#125;</span><br><span class="line">             *    </span><br><span class="line">             * 但如果是这样做，会导致一个问题，即短时内，队列结构会遭到破坏。考虑这种情况，</span><br><span class="line">             * 某个线程在调用 compareAndSetTail(t, node)成功后，该线程被 CPU 切换了。此时</span><br><span class="line">             * 设置前驱和后继的代码还没带的及执行，但尾节点指针却设置成功，导致队列结构短时内会</span><br><span class="line">             * 出现如下情况：</span><br><span class="line">             *</span><br><span class="line">             *      +------+  prev +-----+       +-----+</span><br><span class="line">             * head |      | &lt;---- |     |       |     |  tail</span><br><span class="line">             *      |      | ----&gt; |     |       |     |</span><br><span class="line">             *      +------+ next  +-----+       +-----+</span><br><span class="line">             *</span><br><span class="line">             * tail 节点完全脱离了队列，这样导致一些队列遍历代码出错。如果先设置</span><br><span class="line">             * 前驱，在设置尾节点。及时线程被切换，队列结构短时可能如下：</span><br><span class="line">             *</span><br><span class="line">             *      +------+  prev +-----+ prev  +-----+</span><br><span class="line">             * head |      | &lt;---- |     | &lt;---- |     |  tail</span><br><span class="line">             *      |      | ----&gt; |     |       |     |</span><br><span class="line">             *      +------+ next  +-----+       +-----+</span><br><span class="line">             *      </span><br><span class="line">             * 这样并不会影响从后向前遍历，不会导致遍历逻辑出错。</span><br><span class="line">             * </span><br><span class="line">             * 参考：</span><br><span class="line">             *    https://www.cnblogs.com/micrari/p/6937995.html</span><br><span class="line">             */</span><br><span class="line">             // 这个代码细节写的very/very/very good， 很精妙</span><br><span class="line">            node.prev = t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 同步队列中的线程在此方法中以循环尝试获取同步状态，在有限次的尝试后，</span><br><span class="line"> * 若仍未获取锁，线程将会被阻塞，直至被前驱节点的线程唤醒。</span><br><span class="line"> */</span><br><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        // 循环获取同步状态</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            /*</span><br><span class="line">             * 前驱节点如果是头结点，表明前驱节点已经获取了同步状态。前驱节点释放同步状态后，</span><br><span class="line">             * 在不出异常的情况下， tryAcquire(arg) 应返回 true。此时节点就成功获取了同</span><br><span class="line">             * 步状态，并将自己设为头节点，原头节点出队。</span><br><span class="line">             */ </span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                // 成功获取同步状态，设置自己为头节点</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = null; // help GC</span><br><span class="line">                failed = false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            /*</span><br><span class="line">             * 如果获取同步状态失败，则根据条件判断是否应该阻塞自己。</span><br><span class="line">             * 如果不阻塞，CPU 就会处于忙等状态，这样会浪费 CPU 资源</span><br><span class="line">             */</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 如果在获取同步状态中出现异常，failed = true，cancelAcquire 方法会被执行。</span><br><span class="line">         * tryAcquire 需同步组件开发者覆写，难免不了会出现异常。</span><br><span class="line">         */</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 设置头节点 */</span><br><span class="line">private void setHead(Node node) &#123;</span><br><span class="line">    // 仅有一个线程可以成功获取同步状态，所以这里不需要进行同步控制</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = null;</span><br><span class="line">    node.prev = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 该方法主要用途是，当线程在获取同步状态失败时，根据前驱节点的等待状态，决定后续的动作。比如前驱</span><br><span class="line"> * 节点等待状态为 SIGNAL，表明当前节点线程应该被阻塞住了。不能老是尝试，避免 CPU 忙等。</span><br><span class="line"> *    —————————————————————————————————————————————————————————————————</span><br><span class="line"> *    | 前驱节点等待状态 |                   相应动作                     |</span><br><span class="line"> *    —————————————————————————————————————————————————————————————————</span><br><span class="line"> *    | SIGNAL         | 阻塞                                          |</span><br><span class="line"> *    | CANCELLED      | 向前遍历, 移除前面所有为该状态的节点               |</span><br><span class="line"> *    | waitStatus &lt; 0 | 将前驱节点状态设为 SIGNAL, 并再次尝试获取同步状态   |</span><br><span class="line"> *    —————————————————————————————————————————————————————————————————</span><br><span class="line"> */</span><br><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    int ws = pred.waitStatus;</span><br><span class="line">    /* </span><br><span class="line">     * 前驱节点等待状态为 SIGNAL，表示当前线程应该被阻塞。</span><br><span class="line">     * 线程阻塞后，会在前驱节点释放同步状态后被前驱节点线程唤醒</span><br><span class="line">     */</span><br><span class="line">    if (ws == Node.SIGNAL)</span><br><span class="line">        return true;</span><br><span class="line">        </span><br><span class="line">    /*</span><br><span class="line">     * 前驱节点等待状态为 CANCELLED，则以前驱节点为起点向前遍历，</span><br><span class="line">     * 移除其他等待状态为 CANCELLED 的节点。</span><br><span class="line">     */ </span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">        do &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 等待状态为 0 或 PROPAGATE，设置前驱节点等待状态为 SIGNAL，</span><br><span class="line">         * 并再次尝试获取同步状态。</span><br><span class="line">         */</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    // 调用 LockSupport.park 阻塞自己</span><br><span class="line">    LockSupport.park(this);</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 取消获取同步状态</span><br><span class="line"> */</span><br><span class="line">private void cancelAcquire(Node node) &#123;</span><br><span class="line">    if (node == null)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    node.thread = null;</span><br><span class="line"></span><br><span class="line">    // 前驱节点等待状态为 CANCELLED，则向前遍历并移除其他为该状态的节点</span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    while (pred.waitStatus &gt; 0)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    // 记录 pred 的后继节点，后面会用到</span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    // 将当前节点等待状态设为 CANCELLED</span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 如果当前节点是尾节点，则通过 CAS 设置前驱节点 prev 为尾节点。设置成功后，再利用 CAS 将 </span><br><span class="line">     * prev 的 next 引用置空，断开与后继节点的联系，完成清理工作。</span><br><span class="line">     */ </span><br><span class="line">    if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        /* </span><br><span class="line">         * 执行到这里，表明 pred 节点被成功设为了尾节点，这里通过 CAS 将 pred 节点的后继节点</span><br><span class="line">         * 设为 null。注意这里的 CAS 即使失败了，也没关系。失败了，表明 pred 的后继节点更新</span><br><span class="line">         * 了。pred 此时已经是尾节点了，若后继节点被更新，则是有新节点入队了。这种情况下，CAS </span><br><span class="line">         * 会失败，但失败不会影响同步队列的结构。</span><br><span class="line">         */</span><br><span class="line">        compareAndSetNext(pred, predNext, null);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int ws;</span><br><span class="line">        // 根据条件判断是唤醒后继节点，还是将前驱节点和后继节点连接到一起</span><br><span class="line">        if (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != null) &#123;</span><br><span class="line">            </span><br><span class="line">            Node next = node.next;</span><br><span class="line">            if (next != null &amp;&amp; next.waitStatus &lt;= 0)</span><br><span class="line">                /*</span><br><span class="line">                 * 这里使用 CAS 设置 pred 的 next，表明多个线程同时在取消，这里存在竞争。</span><br><span class="line">                 * 不过此处没针对 compareAndSetNext 方法失败后做一些处理，表明即使失败了也</span><br><span class="line">                 * 没关系。实际上，多个线程同时设置 pred 的 next 引用时，只要有一个能设置成</span><br><span class="line">                 * 功即可。</span><br><span class="line">                 */</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 唤醒后继节点对应的线程。这里简单讲一下为什么要唤醒后继线程，考虑下面一种情况：</span><br><span class="line">             *        head          node1         node2         tail</span><br><span class="line">             *        ws=0          ws=1          ws=-1         ws=0</span><br><span class="line">             *      +------+  prev +-----+  prev +-----+  prev +-----+</span><br><span class="line">             *      |      | &lt;---- |     | &lt;---- |     | &lt;---- |     |  </span><br><span class="line">             *      |      | ----&gt; |     | ----&gt; |     | ----&gt; |     |</span><br><span class="line">             *      +------+  next +-----+  next +-----+  next +-----+</span><br><span class="line">             *      </span><br><span class="line">             * 头结点初始状态为 0，node1、node2 和 tail 节点依次入队。node1 自旋过程中调用 </span><br><span class="line">             * tryAcquire 出现异常，进入 cancelAcquire。head 节点此时等待状态仍然是 0，它</span><br><span class="line">             * 会认为后继节点还在运行中，所它在释放同步状态后，不会去唤醒后继等待状态为非取消的</span><br><span class="line">             * 节点 node2。如果 node1 再不唤醒 node2 的线程，该线程面临无法被唤醒的情况。此</span><br><span class="line">             * 时，整个同步队列就回全部阻塞住。</span><br><span class="line">             */</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; // help GC</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    int ws = node.waitStatus;</span><br><span class="line">    /*</span><br><span class="line">     * 通过 CAS 将等待状态设为 0，让后继节点线程多一次</span><br><span class="line">     * 尝试获取同步状态的机会</span><br><span class="line">     */</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s = null;</span><br><span class="line">       /*</span><br><span class="line">        * 这里如果 s == null 处理，是不是表明 node 是尾节点？答案是不一定。原因之前在分析 </span><br><span class="line">        * enq 方法时说过。这里再啰嗦一遍，新节点入队时，队列瞬时结构可能如下：</span><br><span class="line">        *                      node1         node2</span><br><span class="line">        *      +------+  prev +-----+ prev  +-----+</span><br><span class="line">        * head |      | &lt;---- |     | &lt;---- |     |  tail</span><br><span class="line">        *      |      | ----&gt; |     |       |     |</span><br><span class="line">        *      +------+ next  +-----+       +-----+</span><br><span class="line">        * </span><br><span class="line">        * node2 节点为新入队节点，此时 tail 已经指向了它，但 node1 后继引用还未设置。</span><br><span class="line">        * 这里 node1 就是 node 参数，s = node1.next = null，但此时 node1 并不是尾</span><br><span class="line">        * 节点。所以这里不能从前向后遍历同步队列，应该从后向前。</span><br><span class="line">        */</span><br><span class="line">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            if (t.waitStatus &lt;= 0)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    if (s != null)</span><br><span class="line">        // 唤醒 node 的后继节点线程</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，独占式获取同步状态的分析就讲完了。如果仅分析获取同步状态的大致流程，那么这个流程并不难。但若深入到细节之中，还是需要思考思考。这里对独占式获取同步状态的大致流程做个总结，如下：</p><ul><li>调用 tryAcquire 方法尝试获取同步状态</li><li>获取成功，直接返回</li><li>获取失败，将线程封装到节点中，并将节点入队</li><li>入队节点在 acquireQueued 方法中自旋获取同步状态</li><li>若节点的前驱节点是头节点，则再次调用 tryAcquire 尝试获取同步状态</li><li>获取成功，当前节点将自己设为头节点并返回</li><li>获取失败，可能再次尝试，也可能会被阻塞。这里简单认为会被阻塞。</li></ul><p>上面的步骤对应下面的流程图：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191024174549.png" alt></p><h2><a id="_68"></a><a class="header-anchor" href="#释放同步状态">¶</a>释放同步状态</h2><p>相对于获取同步状态，释放同步状态的过程则要简单的多，这里简单罗列一下步骤：</p><ul><li>调用 tryRelease(arg) 尝试释放同步状态</li><li>根据条件判断是否应该唤醒后继线程</li></ul><p>就两个步骤，下面看一下源码分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        /*</span><br><span class="line">         * 这里简单列举条件分支的可能性，如下：</span><br><span class="line">         * 1. head = null</span><br><span class="line">         *     head 还未初始化。初始情况下，head = null，当第一个节点入队后，head 会被初始</span><br><span class="line">         *     为一个虚拟（dummy）节点。这里，如果还没节点入队就调用 release 释放同步状态，</span><br><span class="line">         *     就会出现 h = null 的情况。</span><br><span class="line">         *     </span><br><span class="line">         * 2. head != null &amp;&amp; waitStatus = 0</span><br><span class="line">         *     表明后继节点对应的线程仍在运行中，不需要唤醒</span><br><span class="line">         * </span><br><span class="line">         * 3. head != null &amp;&amp; waitStatus &lt; 0</span><br><span class="line">         *     后继节点对应的线程可能被阻塞了，需要唤醒 </span><br><span class="line">         */</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            // 唤醒后继节点，上面分析过了，这里不再赘述</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><a id="_77"></a><a class="header-anchor" href="#共享模式">¶</a>共享模式</h2><p>与独占模式不同，共享模式下，同一时刻会有多个线程获取共享同步状态。共享模式是实现读写锁中的读锁、CountDownLatch 和 Semaphore 等同步组件的基础，搞懂了，再去理解一些共享同步组件就不难了。</p><h3><a id="_79"></a><a class="header-anchor" href="#获取同步状态-v2">¶</a>获取同步状态</h3><p>共享类型的节点获取共享同步状态后，如果后继节点也是共享类型节点，当前节点则会唤醒后继节点。这样，多个节点线程即可同时获取共享同步状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    // 尝试获取共享同步状态，tryAcquireShared 返回的是整型</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">    final Node node = addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        // 这里和前面一样，也是通过有限次自旋的方式获取同步状态</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            /*</span><br><span class="line">             * 前驱是头结点，其类型可能是 EXCLUSIVE，也可能是 SHARED.</span><br><span class="line">             * 如果是 EXCLUSIVE，线程无法获取共享同步状态。</span><br><span class="line">             * 如果是 SHARED，线程则可获取共享同步状态。</span><br><span class="line">             * 能不能获取共享同步状态要看 tryAcquireShared 具体的实现。比如多个线程竞争读写</span><br><span class="line">             * 锁的中的读锁时，均能成功获取读锁。但多个线程同时竞争信号量时，可能就会有一部分线</span><br><span class="line">             * 程因无法竞争到信号量资源而阻塞。</span><br><span class="line">             */ </span><br><span class="line">            if (p == head) &#123;</span><br><span class="line">                // 尝试获取共享同步状态</span><br><span class="line">                // 获取失败：负数</span><br><span class="line">                // 成功：0，但是后续节点无法获取同步状态</span><br><span class="line">                // 成功：&gt;0 , 同时后续节点可以获取同步状态，但是后续线程必须检查状态的可用性</span><br><span class="line">                int r = tryAcquireShared(arg);</span><br><span class="line">                if (r &gt;= 0) &#123;</span><br><span class="line">                    // 设置头结点，如果后继节点是共享类型，唤醒后继节点</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    if (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">/**</span><br><span class="line"> * 这个方法做了两件事情：</span><br><span class="line"> * 1. 设置自身为头结点</span><br><span class="line"> * 2. 根据条件判断是否要唤醒后继节点</span><br><span class="line"> */ </span><br><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">    Node h = head;</span><br><span class="line">    // 设置头结点</span><br><span class="line">    setHead(node);</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     * 这个条件分支由 propagate &gt; 0 和 h.waitStatus &lt; 0 两部分组成。</span><br><span class="line">     * h.waitStatus &lt; 0 时，waitStatus = SIGNAL 或 PROPAGATE。这里仅依赖</span><br><span class="line">     * 条件 propagate &gt; 0 判断是否唤醒后继节点是不充分的，至于原因请参考下面</span><br><span class="line">     */</span><br><span class="line">    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</span><br><span class="line">        (h = head) == null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        /*</span><br><span class="line">         * 节点 s 如果是共享类型节点，则应该唤醒该节点</span><br><span class="line">         * 至于 s == null 的情况前面分析过，这里不在赘述。</span><br><span class="line">         */ </span><br><span class="line">        if (s == null || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 该方法用于在 acquires/releases 存在竞争的情况下，确保唤醒动作向后传播。</span><br><span class="line"> */ </span><br><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    /*</span><br><span class="line">     * 下面的循环在 head 节点存在后继节点的情况下，做了两件事情：</span><br><span class="line">     * 1. 如果 head 节点等待状态为 SIGNAL，则将 head 节点状态设为 0，并唤醒后继节点</span><br><span class="line">     * 2. 如果 head 节点等待状态为 0，则将 head 节点状态设为 PROPAGATE，保证唤醒能够正</span><br><span class="line">     *    常传播下去。关于 PROPAGATE 状态的细节分析，后面会讲到。</span><br><span class="line">     */</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">            int ws = h.waitStatus;</span><br><span class="line">            if (ws == Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            // loop to recheck cases</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            /* </span><br><span class="line">             * ws = 0 的情况下，这里要尝试将状态从 0 设为 PROPAGATE，保证唤醒向后</span><br><span class="line">             * 传播。setHeadAndPropagate 在读到 h.waitStatus &lt; 0 时，可以继续唤醒</span><br><span class="line">             * 后面的节点。</span><br><span class="line">             */</span><br><span class="line">            else if (ws == 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                // loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        if (h == head)                   // loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，共享模式下获取同步状态的逻辑就分析完了，不过我这里只做了简单分析。相对于独占式获取同步状态，共享式的情况更为复杂。独占模式下，只有一个节点线程可以成功获取同步状态，也只有获取已同步状态节点线程才可以释放同步状态。但在共享模式下，多个共享节点线程可以同时获得同步状态，在一些线程获取同步状态的同时，可能还会有另外一些线程正在释放同步状态。所以，共享模式更为复杂。这里我的脑力跟不上了，没法面面俱到的分析。<br>最后说一下共享模式下获取同步状态的大致流程，如下：</p><ul><li>获取共享同步状态</li><li>若获取失败，则生成节点，并入队</li><li>如果前驱为头结点，再次尝试获取共享同步状态</li><li>获取成功则将自己设为头结点，如果后继节点是共享类型的，则唤醒</li><li>若失败，将节点状态设为 SIGNAL，再次尝试。若再次失败，线程进入等待状态</li></ul><h2><a id="_90"></a><a class="header-anchor" href="#释放同步状态-v2">¶</a>释放同步状态</h2><p>释放共享状态主要逻辑在 doReleaseShared 中，doReleaseShared 上节已经分析过，这里就不赘述了。共享节点线程在获取同步状态和释放同步状态时都会调用 doReleaseShared，所以 doReleaseShared 是多线程竞争集中的地方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><a id="PROPAGATE__94"></a>PROPAGATE 状态存在的意义</h1><p>AQS 的节点有几种不同的状态，PROPAGATE 字面意义，即向后传播唤醒动作。<br>那么就有两个问题：</p><ul><li>PROPAGATE 状态用在哪里，以及怎样向后传播唤醒动作的？</li><li>引入 PROPAGATE 状态是为了解决什么问题？</li></ul><h2><a id="_PROPAGATE__100"></a><a class="header-anchor" href="#利用-propagate-传播唤醒动作">¶</a>利用 PROPAGATE 传播唤醒动作</h2><p>PROPAGATE 状态是用来传播唤醒动作的，那么它是在哪里进行传播的呢？答案是在setHeadAndPropagate方法中，这里再来看看 setHeadAndPropagate 方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">    Node h = head;</span><br><span class="line">    setHead(node);</span><br><span class="line">    </span><br><span class="line">    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</span><br><span class="line">        (h = head) == null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        if (s == null || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意看 setHeadAndPropagate 方法中那个长长的判断语句，其中有一个条件是h.waitStatus &lt; 0，当 h.waitStatus = SIGNAL(-1) 或 PROPAGATE(-3) 是，这个条件就会成立。那么 PROPAGATE 状态是在何时被设置的呢？答案是在doReleaseShared方法中，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">            int ws = h.waitStatus;</span><br><span class="line">            if (ws == Node.SIGNAL) &#123;...&#125;</span><br><span class="line">            </span><br><span class="line">            // 如果 ws = 0，则将 h 状态设为 PROPAGATE</span><br><span class="line">            else if (ws == 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                // loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再回到 setHeadAndPropagate 的实现，该方法既然引入了h.waitStatus &lt; 0这个条件，就意味着仅靠条件propagate &gt; 0判断是否唤醒后继节点线程的机制是不充分的。为啥?</p><h2><a id="_PROPAGATE__106"></a><a class="header-anchor" href="#引入-propagate-所解决的问题">¶</a>引入 PROPAGATE 所解决的问题</h2><p>PROPAGATE 的引入是为了解决一个 BUG – <a href="https://bugs.java.com/view_bug.do?bug_id=6801020" target="_blank" rel="noopener">JDK-6801020</a>，复现这个 BUG 的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line">public class TestSemaphore &#123;</span><br><span class="line"></span><br><span class="line">   private static Semaphore sem = new Semaphore(0);</span><br><span class="line"></span><br><span class="line">   private static class Thread1 extends Thread &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void run() &#123;</span><br><span class="line">           sem.acquireUninterruptibly();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static class Thread2 extends Thread &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void run() &#123;</span><br><span class="line">           sem.release();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">       for (int i = 0; i &lt; 10000000; i++) &#123;</span><br><span class="line">           Thread t1 = new Thread1();</span><br><span class="line">           Thread t2 = new Thread1();</span><br><span class="line">           Thread t3 = new Thread2();</span><br><span class="line">           Thread t4 = new Thread2();</span><br><span class="line">           t1.start();</span><br><span class="line">           t2.start();</span><br><span class="line">           t3.start();</span><br><span class="line">           t4.start();</span><br><span class="line">           t1.join();</span><br><span class="line">           t2.join();</span><br><span class="line">           t3.join();</span><br><span class="line">           t4.join();</span><br><span class="line">           System.out.println(i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 BUG 的描述消息可知 JDK 6u11,6u17 两个版本受到影响。那么，接下来再来看看引起这个 BUG 的代码 – JDK 6u17 中 setHeadAndPropagate 和 releaseShared 两个方法源码，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">    setHead(node);</span><br><span class="line">    if (propagate &gt; 0 &amp;&amp; node.waitStatus != 0) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * Don&apos;t bother fully figuring out successor.  If it</span><br><span class="line">         * looks null, call unparkSuccessor anyway to be safe.</span><br><span class="line">         */</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        if (s == null || s.isShared())</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 和 release 方法的源码基本一样</span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来简单说明 TestSemaphore 这个类的逻辑。这个类持有一个数值为 0 的信号量对象，并创建了4个线程，线程 t1 和 t2 用于获取信号量，t3 和 t4 则是调用 release() 方法释放信号量。在一般情况下，TestSemaphore 这个类的代码都可以正常执行。但当有极端情况出现时，可能会导致同步队列挂掉。这里演绎一下这个极端情况，考虑某次循环时，队列结构如下：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191024181912.png" alt></p><ul><li>时刻1：线程 t3 调用 unparkSuccessor 方法，head 节点状态由 SIGNAL(-1) 变为0，并唤醒线程 t1。此时信号量数值为1。</li><li>时刻2：线程 t1 恢复运行，t1 调用 Semaphore.NonfairSync 的 tryAcquireShared，返回0。然后线程 t1 被切换，暂停运行。</li><li>时刻3：线程 t4 调用 releaseShared 方法，因 head 的状态为0，所以 t4 不会调用 unparkSuccessor 方法。</li><li>时刻4：线程 t1 恢复运行，t1 成功获取信号量，调用 setHeadAndPropagate。但因为 propagate = 0，线程 t1 无法调用 unparkSuccessor 唤醒线程 t2，t2 面临无线程唤醒的情况。因为 t2 无法退出等待状态，所以 t2.join 会阻塞主线程，导致程序挂住。</li></ul><p>下面再来看一下修复 BUG 后的代码，根据 BUG 详情页显示，该 BUG 在 JDK 1.7 中被修复。这里找一个 JDK 7 较早版本（JDK 7u10）的代码看一下，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">    Node h = head; // Record old head for check below</span><br><span class="line">    setHead(node);</span><br><span class="line">    </span><br><span class="line">    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        if (s == null || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">            int ws = h.waitStatus;</span><br><span class="line">            if (ws == Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            // loop to recheck cases</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws == 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                // loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        if (h == head)                   // loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在按照上面的代码演绎一下逻辑，如下：</p><ul><li>时刻1：线程 t3 调用 unparkSuccessor 方法，head 节点状态由 SIGNAL(-1) 变为0，并唤醒线程t1。此时信号量数值为1。</li><li>时刻2：线程 t1 恢复运行，t1 调用 Semaphore.NonfairSync 的 tryAcquireShared，返回0。然后线程 t1 被切换，暂停运行。</li><li>时刻3：线程 t4 调用 releaseShared 方法，检测到h.waitStatus = 0，t4 将头节点等待状态由0设为PROPAGATE(-3)。</li><li>时刻4：线程 t1 恢复运行，t1 成功获取信号量，调用 setHeadAndPropagate。因 propagate = 0，propagate &gt; 0 条件不满足。而 h.waitStatus = PROPAGATE(-3)，所以条件h.waitStatus &lt; 0成立。进而，线程 t1 可以唤醒线程 t2，完成唤醒动作的传播。</li></ul><h3><a id="PROPAGATE__128"></a><a class="header-anchor" href="#propagate-状态用在哪里-以及怎样向后传播唤醒动作的？">¶</a>PROPAGATE 状态用在哪里，以及怎样向后传播唤醒动作的？</h3><p>PROPAGATE 状态用在 setHeadAndPropagate。当头节点状态被设为 PROPAGATE 后，后继节点成为新的头结点后。若 propagate &gt; 0 条件不成立，则根据条件h.waitStatus &lt; 0成立与否，来决定是否唤醒后继节点，即向后传播唤醒动作。</p><h3><a id="_PROPAGATE__131"></a><a class="header-anchor" href="#引入-propagate-状态是为了解决什么问题？">¶</a>引入 PROPAGATE 状态是为了解决什么问题？</h3><p>引入 PROPAGATE 状态是为了解决并发释放信号量所导致部分请求信号量的线程无法被唤醒的问题。</p></div><div id="wechat_subscriber" style="display:block;padding:10px 0;margin:20px auto;width:100%;text-align:center"><img id="wechat_subscriber_qcode" src="/blog/uploads/wechat-qcode.png" alt="Jeff-Eric wechat" style="width:200px;max-width:100%"><div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Jeff-Eric</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://jeff-eric.github.com/blog/2019/10/24/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/" title="AbstractQueuedSynchronizer 原理分析 - 独占&#x2F;共享模式">https:&#x2F;&#x2F;jeff-eric.github.com&#x2F;blog&#x2F;2019&#x2F;10&#x2F;24&#x2F;AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F&#x2F;</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank">&lt;i class=&quot;fa fa-fw fa-creative-commons&quot;&gt;&lt;&#x2F;i&gt;BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/blog/tags/%E7%BA%BF%E7%A8%8B/" rel="tag"># 线程</a></div><div class="post-widgets"><div class="social_share"><div id="needsharebutton-postbottom"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/blog/2019/10/24/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F/" rel="next" title="AbstractQueuedSynchronizer 原理分析 - 独占模式"><i class="fa fa-chevron-left"></i> AbstractQueuedSynchronizer 原理分析 - 独占模式</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"></div></div></footer></div></article></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/blog/uploads/avatar.jpg" alt="Jeff-Eric"><p class="site-author-name" itemprop="name">Jeff-Eric</p><div class="site-description motion-element" itemprop="description"></div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/blog/archives/%20%7C%7C%20archive"><span class="site-state-item-count">42</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/blog/categories/%20%7C%7C%20th"><span class="site-state-item-count">12</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/blog/tags/%20%7C%7C%20tags"><span class="site-state-item-count">28</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/jeff-eric" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;jeff-eric" rel="noopener" target="_blank">&lt;i class=&quot;fa fa-fw fa-github&quot;&gt;&lt;&#x2F;i&gt;GitHub</a> </span><span class="links-of-author-item"><a href="/blog/jphoebe4086824@gmail.com" title="E-Mail &amp;rarr; jphoebe4086824@gmail.com">&lt;i class=&quot;fa fa-fw fa-envelope&quot;&gt;&lt;&#x2F;i&gt;E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank">&lt;img src=&quot;&#x2F;blog&#x2F;images&#x2F;cc-by-nc-sa.svg&quot; alt=&quot;Creative Commons&quot;&#x2F;&gt;</a></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">2.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">3.</span> <span class="nav-text">常用方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">4.</span> <span class="nav-text">源码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">4.1.</span> <span class="nav-text">¶线程队列节点结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">4.2.</span> <span class="nav-text">¶独占模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">4.2.1.</span> <span class="nav-text">¶获取同步状态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">4.3.</span> <span class="nav-text">¶释放同步状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">4.4.</span> <span class="nav-text">¶共享模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">4.4.1.</span> <span class="nav-text">¶获取同步状态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">4.5.</span> <span class="nav-text">¶释放同步状态</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">5.</span> <span class="nav-text">PROPAGATE 状态存在的意义</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">5.1.</span> <span class="nav-text">¶利用 PROPAGATE 传播唤醒动作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">5.2.</span> <span class="nav-text">¶引入 PROPAGATE 所解决的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">5.2.1.</span> <span class="nav-text">¶PROPAGATE 状态用在哪里，以及怎样向后传播唤醒动作的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">5.2.2.</span> <span class="nav-text">¶引入 PROPAGATE 状态是为了解决什么问题？</span></a></li></ol></li></ol></li></ol></div></div></div><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Jeff-Eric</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0</div><span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.0.1</div></div></footer><div id="needsharebutton-float"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script><script id="ribbon" size="300" alpha="0.6" zindex="-1" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@2/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/npm/fastclick@1/lib/fastclick.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery-lazyload@1/jquery.lazyload.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three-waves.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_lines.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_sphere.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-reading-progress@1/reading_progress.min.js"></script><script src="/blog/js/src/utils.js?v=7.0.1"></script><script src="/blog/js/src/motion.js?v=7.0.1"></script><script src="/blog/js/src/affix.js?v=7.0.1"></script><script src="/blog/js/src/schemes/pisces.js?v=7.0.1"></script><script src="/blog/js/src/scrollspy.js?v=7.0.1"></script><script src="/blog/js/src/post-details.js?v=7.0.1"></script><script src="/blog/js/src/next-boot.js?v=7.0.1"></script><script src="/blog/js/src/js.cookie.js?v=7.0.1"></script><script src="/blog/js/src/scroll-cookie.js?v=7.0.1"></script><script src="//cdn.jsdelivr.net/npm/leancloud-storage@3/dist/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js"></script><script>var GUEST=["nick","mail","link"],guest="nick,mail,link";guest=guest.split(",").filter(function(e){return GUEST.indexOf(e)>-1}),new Valine({el:"#comments",verify:!0,notify:!1,appId:"MKGyMx7EafphCr9hAbMPAwAc-gzGzoHsz",appKey:"4SB8MPoE51bFPHDoKtPM8vLG",placeholder:"Just go go",avatar:"mm",meta:guest,pageSize:"10",visitor:!0})</script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var e=$("#local-search-input");e.attr("autocapitalize","none"),e.attr("autocorrect","off"),e.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/blog/"+search_path,onPopupClose=function(e){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(e,t,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:e,dataType:isXml?"xml":"json",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,r=document.getElementById(t),s=document.getElementById(o),a=function(){var e=r.value.trim().toLowerCase(),t=e.split(/[\s\-]+/);t.length>1&&t.push(e);var o=[];if(e.length>0&&n.forEach(function(n){function r(t,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===e&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(e,t){var o="",n=t.start;return t.hits.forEach(function(t){o+=e.substring(n,t.position);var r=t.position+t.length;o+='<b class="search-keyword">'+e.substring(t.position,r)+"</b>",n=r}),o+=e.substring(n,t.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url).replace(/\/{2,}/g,"/"),d=[],g=[];if(""!=l&&(t.forEach(function(e){function t(e,t,o){var n=e.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(t=t.toLowerCase(),e=e.toLowerCase());(s=t.indexOf(e,r))>-1;)a.push({position:s,word:e}),r=s+n;return a}d=d.concat(t(e,h,!1)),g=g.concat(t(e,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(e){e.sort(function(e,t){return t.position!==e.position?t.position-e.position:e.word.length-t.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hits.length!==t.hits.length?t.hits.length-e.hits.length:e.start-t.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(e){b+="<a href='"+f+'\'><p class="search-result">'+s(p,e)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===t.length&&""===t[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x"></i></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>';else{o.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hitCount!==t.hitCount?t.hitCount-e.hitCount:t.id-e.id});var a='<ul class="search-result-list">';o.forEach(function(e){a+=e.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(e){e.stopPropagation()}),$(document).on("keyup",function(e){var t=27===e.which&&$(".search-popup").is(":visible");t&&onPopupClose()})</script><script src="https://www.gstatic.com/firebasejs/4.6.0/firebase.js"></script><script src="https://www.gstatic.com/firebasejs/4.6.0/firebase-firestore.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/bluebird/3.5.1/bluebird.core.min.js"></script><script>!function(){function getCount(t,e){return t.get().then(function(a){var n;return a.exists?(n=a.data().count,e&&(window.localStorage&&window.localStorage.getItem(title)||(t.set({count:n+1}),n++))):e?(t.set({count:1}),n=1):n=0,window.localStorage&&e&&localStorage.setItem(title,!0),n})}function appendCountTo(t){return function(e){$(t).append($("<span>").addClass("post-visitors-count").append($("<span>").addClass("post-meta-divider").text("|")).append($("<span>").addClass("post-meta-item-icon").append($("<i>").addClass("fa fa-users"))).append($("<span>").text("阅读次数 "+e)))}}firebase.initializeApp({apiKey:"AIzaSyD-BIMnFQcvrv1utthoP5z5shcYP8JMKmY",projectId:"blog-6cbe0"});var db=firebase.firestore(),articles=db.collection("articles"),isPost="AbstractQueuedSynchronizer 原理分析 - 独占/共享模式".length>0,isArchive=!1,isCategory="".length>0,isTag="".length>0;if(isPost){var title="AbstractQueuedSynchronizer 原理分析 - 独占/共享模式",doc=articles.doc(title);getCount(doc,!0).then(appendCountTo($(".post-meta")))}else if(!isArchive&&!isCategory&&!isTag){var titles=[],postsstr="";eval(postsstr);var promises=titles.map(function(t){return articles.doc(t)}).map(function(t){return getCount(t)});Promise.all(promises).then(function(t){var e=$(".post-meta");t.forEach(function(t,a){appendCountTo(e[a])(t)})})}}()</script><style>.pdfobject-container{position:relative;overflow:auto;width:100%}</style><script>$("body").find("div.pdf").length&&$.ajax({type:"GET",url:"//cdn.jsdelivr.net/npm/pdfobject@2.1.1/pdfobject.min.js",dataType:"script",cache:!0,success:function(){$("body").find("div.pdf").each(function(e,t){PDFObject.embed($(t).attr("target"),$(t),{pdfOpenParams:{navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"},PDFJS_URL:"/lib/pdf/web/viewer.html",height:$(t).attr("height")||"500px"})})}})</script><script>$("body").find("pre.mermaid").length&&$.ajax({type:"GET",url:"//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js",dataType:"script",cache:!0,success:function(){mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})}})</script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script><script>pbOptions={},pbOptions.iconStyle="box",pbOptions.boxForm="horizontal",pbOptions.position="bottomCenter",pbOptions.networks="Weibo,Wechat,Douban,QQZone,Twitter,Facebook",new needShareButton("#needsharebutton-postbottom",pbOptions),flOptions={},flOptions.iconStyle="box",flOptions.boxForm="horizontal",flOptions.position="middleRight",flOptions.networks="Weibo,Wechat,Douban,QQZone,Twitter,Facebook",new needShareButton("#needsharebutton-float",flOptions)</script><script src="//cdn.jsdelivr.net/npm/pangu@3/dist/browser/pangu.min.js"></script><script>pangu.spacingPage()</script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@1/bookmark.min.js"></script><script>bookmark.scrollToMark("auto","#更多")</script><style>.copy-btn{display:inline-block;padding:6px 12px;font-size:13px;font-weight:700;line-height:20px;color:#333;white-space:nowrap;vertical-align:middle;cursor:pointer;background-color:#eee;background-image:linear-gradient(#fcfcfc,#eee);border:1px solid #d5d5d5;border-radius:3px;user-select:none;outline:0}.highlight-wrap .copy-btn{transition:opacity .3s ease-in-out;opacity:0;padding:2px 6px;position:absolute;right:4px;top:8px}.highlight-wrap .copy-btn:focus,.highlight-wrap:hover .copy-btn{opacity:1}.highlight-wrap{position:relative}</style><script>$(".highlight").each(function(t,e){var n=$("<div>").addClass("highlight-wrap");$(e).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(t){var e=$(this).parent().find(".code").find(".line").map(function(t,e){return $(e).text()}).toArray().join("\n"),n=document.createElement("textarea"),o=window.pageYOffset||document.documentElement.scrollTop;n.style.top=o+"px",n.style.position="absolute",n.style.opacity="0",n.readOnly=!0,n.value=e,document.body.appendChild(n),n.select(),n.setSelectionRange(0,e.length),n.readOnly=!1;var a=document.execCommand("copy");a?$(this).text("复制成功"):$(this).text("复制失败"),n.blur(),$(this).blur()})).on("mouseleave",function(t){var e=$(this).find(".copy-btn");setTimeout(function(){e.text("复制")},300)}).append(e)})</script></body></html><!-- rebuild by neat -->