<!-- build time:Tue Nov 26 2019 14:32:22 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-CN,zh-HK,zh-TW,en,default"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/han-css@3/dist/han.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css"><link rel="stylesheet" href="/blog/css/main.css?v=7.0.1"><link rel="apple-touch-icon" sizes="180x180" href="/blog/uploads/avatar.jpg?v=7.0.1"><link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/avatar.jpg?v=7.0.1"><link rel="icon" type="image/png" sizes="16x16" href="/blog/blog/uploads/avatar.jpg?v=7.0.1"><link rel="mask-icon" href="/blog/uploads/avatar.jpg?v=7.0.1" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/blog/",scheme:"Gemini",version:"7.0.1",sidebar:{position:"left",display:"always",offset:12,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!0,fancybox:!0,fastclick:!0,lazyload:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="锁的相关概念介绍¶可重入锁如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新"><meta name="keywords" content="synchronized,Lock,锁"><meta property="og:type" content="article"><meta property="og:title" content="synchronized 和 Lock"><meta property="og:url" content="https:&#x2F;&#x2F;jeff-eric.github.com&#x2F;blog&#x2F;2019&#x2F;10&#x2F;22&#x2F;synchronized-%E5%92%8C-Lock&#x2F;index.html"><meta property="og:site_name" content="纯天然绿色学渣"><meta property="og:description" content="锁的相关概念介绍¶可重入锁如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;UTOOLS1571752755472.png"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;UTOOLS1571752769518.png"><meta property="og:updated_time" content="2019-10-24T01:40:50.726Z"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;UTOOLS1571752755472.png"><link rel="canonical" href="https://jeff-eric.github.com/blog/2019/10/22/synchronized-和-Lock/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>synchronized 和 Lock | 纯天然绿色学渣</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?bb5d4f8207d7c2bd1aa936180430bbaa";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/blog/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">纯天然绿色学渣</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-home&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;首页</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-tags&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;标签&lt;span class=&quot;badge&quot;&gt;28&lt;&#x2F;span&gt;</a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-th&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;分类&lt;span class=&quot;badge&quot;&gt;12&lt;&#x2F;span&gt;</a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-archive&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;归档&lt;span class=&quot;badge&quot;&gt;42&lt;&#x2F;span&gt;</a></li><li class="menu-item menu-item-tools"><a href="/blog/tools/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-tree&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;工具</a></li><li class="menu-item menu-item-search"><a href="javascript:;" target="_blank" rel="noopener" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><div class="reading-progress-bar"></div><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jeff-eric.github.com/blog/blog/2019/10/22/synchronized-%E5%92%8C-Lock/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jeff-Eric"><meta itemprop="description" content=""><meta itemprop="image" content="/blog/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="纯天然绿色学渣"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">synchronized 和 Lock</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-22 18:51:56" itemprop="dateCreated datePublished" datetime="2019-10-22T18:51:56+08:00">2019-10-22</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-10-24 09:40:50" itemprop="dateModified" datetime="2019-10-24T09:40:50+08:00">2019-10-24</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/blog/2019/10/22/synchronized-%E5%92%8C-Lock/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/2019/10/22/synchronized-%E5%92%8C-Lock/" itemprop="commentCount"></span> </a></span><span id="/blog/2019/10/22/synchronized-%E5%92%8C-Lock/" class="leancloud_visitors" data-flag-title="synchronized 和 Lock"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body han-init-context" itemprop="articleBody"><h1><a id="_1"></a>锁的相关概念介绍</h1><h2><a id="_2"></a><a class="header-anchor" href="#可重入锁">¶</a>可重入锁</h2><p>如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。</p><p>看下面这段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * LockTest class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2017/09/22</span><br><span class="line"> */</span><br><span class="line">public class LockTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        final LockTest test = new LockTest();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            test.get();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            test.get();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void get() &#123;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void method2() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>你认为结果会是怎样的呢，会不会造成死锁呢？</b></p><p>上述代码中的两个方法method1和method2都用synchronized修饰了，假如某一时刻，线程A执行到了method1，此时线程A获取了这个对象的锁，而由于method2也是synchronized方法，假如synchronized不具备可重入性，此时线程A需要重新申请锁。但是这就会造成一个问题，因为线程A已经持有了该对象的锁，而又在申请获取该对象的锁，这样就会线程A一直等待永远不会获取到的锁。<br>而由于synchronized和Lock都具备可重入性，所以不会发生上述现象</p><h2><a id="_12"></a><a class="header-anchor" href="#可中断锁">¶</a>可中断锁</h2><p>可中断锁：顾名思义，就是可以相应中断的锁。<br>在Java中，synchronized就不是可中断锁，而Lock是可中断锁。<br>如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。<br>在前面演示lockInterruptibly()的用法时已经体现了Lock的可中断性。</p><h2><a id="_18"></a><a class="header-anchor" href="#公平锁">¶</a>公平锁</h2><p>公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。<br>非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。<br>在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。<br>而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/UTOOLS1571752755472.png" alt><br>在ReentrantLock中定义了2个静态内部类，一个是NotFairSync，一个是FairSync，分别用来实现非公平锁和公平锁。<br>我们可以在创建ReentrantLock对象时，通过以下方式来设置锁的公平性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = new ReentrantLock(true);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/UTOOLS1571752769518.png" alt><br>另外在ReentrantLock类中定义了很多方法，比如：</p><ul><li>isFair() //判断锁是否是公平锁</li><li>isLocked() //判断锁是否被任何线程获取了</li><li>isHeldByCurrentThread() //判断锁是否被当前线程获取了</li><li>hasQueuedThreads() //判断是否有线程在等待该锁</li></ul><p>在ReentrantReadWriteLock中也有类似的方法，同样也可以设置为公平锁和非公平锁。不过要记住，ReentrantReadWriteLock并未实现Lock接口，它实现的是ReadWriteLock接口。</p><h2><a id="_36"></a><a class="header-anchor" href="#读写锁">¶</a>读写锁</h2><p>读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。<br>正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。<br>ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。<br>可以通过readLock()获取读锁，通过writeLock()获取写锁。</p><h1><a id="synchronized_43"></a>synchronized</h1><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，只有一个线程可以执行某个方法或某个代码块，同时synchronized可以保证一个线程的变化可见（可见性），即可以代替volatile，保证共享变量的内存可见性</p><h4><a id="_45"></a><a class="header-anchor" href="#常见的几种应用是：">¶</a>常见的几种应用是：</h4><ul><li>synchronized(this)、synchronize方法</li><li>synchronized(class)、synchronized静态同步方法</li><li>synchronized(Object)</li></ul><h3><a id="synchronizedthissynchronize_50"></a><a class="header-anchor" href="#synchronized-this-synchronize方法">¶</a>synchronized(this)、synchronize方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Lock1 class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2017/09/22</span><br><span class="line"> */</span><br><span class="line">public class SynchronizedTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        SynchronizedTest synchronizedTest = new SynchronizedTest();</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(100);</span><br><span class="line"></span><br><span class="line">        executorService.execute(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                synchronizedTest.test();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        // 保证第一个线程先启动并执行</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        executorService.execute(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                synchronizedTest.test2();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test() throws InterruptedException &#123;</span><br><span class="line">        synchronized (this)&#123;</span><br><span class="line">            System.out.println(&quot;test start&quot;);</span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line">            System.out.println(&quot;test end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void test2() &#123;</span><br><span class="line">        synchronized (this)&#123;</span><br><span class="line">            System.out.println(&quot;test22222222 start&quot;);</span><br><span class="line">            System.out.println(&quot;test22222222 end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test start</span><br><span class="line">test end</span><br><span class="line">test22222222 start</span><br><span class="line">test22222222 end</span><br></pre></td></tr></table></figure><p>将test2方法的锁去掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void test2() &#123;</span><br><span class="line">    System.out.println(&quot;test22222222 start&quot;);</span><br><span class="line">    System.out.println(&quot;test22222222 end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test start</span><br><span class="line">test22222222 start</span><br><span class="line">test22222222 end</span><br><span class="line">test end</span><br></pre></td></tr></table></figure><p>将test2改成方法锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void test2() &#123;</span><br><span class="line">    System.out.println(&quot;test22222222 start&quot;);</span><br><span class="line">    System.out.println(&quot;test22222222 end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test start</span><br><span class="line">test end</span><br><span class="line">test22222222 start</span><br><span class="line">test22222222 end</span><br></pre></td></tr></table></figure><h4><a id="_62"></a><a class="header-anchor" href="#总结">¶</a>总结</h4><p>上面的结果我们能看到即使 test方法 耗时较长，test2方法 也并不会获得执行的机会，<br>如果将 test2方法 的同步锁去掉，test2方法 就可以执行<br>如果将 test2方法 改成方法锁，执行结果和 synchronized(this) 结果相同<br>so,<br><strong>synchronized (this)使用的对象监视器该对象自身, 当一个线程访问SynchronizedTest中的一个synchronized (this)同步代码块时，其它线程对同一个SynchronizedTest中的synchronized (this)【包括本方法和其它被修饰的方法】同步代码块的访问将是堵塞，实现了代码顺序的同步执行</strong><br><strong>synchronized(this) == synchronize方法 【前提是this不是写在其他线程里的，如果是写在其他线程里的，则代表这个线程对象】</strong></p><h3><a id="synchronizedObject_70"></a><a class="header-anchor" href="#synchronized-object">¶</a>synchronized(Object)</h3><h5><a id="object_71"></a><a class="header-anchor" href="#object">¶</a>object</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">/**</span><br><span class="line"> * Lock1 class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2017/09/22</span><br><span class="line"> */</span><br><span class="line">public class SynchronizedTest &#123;</span><br><span class="line"></span><br><span class="line">    private Object objectLock = new Object();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        SynchronizedTest synchronizedTest = new SynchronizedTest();</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(100);</span><br><span class="line"></span><br><span class="line">        executorService.execute(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                synchronizedTest.test(&quot;线程A&quot;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        // 保证第一个线程先启动并执行</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        executorService.execute(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                synchronizedTest.test(&quot;线程B&quot;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test(String msg) throws InterruptedException &#123;</span><br><span class="line">        synchronized (objectLock)&#123;</span><br><span class="line">            System.out.println(msg + &quot; test start&quot;);</span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line">            System.out.println(msg + &quot; test end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程A test start</span><br><span class="line">线程A test end</span><br><span class="line">线程B test start</span><br><span class="line">线程B test end</span><br></pre></td></tr></table></figure><p>将 objectLock 锁对象放入到 <strong>方法内</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void test(String msg) throws InterruptedException &#123;</span><br><span class="line">    Object objectLock = new Object();</span><br><span class="line">    synchronized (objectLock)&#123;</span><br><span class="line">        System.out.println(msg + &quot; test start&quot;);</span><br><span class="line">        Thread.sleep(5000);</span><br><span class="line">        System.out.println(msg + &quot; test end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程A test start</span><br><span class="line">线程B test start</span><br><span class="line">线程A test end</span><br><span class="line">线程B test end</span><br></pre></td></tr></table></figure><h4><a id="_79"></a><a class="header-anchor" href="#总结-v2">¶</a>总结</h4><p>object 和 this 本质上是一样的，只不过this是当前对象，而object是我们额外引入的对象</p><h3><a id="synchronizedclasssynchronized_82"></a><a class="header-anchor" href="#synchronized-class-synchronized静态同步方法">¶</a>synchronized(class)、synchronized静态同步方法</h3><h5><a id="class_83"></a><a class="header-anchor" href="#class">¶</a>class</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * LockTest class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2017/09/22</span><br><span class="line"> */</span><br><span class="line">public class LockTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line"></span><br><span class="line">        LockTest lockTest = new LockTest();</span><br><span class="line">        LockTest lockTest2 = new LockTest();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            synchronized (LockTest.class)&#123;</span><br><span class="line">                lockTest.print();</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            synchronized (LockTest.class)&#123;</span><br><span class="line">                lockTest2.print();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;父类正在执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果发现 线程2 也是无法执行的，至到 线程1 释放锁</p><h5><a id="synchronized_86"></a><a class="header-anchor" href="#静态同步synchronized方法">¶</a>静态同步synchronized方法</h5><p>把 print 方法改成静态锁方法，发现结果和锁class是一样的</p><h4><a id="_89"></a><a class="header-anchor" href="#总结-v3">¶</a>总结</h4><p>静态同步synchronized方法 默认锁的是当前的.class对象，<br>通过实例可以发现 class 锁的当前对象的所有实例，区别于this，this只是锁当前的实例对象<br>so, <strong>synchronized(class) == synchronized静态同步方法</strong></p><h1><a id="Lock_95"></a>Lock</h1><h2><a id="_96"></a><a class="header-anchor" href="#概念">¶</a>概念</h2><p>synchronized是java中的一个关键字，也就是说是Java语言内置的特性。那么为什么会出现Lock呢？<br>如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：</p><ul><li>获取锁的线程执行完了该代码块，然后线程释放对锁的占有</li><li>线程执行发生异常，此时JVM会让线程自动释放锁。</li></ul><p>那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。<br>因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。<br>再举个例子：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。<br>但是采用synchronized关键字来实现同步的话，就会导致一个问题：<br>如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。<br>因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。</p><p>另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。<br>总结一下，也就是说Lock提供了比synchronized更多的功能。但是要注意以下几点：</p><ul><li>Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；</li><li>Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</li></ul><p>首先要说明的就是Lock，通过查看Lock的源码可知，Lock是一个接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Lock &#123;</span><br><span class="line">    void lock();</span><br><span class="line">    void lockInterruptibly() throws InterruptedException;</span><br><span class="line">    boolean tryLock();</span><br><span class="line">    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line">    void unlock();</span><br><span class="line">    Condition newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lock()、tryLock()、tryLock(long time, TimeUnit unit)和lockInterruptibly()是用来获取锁的<br>unLock()方法是用来释放锁的</p><p>在Lock中声明了四个方法来获取锁，那么这四个方法有何区别呢？<br>首先lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待</p><h5><a id="lock_122"></a><a class="header-anchor" href="#lock">¶</a>lock()</h5><p>由于在前面讲到如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。</p><p>通常使用Lock来进行同步的话，是以下面这种形式去使用的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line">lock.lock();</span><br><span class="line">try&#123;</span><br><span class="line">    //处理任务</span><br><span class="line">&#125;catch(Exception ex)&#123;</span><br><span class="line">     </span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    lock.unlock();   //释放锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><a id="tryLocktryLocklong_time_TimeUnit_unit_127"></a><a class="header-anchor" href="#trylock-trylock-long-time-timeunit-unit">¶</a>tryLock()、tryLock(long time, TimeUnit unit)</h5><p>tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。<br>tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true</p><p>所以，一般情况下通过tryLock来获取锁时是这样使用的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line">if(lock.tryLock()) &#123;</span><br><span class="line">     try&#123;</span><br><span class="line">         //处理任务</span><br><span class="line">     &#125;catch(Exception ex)&#123;</span><br><span class="line">         </span><br><span class="line">     &#125;finally&#123;</span><br><span class="line">         lock.unlock();   //释放锁</span><br><span class="line">     &#125; </span><br><span class="line">&#125;else &#123;</span><br><span class="line">    //如果不能获取锁，则直接做其他事情</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><a id="lockInterruptibly_134"></a><a class="header-anchor" href="#lockinterruptibly">¶</a>lockInterruptibly()</h5><p>lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。</p><p>由于lockInterruptibly()的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly()的方法外声明抛出InterruptedException。</p><p>因此lockInterruptibly()一般的使用形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void method() throws InterruptedException &#123;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;  </span><br><span class="line">     //.....</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red">注意:</font><br>当一个线程获取了锁之后，是不会被interrupt()方法中断的。单独调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。</p><h2><a id="ReentrantLock_144"></a><a class="header-anchor" href="#reentrantlock">¶</a>ReentrantLock</h2><p>ReentrantLock，意思是“可重入锁”，ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。<br>具体的使用和synchronized 差不多，都需要注意锁的对象，不要把lock对象定义在方法中，导致线程不能共享锁</p><p>lock()、tryLock()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">**</span><br><span class="line"> * LockTest class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2017/09/22</span><br><span class="line"> */</span><br><span class="line">public class LockTest &#123;</span><br><span class="line"></span><br><span class="line">    private ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        final LockTest test = new LockTest();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            test.lock(Thread.currentThread());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            test.lock(Thread.currentThread());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void lock(Thread thread) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(thread.getName()+&quot;得到了锁&quot;);</span><br><span class="line">            </span><br><span class="line">            // TODO: 2019/10/22 执行业务逻辑 </span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // TODO: handle exception</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            System.out.println(thread.getName()+&quot;释放了锁&quot;);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void tryLock(Thread thread) &#123;</span><br><span class="line">        if(lock.tryLock()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(thread.getName()+&quot;得到了锁&quot;);</span><br><span class="line"></span><br><span class="line">                // TODO: 2019/10/22 执行业务逻辑</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                // TODO: handle exception</span><br><span class="line">            &#125;finally &#123;</span><br><span class="line">                System.out.println(thread.getName()+&quot;释放了锁&quot;);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(thread.getName()+&quot;获取锁失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lockInterruptibly()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * LockTest class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2017/09/22</span><br><span class="line"> */</span><br><span class="line">public class LockTest &#123;</span><br><span class="line"></span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        final LockTest test = new LockTest();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                test.lockInterruptibly(Thread.currentThread());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;被中断&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread thread2 = new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                test.lockInterruptibly(Thread.currentThread());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;被中断&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line"></span><br><span class="line">        thread2.interrupt();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(10000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void lockInterruptibly(Thread thread) throws InterruptedException &#123;</span><br><span class="line">        //注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将InterruptedException抛出</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(thread.getName()+&quot;得到了锁&quot;);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line"></span><br><span class="line">            // TODO: 2019/10/22 执行业务逻辑</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;执行finally&quot;);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(thread.getName()+&quot;释放了锁&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，发现thread2能够被正确中断。</p><h2><a id="ReadWriteLock_154"></a><a class="header-anchor" href="#readwritelock">¶</a>ReadWriteLock</h2><p>ReadWriteLock也是一个接口，在它里面只定义了两个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface ReadWriteLock &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Returns the lock used for reading.</span><br><span class="line">     *</span><br><span class="line">     * @return the lock used for reading.</span><br><span class="line">     */</span><br><span class="line">    Lock readLock();</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * Returns the lock used for writing.</span><br><span class="line">     *</span><br><span class="line">     * @return the lock used for writing.</span><br><span class="line">     */</span><br><span class="line">    Lock writeLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的ReentrantReadWriteLock实现了ReadWriteLock接口。</p><h2><a id="ReentrantReadWriteLock_159"></a><a class="header-anchor" href="#reentrantreadwritelock">¶</a>ReentrantReadWriteLock</h2><p>ReentrantReadWriteLock里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和writeLock()用来获取读锁和写锁。<br>假如有多个线程要同时进行读操作的话，先看一下synchronized达到的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * LockTest class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2017/09/22</span><br><span class="line"> */</span><br><span class="line">public class LockTest &#123;</span><br><span class="line"></span><br><span class="line">    private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        final LockTest test = new LockTest();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            test.get(Thread.currentThread());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            test.get(Thread.currentThread());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void get(Thread thread) &#123;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        while(System.currentTimeMillis() - start &lt;= 1) &#123;</span><br><span class="line">            System.out.println(thread.getName()+&quot;正在进行读操作&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(thread.getName()+&quot;读操作完毕&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序的输出结果会是，直到thread1执行完读操作之后，才会打印thread2执行读操作的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0读操作完毕</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1读操作完毕</span><br></pre></td></tr></table></figure><p>而改成用读写锁的话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * LockTest class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2017/09/22</span><br><span class="line"> */</span><br><span class="line">public class LockTest &#123;</span><br><span class="line"></span><br><span class="line">    private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        final LockTest test = new LockTest();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            test.get(Thread.currentThread());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            test.get(Thread.currentThread());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void get(Thread thread) &#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            while(System.currentTimeMillis() - start &lt;= 1) &#123;</span><br><span class="line">                System.out.println(thread.getName()+&quot;正在进行读操作&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(thread.getName()+&quot;读操作完毕&quot;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-0读操作完毕</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1读操作完毕</span><br></pre></td></tr></table></figure><p>说明thread1和thread2在同时进行读操作。<br>这样就大大提升了读操作的效率。<br>不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。<br>如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。</p><h2><a id="Condition__174"></a><a class="header-anchor" href="#condition-类">¶</a>Condition 类</h2><p>Condition与重入锁是通过lock.newCondition()方法产生一个与当前重入锁绑定的Condtion实例，我们通知该实例来控制线程的等待与通知。该接口的所有方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface Condition &#123;</span><br><span class="line">     //当前线程进入等待状态，直到被通知（signal）或者被中断时，当前线程进入运行状态，从await()返回。与Object.wait()类似。</span><br><span class="line">    void await() throws InterruptedException;</span><br><span class="line"> </span><br><span class="line">    //当前线程进入等待状态，直到被通知，对中断不做响应； </span><br><span class="line">    //线程在调用condition.await()后处于await状态，此时调用thread.interrupt()会报错</span><br><span class="line">    //但是使用condition.awaitUninterruptibly()后，调用thread.interrupt()则不会报错</span><br><span class="line">    void awaitUninterruptibly();</span><br><span class="line"> </span><br><span class="line">    //nanosTimeout指定该方法等待信号的的最大时间（单位为纳秒）。若指定时间内收到signal()或signalALL()则返回nanosTimeout减去已经等待的时间；</span><br><span class="line">    //若指定时间内有其它线程中断该线程，则抛出InterruptedException并清除当前线程的打断状态；</span><br><span class="line">    //增加了超时响应，返回值表示当前剩余的时间，如果在nanosTimeout之前被唤醒，返回值 = nanosTimeout - 实际消耗的时间，返回值 &lt;= 0表示超时；</span><br><span class="line">    long awaitNanos(long nanosTimeout) throws InterruptedException;</span><br><span class="line"> </span><br><span class="line">    //与await()基本一致，唯一不同点在于，返回值返回true/false，在time之前被唤醒，返回true，超时返回false。</span><br><span class="line">    boolean await(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line"> </span><br><span class="line">   //适用条件与行为与awaitNanos(long nanosTimeout)完全一样，唯一不同点在于它不是等待指定时间，而是等待由参数指定的某一时刻。</span><br><span class="line">    boolean awaitUntil(Date deadline) throws InterruptedException;</span><br><span class="line">    </span><br><span class="line">    //唤醒一个在 await()等待队列中的线程。与Object.notify()相似</span><br><span class="line">    void signal();</span><br><span class="line"> </span><br><span class="line">   //唤醒 await()等待队列中所有的线程。与object.notifyAll()相似</span><br><span class="line">    void signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><a id="CountDownLatch_178"></a><a class="header-anchor" href="#countdownlatch">¶</a>CountDownLatch</h2><ul><li>countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。</li><li>是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。</li></ul><p>countDownLatch类中只提供了一个构造器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//参数count为计数值</span><br><span class="line">public CountDownLatch(int count) &#123;  &#125;;</span><br></pre></td></tr></table></figure><p>类中有三个方法是最重要的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span><br><span class="line">public void await() throws InterruptedException &#123; &#125;;   </span><br><span class="line">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span><br><span class="line">public boolean await(long timeout, TimeUnit unit) throws InterruptedException &#123; &#125;;  </span><br><span class="line">//将count值减1</span><br><span class="line">public void countDown() &#123; &#125;;</span><br></pre></td></tr></table></figure><h2><a id="CyclicBarrier_187"></a><a class="header-anchor" href="#cyclicbarrier">¶</a>CyclicBarrier</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//调用await方法的线程告诉CyclicBarrier自己已经到达同步点，然后当前线程被阻塞。直到parties个参与线程调用了await方法，CyclicBarrier同样提供带超时时间的await和不带超时时间的await方法</span><br><span class="line">await()</span><br><span class="line">//broken标识该当前CyclicBarrier是否已经处于中断状态。</span><br><span class="line">//默认barrier是没有损坏的。当barrier损坏了或者有一个线程中断了，则通过breakBarrier()来终止所有的线程</span><br><span class="line">breakBarrier()</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>dowait(boolean, long)方法，它也是CyclicBarrier的核心方法，该方法定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">private int dowait(boolean timed, long nanos)</span><br><span class="line">    throws InterruptedException, BrokenBarrierException,</span><br><span class="line">            TimeoutException &#123;</span><br><span class="line">    // 获取独占锁</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 当前代</span><br><span class="line">        final Generation g = generation;</span><br><span class="line">        // 如果这代损坏了，抛出异常</span><br><span class="line">        if (g.broken)</span><br><span class="line">            throw new BrokenBarrierException();</span><br><span class="line"> </span><br><span class="line">        // 如果线程中断了，抛出异常</span><br><span class="line">        if (Thread.interrupted()) &#123;</span><br><span class="line">            // 将损坏状态设置为true</span><br><span class="line">            // 并通知其他阻塞在此栅栏上的线程</span><br><span class="line">            breakBarrier();</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        // 获取下标</span><br><span class="line">        int index = --count;</span><br><span class="line">        // 如果是 0，说明最后一个线程调用了该方法</span><br><span class="line">        if (index == 0) &#123;  // tripped</span><br><span class="line">            boolean ranAction = false;</span><br><span class="line">            try &#123;</span><br><span class="line">                final Runnable command = barrierCommand;</span><br><span class="line">                // 执行栅栏任务</span><br><span class="line">                if (command != null)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = true;</span><br><span class="line">                // 更新一代，将count重置，将generation重置</span><br><span class="line">                // 唤醒之前等待的线程</span><br><span class="line">                nextGeneration();</span><br><span class="line">                return 0;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // 如果执行栅栏任务的时候失败了，就将损坏状态设置为true</span><br><span class="line">                if (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        // loop until tripped, broken, interrupted, or timed out</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                 // 如果没有时间限制，则直接等待，直到被唤醒</span><br><span class="line">                if (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                // 如果有时间限制，则等待指定时间</span><br><span class="line">                else if (nanos &gt; 0L)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                // 当前代没有损坏</span><br><span class="line">                if (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    // 让栅栏失效</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    throw ie;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 上面条件不满足，说明这个线程不是这代的</span><br><span class="line">                    // 就不会影响当前这代栅栏的执行，所以，就打个中断标记</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            // 当有任何一个线程中断了，就会调用breakBarrier方法</span><br><span class="line">            // 就会唤醒其他的线程，其他线程醒来后，也要抛出异常</span><br><span class="line">            if (g.broken)</span><br><span class="line">                throw new BrokenBarrierException();</span><br><span class="line"> </span><br><span class="line">            // g != generation表示正常换代了，返回当前线程所在栅栏的下标</span><br><span class="line">            // 如果 g == generation，说明还没有换代，那为什么会醒了？</span><br><span class="line">            // 因为一个线程可以使用多个栅栏，当别的栅栏唤醒了这个线程，就会走到这里，所以需要判断是否是当前代。</span><br><span class="line">            // 正是因为这个原因，才需要generation来保证正确。</span><br><span class="line">            if (g != generation)</span><br><span class="line">                return index;</span><br><span class="line">            </span><br><span class="line">            // 如果有时间限制，且时间小于等于0，销毁栅栏并抛出异常</span><br><span class="line">            if (timed &amp;&amp; nanos &lt;= 0L) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                throw new TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 释放独占锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dowait(boolean, long)方法的主要逻辑处理比较简单，如果该线程不是最后一个调用await方法的线程，则它会一直处于等待状态，除非发生以下情况：</p><ul><li>最后一个线程到达，即index == 0</li><li>某个参与线程等待超时</li><li>某个参与线程被中断</li><li>调用了CyclicBarrier的reset()方法。该方法会将屏障重置为初始状态<br>在上面的源代码中，我们可能需要注意Generation 对象，在上述代码中我们总是可以看到抛出BrokenBarrierException异常，那么什么时候抛出异常呢？如果一个线程处于等待状态时，如果其他线程调用reset()，或者调用的barrier原本就是被损坏的，则抛出BrokenBarrierException异常。同时，任何线程在等待时被中断了，则其他所有线程都将抛出BrokenBarrierException异常，并将barrier置于损坏状态。</li></ul><p>同时，Generation描述着CyclicBarrier的更新换代。在CyclicBarrier中，同一批线程属于同一代。当有parties个线程到达barrier之后，generation就会被更新换代。其中broken标识该当前CyclicBarrier是否已经处于中断状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static class Generation &#123;</span><br><span class="line">    boolean broken = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认barrier是没有损坏的。当barrier损坏了或者有一个线程中断了，则通过breakBarrier()来终止所有的线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void breakBarrier() &#123;</span><br><span class="line">    generation.broken = true;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在breakBarrier()中除了将broken设置为true，还会调用signalAll将在CyclicBarrier处于等待状态的线程全部唤醒。</p><p>当所有线程都已经到达barrier处（index == 0），则会通过nextGeneration()进行更新换地操作，在这个步骤中，做了三件事：唤醒所有线程，重置count，generation：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void nextGeneration() &#123;</span><br><span class="line">    // signal completion of last generation</span><br><span class="line">    trip.signalAll();</span><br><span class="line">    // set up next generation</span><br><span class="line">    count = parties;</span><br><span class="line">    generation = new Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了上面讲到的栅栏更新换代以及损坏状态，我们在使用CyclicBarrier时还要要注意以下几点：</p><ul><li>CyclicBarrier使用独占锁来执行await方法，并发性可能不是很高</li><li>如果在等待过程中，线程被中断了，就抛出异常。但如果中断的线程所对应的CyclicBarrier不是这代的，比如，在最后一次线程执行signalAll后，并且更新了这个“代”对象。在这个区间，这个线程被中断了，那么，JDK认为任务已经完成了，就不必在乎中断了，只需要打个标记。该部分源码已在dowait(boolean, long)方法中进行了注释。</li><li>如果线程被其他的CyclicBarrier唤醒了，那么g肯定等于generation，这个事件就不能return了，而是继续循环阻塞。反之，如果是当前CyclicBarrier唤醒的，就返回线程在CyclicBarrier的下标。完成了一次冲过栅栏的过程。该部分源码已在dowait(boolean, long)方法中进行了注释。</li></ul><p>我们自定义的工作线程必须要等所有参与线程开始之后才可以执行，我们可以使用CyclicBarrier类来帮助我们完成。从程序的执行结果中也可以看出，所有的工作线程都运行await()方法之后都到达了栅栏位置，然后，工作线程才开始执行业务处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class CyclicBarrier &#123;</span><br><span class="line">    </span><br><span class="line">    private static class Generation &#123;</span><br><span class="line">        boolean broken = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 独占锁成员</span><br><span class="line">    private final ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    // 条件成员</span><br><span class="line">    private final Condition trip = lock.newCondition();</span><br><span class="line">    // 必须满足障碍条件的线程个数</span><br><span class="line">    private final int parties;</span><br><span class="line">    // 当障碍条件满足会被自动执行的任务</span><br><span class="line">    private final Runnable barrierCommand;</span><br><span class="line">    // 当前世代(cyclicBarrier可重复利用，每一次利用是一个世代)</span><br><span class="line">    private Generation generation = new Generation();</span><br><span class="line">    // 满足障碍锁条件还需要的阻塞线程个数</span><br><span class="line">    private int count;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    ..</span><br><span class="line">    .</span><br><span class="line">    // 构造函数</span><br><span class="line">    public CyclicBarrier(int parties, Runnable barrierAction) &#123;</span><br><span class="line">        if (parties &lt;= 0) throw new IllegalArgumentException();</span><br><span class="line">        // 初始化障碍条件总数</span><br><span class="line">        this.parties = parties;</span><br><span class="line">        // 初始化阻塞线程个数</span><br><span class="line">        this.count = parties;</span><br><span class="line">        // 初始化条件满足时自动执行任务</span><br><span class="line">        this.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">public int await() throws InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 调用dowait来实现。</span><br><span class="line">        return dowait(false, 0L);</span><br><span class="line">    &#125; catch (TimeoutException toe) &#123;</span><br><span class="line">        throw new Error(toe); // cannot happen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> private int dowait(boolean timed, long nanos)</span><br><span class="line">        throws InterruptedException, BrokenBarrierException,</span><br><span class="line">               TimeoutException &#123;</span><br><span class="line">    // 获取独占锁。下面的操作都是同步的。</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 设置当前世代</span><br><span class="line">        final Generation g = generation;</span><br><span class="line"></span><br><span class="line">        if (g.broken)</span><br><span class="line">            throw new BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        if (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        // 由于本线程调用await()，则需要的阻塞线程个数-1。</span><br><span class="line">       int index = --count;</span><br><span class="line">       // 若为0则代表障碍条件满足</span><br><span class="line">       if (index == 0) &#123;  // tripped</span><br><span class="line">           boolean ranAction = false;</span><br><span class="line">           try &#123;</span><br><span class="line">               // 执行注册的自动执行任务</span><br><span class="line">               final Runnable command = barrierCommand;</span><br><span class="line">               if (command != null)</span><br><span class="line">                   command.run();</span><br><span class="line">               ranAction = true;</span><br><span class="line">               // 设置世代为下一世代，以方便障碍锁的二次利用。</span><br><span class="line">               nextGeneration();</span><br><span class="line">               return 0;</span><br><span class="line">           &#125; finally &#123;</span><br><span class="line">               if (!ranAction)</span><br><span class="line">                   breakBarrier();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        // 通过循环</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 若没有阻塞时间限制，则阻塞</span><br><span class="line">                if (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                // 若有阻塞时间限制，则阻塞相应的时间</span><br><span class="line">                else if (nanos &gt; 0L)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                if (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    throw ie;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (g.broken)</span><br><span class="line">                throw new BrokenBarrierException();</span><br><span class="line">            // 阻塞线程被唤醒后，若generation已被更新则代表障碍条件达成，线程继续执行。</span><br><span class="line">            if (g != generation)</span><br><span class="line">                return index;</span><br><span class="line">            // 阻塞线程若超过了阻塞时间，被唤醒后，则抛出异常</span><br><span class="line">            if (timed &amp;&amp; nanos &lt;= 0L) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                throw new TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 释放同步锁。</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">.....</span><br><span class="line">...</span><br><span class="line">..</span><br><span class="line">// 更新当前障碍锁世代。</span><br><span class="line">private void nextGeneration() &#123;</span><br><span class="line">    // 唤醒所有在当前障碍锁上阻塞的线程</span><br><span class="line">    trip.signalAll();</span><br><span class="line">    // reset障碍锁条件</span><br><span class="line">    count = parties;</span><br><span class="line">    // 初始化新世代</span><br><span class="line">    generation = new Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><a id="CyclicBarrierCountDownLatch_216"></a><a class="header-anchor" href="#cyclicbarrier和countdownlatch的区别">¶</a>CyclicBarrier和CountDownLatch的区别</h4><ul><li>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置，可以使用多次，所以CyclicBarrier能够处理更为复杂的场景；</li><li>CyclicBarrier还提供了一些其他有用的方法，比如getNumberWaiting()方法可以获得CyclicBarrier阻塞的线程数量，isBroken()方法用来了解阻塞的线程是否被中断；</li><li>CountDownLatch允许一个或多个线程等待一组事件的产生，而CyclicBarrier用于等待其他线程运行到栅栏位置。</li><li>CountDownLatch : 一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行。 CyclicBarrier : N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。这样应该就清楚一点了，对于CountDownLatch来说，重点是那个“一个线程”, 是它在等待， 而另外那N的线程在把“某个事</li><li>情”做完之后可以继续等待，可以终止。而对于CyclicBarrier来说，重点是那N个线程，他们之间任何一个没有完成，所有的线程都必须等待。</li></ul><h1><a id="Locksynchronized_224"></a>Lock和synchronized的选择</h1><p>总结来说，Lock和synchronized有以下几点不同：</p><ul><li>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</li><li>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</li><li>Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li><li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</li><li>Lock可以提高多个线程进行读操作的效率。<br>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</li></ul></div><div id="wechat_subscriber" style="display:block;padding:10px 0;margin:20px auto;width:100%;text-align:center"><img id="wechat_subscriber_qcode" src="/blog/uploads/wechat-qcode.png" alt="Jeff-Eric wechat" style="width:200px;max-width:100%"><div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Jeff-Eric</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://jeff-eric.github.com/blog/2019/10/22/synchronized-%E5%92%8C-Lock/" title="synchronized 和 Lock">https:&#x2F;&#x2F;jeff-eric.github.com&#x2F;blog&#x2F;2019&#x2F;10&#x2F;22&#x2F;synchronized-%E5%92%8C-Lock&#x2F;</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank">&lt;i class=&quot;fa fa-fw fa-creative-commons&quot;&gt;&lt;&#x2F;i&gt;BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/blog/tags/synchronized-Lock-%E9%94%81/" rel="tag"># synchronized,Lock,锁</a></div><div class="post-widgets"><div class="social_share"><div id="needsharebutton-postbottom"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/blog/2019/10/22/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8C%96/" rel="next" title="分布式架构的演化"><i class="fa fa-chevron-left"></i> 分布式架构的演化</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/blog/2019/10/22/spring%20-%20%E7%AE%80%E4%BB%8B/" rel="prev" title="spring - 简介">spring - 简介 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/blog/uploads/avatar.jpg" alt="Jeff-Eric"><p class="site-author-name" itemprop="name">Jeff-Eric</p><div class="site-description motion-element" itemprop="description"></div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/blog/archives/%20%7C%7C%20archive"><span class="site-state-item-count">42</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/blog/categories/%20%7C%7C%20th"><span class="site-state-item-count">12</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/blog/tags/%20%7C%7C%20tags"><span class="site-state-item-count">28</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/jeff-eric" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;jeff-eric" rel="noopener" target="_blank">&lt;i class=&quot;fa fa-fw fa-github&quot;&gt;&lt;&#x2F;i&gt;GitHub</a> </span><span class="links-of-author-item"><a href="/blog/jphoebe4086824@gmail.com" title="E-Mail &amp;rarr; jphoebe4086824@gmail.com">&lt;i class=&quot;fa fa-fw fa-envelope&quot;&gt;&lt;&#x2F;i&gt;E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank">&lt;img src=&quot;&#x2F;blog&#x2F;images&#x2F;cc-by-nc-sa.svg&quot; alt=&quot;Creative Commons&quot;&#x2F;&gt;</a></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">1.</span> <span class="nav-text">锁的相关概念介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">1.1.</span> <span class="nav-text">¶可重入锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">1.2.</span> <span class="nav-text">¶可中断锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">1.3.</span> <span class="nav-text">¶公平锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">1.4.</span> <span class="nav-text">¶读写锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">2.</span> <span class="nav-text">synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#null"><span class="nav-number">2.0.0.1.</span> <span class="nav-text">¶常见的几种应用是：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">2.0.1.</span> <span class="nav-text">¶synchronized(this)、synchronize方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#null"><span class="nav-number">2.0.1.1.</span> <span class="nav-text">¶总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">2.0.2.</span> <span class="nav-text">¶synchronized(Object)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#null"><span class="nav-number">2.0.2.0.1.</span> <span class="nav-text">¶object</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#null"><span class="nav-number">2.0.2.1.</span> <span class="nav-text">¶总结</span></a></li></ol><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">2.0.3.</span> <span class="nav-text">¶synchronized(class)、synchronized静态同步方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#null"><span class="nav-number">2.0.3.0.1.</span> <span class="nav-text">¶class</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#null"><span class="nav-number">2.0.3.0.2.</span> <span class="nav-text">¶静态同步synchronized方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#null"><span class="nav-number">2.0.3.1.</span> <span class="nav-text">¶总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">3.</span> <span class="nav-text">Lock</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">3.1.</span> <span class="nav-text">¶概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#null"><span class="nav-number">3.1.0.0.1.</span> <span class="nav-text">¶lock()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#null"><span class="nav-number">3.1.0.0.2.</span> <span class="nav-text">¶tryLock()、tryLock(long time, TimeUnit unit)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#null"><span class="nav-number">3.1.0.0.3.</span> <span class="nav-text">¶lockInterruptibly()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">3.2.</span> <span class="nav-text">¶ReentrantLock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">3.3.</span> <span class="nav-text">¶ReadWriteLock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">3.4.</span> <span class="nav-text">¶ReentrantReadWriteLock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">3.5.</span> <span class="nav-text">¶Condition 类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">3.6.</span> <span class="nav-text">¶CountDownLatch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">3.7.</span> <span class="nav-text">¶CyclicBarrier</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#null"><span class="nav-number">3.7.0.1.</span> <span class="nav-text">¶CyclicBarrier和CountDownLatch的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">4.</span> <span class="nav-text">Lock和synchronized的选择</span></a></li></div></div></div><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Jeff-Eric</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0</div><span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.0.1</div></div></footer><div id="needsharebutton-float"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script><script id="ribbon" size="300" alpha="0.6" zindex="-1" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@2/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/npm/fastclick@1/lib/fastclick.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery-lazyload@1/jquery.lazyload.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three-waves.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_lines.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_sphere.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-reading-progress@1/reading_progress.min.js"></script><script src="/blog/js/src/utils.js?v=7.0.1"></script><script src="/blog/js/src/motion.js?v=7.0.1"></script><script src="/blog/js/src/affix.js?v=7.0.1"></script><script src="/blog/js/src/schemes/pisces.js?v=7.0.1"></script><script src="/blog/js/src/scrollspy.js?v=7.0.1"></script><script src="/blog/js/src/post-details.js?v=7.0.1"></script><script src="/blog/js/src/next-boot.js?v=7.0.1"></script><script src="/blog/js/src/js.cookie.js?v=7.0.1"></script><script src="/blog/js/src/scroll-cookie.js?v=7.0.1"></script><script src="//cdn.jsdelivr.net/npm/leancloud-storage@3/dist/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js"></script><script>var GUEST=["nick","mail","link"],guest="nick,mail,link";guest=guest.split(",").filter(function(e){return GUEST.indexOf(e)>-1}),new Valine({el:"#comments",verify:!0,notify:!1,appId:"MKGyMx7EafphCr9hAbMPAwAc-gzGzoHsz",appKey:"4SB8MPoE51bFPHDoKtPM8vLG",placeholder:"Just go go",avatar:"mm",meta:guest,pageSize:"10",visitor:!0})</script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var e=$("#local-search-input");e.attr("autocapitalize","none"),e.attr("autocorrect","off"),e.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/blog/"+search_path,onPopupClose=function(e){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(e,t,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:e,dataType:isXml?"xml":"json",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,r=document.getElementById(t),s=document.getElementById(o),a=function(){var e=r.value.trim().toLowerCase(),t=e.split(/[\s\-]+/);t.length>1&&t.push(e);var o=[];if(e.length>0&&n.forEach(function(n){function r(t,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===e&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(e,t){var o="",n=t.start;return t.hits.forEach(function(t){o+=e.substring(n,t.position);var r=t.position+t.length;o+='<b class="search-keyword">'+e.substring(t.position,r)+"</b>",n=r}),o+=e.substring(n,t.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url).replace(/\/{2,}/g,"/"),d=[],g=[];if(""!=l&&(t.forEach(function(e){function t(e,t,o){var n=e.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(t=t.toLowerCase(),e=e.toLowerCase());(s=t.indexOf(e,r))>-1;)a.push({position:s,word:e}),r=s+n;return a}d=d.concat(t(e,h,!1)),g=g.concat(t(e,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(e){e.sort(function(e,t){return t.position!==e.position?t.position-e.position:e.word.length-t.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hits.length!==t.hits.length?t.hits.length-e.hits.length:e.start-t.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(e){b+="<a href='"+f+'\'><p class="search-result">'+s(p,e)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===t.length&&""===t[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x"></i></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>';else{o.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hitCount!==t.hitCount?t.hitCount-e.hitCount:t.id-e.id});var a='<ul class="search-result-list">';o.forEach(function(e){a+=e.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(e){e.stopPropagation()}),$(document).on("keyup",function(e){var t=27===e.which&&$(".search-popup").is(":visible");t&&onPopupClose()})</script><script src="https://www.gstatic.com/firebasejs/4.6.0/firebase.js"></script><script src="https://www.gstatic.com/firebasejs/4.6.0/firebase-firestore.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/bluebird/3.5.1/bluebird.core.min.js"></script><script>!function(){function getCount(t,e){return t.get().then(function(o){var n;return o.exists?(n=o.data().count,e&&(window.localStorage&&window.localStorage.getItem(title)||(t.set({count:n+1}),n++))):e?(t.set({count:1}),n=1):n=0,window.localStorage&&e&&localStorage.setItem(title,!0),n})}function appendCountTo(t){return function(e){$(t).append($("<span>").addClass("post-visitors-count").append($("<span>").addClass("post-meta-divider").text("|")).append($("<span>").addClass("post-meta-item-icon").append($("<i>").addClass("fa fa-users"))).append($("<span>").text("阅读次数 "+e)))}}firebase.initializeApp({apiKey:"AIzaSyD-BIMnFQcvrv1utthoP5z5shcYP8JMKmY",projectId:"blog-6cbe0"});var db=firebase.firestore(),articles=db.collection("articles"),isPost="synchronized 和 Lock".length>0,isArchive=!1,isCategory="".length>0,isTag="".length>0;if(isPost){var title="synchronized 和 Lock",doc=articles.doc(title);getCount(doc,!0).then(appendCountTo($(".post-meta")))}else if(!isArchive&&!isCategory&&!isTag){var titles=[],postsstr="";eval(postsstr);var promises=titles.map(function(t){return articles.doc(t)}).map(function(t){return getCount(t)});Promise.all(promises).then(function(t){var e=$(".post-meta");t.forEach(function(t,o){appendCountTo(e[o])(t)})})}}()</script><style>.pdfobject-container{position:relative;overflow:auto;width:100%}</style><script>$("body").find("div.pdf").length&&$.ajax({type:"GET",url:"//cdn.jsdelivr.net/npm/pdfobject@2.1.1/pdfobject.min.js",dataType:"script",cache:!0,success:function(){$("body").find("div.pdf").each(function(e,t){PDFObject.embed($(t).attr("target"),$(t),{pdfOpenParams:{navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"},PDFJS_URL:"/lib/pdf/web/viewer.html",height:$(t).attr("height")||"500px"})})}})</script><script>$("body").find("pre.mermaid").length&&$.ajax({type:"GET",url:"//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js",dataType:"script",cache:!0,success:function(){mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})}})</script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script><script>pbOptions={},pbOptions.iconStyle="box",pbOptions.boxForm="horizontal",pbOptions.position="bottomCenter",pbOptions.networks="Weibo,Wechat,Douban,QQZone,Twitter,Facebook",new needShareButton("#needsharebutton-postbottom",pbOptions),flOptions={},flOptions.iconStyle="box",flOptions.boxForm="horizontal",flOptions.position="middleRight",flOptions.networks="Weibo,Wechat,Douban,QQZone,Twitter,Facebook",new needShareButton("#needsharebutton-float",flOptions)</script><script src="//cdn.jsdelivr.net/npm/pangu@3/dist/browser/pangu.min.js"></script><script>pangu.spacingPage()</script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@1/bookmark.min.js"></script><script>bookmark.scrollToMark("auto","#更多")</script><style>.copy-btn{display:inline-block;padding:6px 12px;font-size:13px;font-weight:700;line-height:20px;color:#333;white-space:nowrap;vertical-align:middle;cursor:pointer;background-color:#eee;background-image:linear-gradient(#fcfcfc,#eee);border:1px solid #d5d5d5;border-radius:3px;user-select:none;outline:0}.highlight-wrap .copy-btn{transition:opacity .3s ease-in-out;opacity:0;padding:2px 6px;position:absolute;right:4px;top:8px}.highlight-wrap .copy-btn:focus,.highlight-wrap:hover .copy-btn{opacity:1}.highlight-wrap{position:relative}</style><script>$(".highlight").each(function(t,e){var n=$("<div>").addClass("highlight-wrap");$(e).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(t){var e=$(this).parent().find(".code").find(".line").map(function(t,e){return $(e).text()}).toArray().join("\n"),n=document.createElement("textarea"),o=window.pageYOffset||document.documentElement.scrollTop;n.style.top=o+"px",n.style.position="absolute",n.style.opacity="0",n.readOnly=!0,n.value=e,document.body.appendChild(n),n.select(),n.setSelectionRange(0,e.length),n.readOnly=!1;var a=document.execCommand("copy");a?$(this).text("复制成功"):$(this).text("复制失败"),n.blur(),$(this).blur()})).on("mouseleave",function(t){var e=$(this).find(".copy-btn");setTimeout(function(){e.text("复制")},300)}).append(e)})</script></body></html><!-- rebuild by neat -->