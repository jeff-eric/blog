<!-- build time:Tue Nov 26 2019 14:32:22 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-CN,zh-HK,zh-TW,en,default"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/han-css@3/dist/han.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css"><link rel="stylesheet" href="/blog/css/main.css?v=7.0.1"><link rel="apple-touch-icon" sizes="180x180" href="/blog/uploads/avatar.jpg?v=7.0.1"><link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/avatar.jpg?v=7.0.1"><link rel="icon" type="image/png" sizes="16x16" href="/blog/blog/uploads/avatar.jpg?v=7.0.1"><link rel="mask-icon" href="/blog/uploads/avatar.jpg?v=7.0.1" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/blog/",scheme:"Gemini",version:"7.0.1",sidebar:{position:"left",display:"always",offset:12,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!0,fancybox:!0,fastclick:!0,lazyload:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="介绍Spring IOC 容器对 Bean 定义资源的定位、读入和解析过程，同时也清楚了当用户通过 getBean 方法向 IOC 容器获取被管理的 Bean时，IOC 容器对 Bean 进行的初始化和依赖注入过程，这些是 Spring IOC 容器的基本功能特性。Spring IOC 容器还有一些高级特性，如使用 lazy-init 属性对 Bean 预初始化、FactoryBean 产生或者修"><meta name="keywords" content="架构师"><meta property="og:type" content="article"><meta property="og:title" content="spring - IOC高级特性"><meta property="og:url" content="https:&#x2F;&#x2F;jeff-eric.github.com&#x2F;blog&#x2F;2019&#x2F;10&#x2F;22&#x2F;spring%20-%20IOC%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7&#x2F;index.html"><meta property="og:site_name" content="纯天然绿色学渣"><meta property="og:description" content="介绍Spring IOC 容器对 Bean 定义资源的定位、读入和解析过程，同时也清楚了当用户通过 getBean 方法向 IOC 容器获取被管理的 Bean时，IOC 容器对 Bean 进行的初始化和依赖注入过程，这些是 Spring IOC 容器的基本功能特性。Spring IOC 容器还有一些高级特性，如使用 lazy-init 属性对 Bean 预初始化、FactoryBean 产生或者修"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2019-11-17T07:28:33.326Z"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://jeff-eric.github.com/blog/2019/10/22/spring - IOC高级特性/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>spring - IOC高级特性 | 纯天然绿色学渣</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?bb5d4f8207d7c2bd1aa936180430bbaa";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/blog/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">纯天然绿色学渣</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-home&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;首页</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-tags&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;标签&lt;span class=&quot;badge&quot;&gt;28&lt;&#x2F;span&gt;</a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-th&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;分类&lt;span class=&quot;badge&quot;&gt;12&lt;&#x2F;span&gt;</a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-archive&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;归档&lt;span class=&quot;badge&quot;&gt;42&lt;&#x2F;span&gt;</a></li><li class="menu-item menu-item-tools"><a href="/blog/tools/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-tree&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;工具</a></li><li class="menu-item menu-item-search"><a href="javascript:;" target="_blank" rel="noopener" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><div class="reading-progress-bar"></div><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jeff-eric.github.com/blog/blog/2019/10/22/spring%20-%20IOC%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jeff-Eric"><meta itemprop="description" content=""><meta itemprop="image" content="/blog/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="纯天然绿色学渣"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">spring - IOC高级特性</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-22 18:51:56" itemprop="dateCreated datePublished" datetime="2019-10-22T18:51:56+08:00">2019-10-22</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-11-17 15:28:33" itemprop="dateModified" datetime="2019-11-17T15:28:33+08:00">2019-11-17</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/blog/2019/10/22/spring%20-%20IOC%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/2019/10/22/spring%20-%20IOC%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" itemprop="commentCount"></span> </a></span><span id="/blog/2019/10/22/spring%20-%20IOC%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" class="leancloud_visitors" data-flag-title="spring - IOC高级特性"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body han-init-context" itemprop="articleBody"><h1><a id="_1"></a>介绍</h1><p>Spring IOC 容器对 Bean 定<br>义资源的定位、读入和解析过程，同时也清楚了当用户通过 getBean 方法向 IOC 容器获取被管理的 Bean<br>时，IOC 容器对 Bean 进行的初始化和依赖注入过程，这些是 Spring IOC 容器的基本功能特性。<br>Spring IOC 容器还有一些高级特性，如使用 lazy-init 属性对 Bean 预初始化、FactoryBean 产生或者<br>修饰 Bean 对象的生成、IOC 容器初始化 Bean 过程中使用 BeanPostProcessor 后置处理器对 Bean 声明周<br>期事件管理和 IOC 容器的 autowiring 自动装配功能等。</p><h1><a id="Spring_IOC__lazyinit__9"></a>Spring IOC 容器的 lazy-init 属性实现预实例化：</h1><p>IOC 容器的初始化过程就是对 Bean 定义<br>资源的定位、载入和注册，此时容器对 Bean 的依赖注入并没有发生，依赖注入主要是在应用程序第一<br>次向容器索取 Bean 时，通过 getBean 方法的调用完成。</p><p>当 Bean 定义资源的<bean>元素中配置了 lazy-init 属性时，容器将会在初始化的时候对所配置的 Bean<br>进行预实例化，Bean 的依赖注入在容器初始化的时候就已经完成。这样，当应用程序第一次向容器索取<br>被管理的 Bean 时，就不用再初始化和对 Bean 进行依赖注入了，直接从容器中获取已经完成依赖注入的<br>现成 Bean，可以提高应用第一次向容器获取 Bean 的性能。</bean></p><p>下面我们通过代码分析容器预实例化的实现过程：</p><h2><a id="refresh_20"></a><a class="header-anchor" href="#refresh">¶</a>refresh()</h2><p>先从 IOC 容器的初始会过程开始，通过前面文章分析，我们知道 IOC 容器读入已经定位的 Bean 定义资<br>源是从 refresh 方法开始的，我们首先从 AbstractApplicationContext 类的 refresh 方法入手分析，<br>源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">// 容器初始化的过程，读入 Bean 定义资源，并解析注册</span><br><span class="line">	public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">		synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">			//调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识.</span><br><span class="line">			prepareRefresh();</span><br><span class="line"></span><br><span class="line">			//告诉子类启动 refreshBeanFactory()方法，Bean 定义资源文件的载入从子类的 refreshBeanFactory()方法启动</span><br><span class="line">			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">			//为 BeanFactory 配置容器特性，例如类加载器、事件处理器等</span><br><span class="line">			prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">				//以下三个方法其实都是加载一些所谓的监听器（ApplicationAware/SessionAware等等）</span><br><span class="line"></span><br><span class="line">				// Allows post-processing of the bean factory in context subclasses.</span><br><span class="line">				//为容器的某些子类指定特殊的 BeanPost 事件处理器</span><br><span class="line">				//比如监听spring是否启动，ApplicationAware中的setApplicationContext方法就可以进行一些容器初始化事件操作</span><br><span class="line">				postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">				// Invoke factory processors registered as beans in the context.</span><br><span class="line">				//调用所有注册的 BeanFactoryPostProcessor 的 Bean</span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				//为 BeanFactory 注册 BeanPost 事件处理器.</span><br><span class="line">				//BeanPostProcessor 是 Bean 后置处理器，用于监听容器触发的事件</span><br><span class="line">				// Register bean processors that intercept bean creation.</span><br><span class="line">				registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				//初始化信息源，和国际化相关.</span><br><span class="line">				// Initialize message source for this context.</span><br><span class="line">				initMessageSource();</span><br><span class="line"></span><br><span class="line">				//初始化容器事件传播器.</span><br><span class="line">				// Initialize event multicaster for this context.</span><br><span class="line">				initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">				//调用子类的某些特殊 Bean 初始化方法</span><br><span class="line">				// Initialize other special beans in specific context subclasses.</span><br><span class="line">				onRefresh();</span><br><span class="line"></span><br><span class="line">				//为事件传播器注册事件监听器.</span><br><span class="line">				// Check for listener beans and register them.</span><br><span class="line">				registerListeners();</span><br><span class="line"></span><br><span class="line">				//初始化所有剩余的单例 Bean.</span><br><span class="line">				// Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">				//初始化容器的生命周期事件处理器，并发布容器的生命周期事件</span><br><span class="line">				// Last step: publish corresponding event.</span><br><span class="line">				finishRefresh();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			catch (BeansException ex) &#123;</span><br><span class="line">				//销毁以创建的单态 Bean</span><br><span class="line">				// Destroy already created singletons to avoid dangling resources.</span><br><span class="line">				destroyBeans();</span><br><span class="line"></span><br><span class="line">				//取消 refresh 操作，重置容器的同步标识.</span><br><span class="line">				// Reset &apos;active&apos; flag.</span><br><span class="line">				cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">				// Propagate exception to caller.</span><br><span class="line">				throw ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>在 refresh 方法中 ConfigurableListableBeanFactorybeanFactory = obtainFreshBeanFactory();<br>启动了 Bean 定义资源的载入、注册过程，而 finishBeanFactoryInitialization 方法是对注册后的 Bean<br>定义中的预实例化(lazy-init=false，Spring 默认就是预实例化，即为 true)的 Bean 进行处理的地方。</p><h2><a id="finishBeanFactoryInitialization__Bean_30"></a><a class="header-anchor" href="#finishbeanfactoryinitialization-处理预实例化-bean">¶</a>finishBeanFactoryInitialization 处理预实例化 Bean</h2><p>当Bean定义资源被载入IOC容器之后，容器将Bean定义资源解析为容器内部的数据结构BeanDefinition<br>注册到容器中，AbstractApplicationContext 类中的 finishBeanFactoryInitialization 方法对配置了<br>预实例化属性的 Bean 进行预初始化过程，源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//对配置了 lazy-init 属性的 Bean 进行预实例化处理</span><br><span class="line">	protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">		// Initialize conversion service for this context.</span><br><span class="line">		//这是 Spring3 以后新加的代码，为容器指定一个转换服务(ConversionService)</span><br><span class="line">		//在对某些 Bean 属性进行转换时使用</span><br><span class="line">		if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">				beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">			beanFactory.setConversionService(</span><br><span class="line">					beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span><br><span class="line">		String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);</span><br><span class="line">		for (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">			getBean(weaverAwareName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Stop using the temporary ClassLoader for type matching.</span><br><span class="line">		//为了类型匹配，停止使用临时的类加载器</span><br><span class="line">		beanFactory.setTempClassLoader(null);</span><br><span class="line"></span><br><span class="line">		// Allow for caching all bean definition metadata, not expecting further changes.</span><br><span class="line">		//缓存容器中所有注册的 BeanDefinition 元数据，以防被修改</span><br><span class="line">		beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">		// Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">		//对配置了 lazy-init 属性的单态模式 Bean 进行预实例化处理</span><br><span class="line">		beanFactory.preInstantiateSingletons();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>ConfigurableListableBeanFactory 是一个接口，其 preInstantiateSingletons 方法由其子类<br>DefaultListableBeanFactory 提供。</p><h2><a id="DefaultListableBeanFactory__lazyinit__Bean__40"></a><a class="header-anchor" href="#defaultlistablebeanfactory-对配置-lazy-init-属性单态-bean-的预实例化">¶</a>DefaultListableBeanFactory 对配置 lazy-init 属性单态 Bean 的预实例化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//对配置 lazy-init 属性单态 Bean 的预实例化</span><br><span class="line">	public void preInstantiateSingletons() throws BeansException &#123;</span><br><span class="line">		if (this.logger.isInfoEnabled()) &#123;</span><br><span class="line">			this.logger.info(&quot;Pre-instantiating singletons in &quot; + this);</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;String&gt; beanNames;</span><br><span class="line">		//在对配置 lazy-init 属性单态 Bean 的预实例化过程中，必须多线程同步，以确保数据一致性</span><br><span class="line">		synchronized (this.beanDefinitionMap) &#123;</span><br><span class="line">			// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span><br><span class="line">			// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span><br><span class="line">			beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames);</span><br><span class="line">		&#125;</span><br><span class="line">		for (String beanName : beanNames) &#123;</span><br><span class="line">			//获取指定名称的 Bean 定义</span><br><span class="line">			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			//Bean 不是抽象的，是单态模式的，且 lazy-init 属性配置为 false</span><br><span class="line">			if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">				//如果指定名称的 bean 是创建容器的 Bean</span><br><span class="line">				if (isFactoryBean(beanName)) &#123;</span><br><span class="line">					//FACTORY_BEAN_PREFIX=”&amp;”，当 Bean 名称前面加”&amp;”符号</span><br><span class="line">					//时，获取的是产生容器对象本身，而不是容器产生的 Bean.</span><br><span class="line">					//调用 getBean 方法，触发容器对 Bean 实例化和依赖注入过程</span><br><span class="line">					final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">					//标识是否需要预实例化</span><br><span class="line">					boolean isEagerInit;</span><br><span class="line">					if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;</span><br><span class="line">						//一个匿名内部类</span><br><span class="line">						isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">							public Boolean run() &#123;</span><br><span class="line">								return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;, getAccessControlContext());</span><br><span class="line">					&#125;</span><br><span class="line">					else &#123;</span><br><span class="line">						isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;</span><br><span class="line">								((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">					&#125;</span><br><span class="line">					if (isEagerInit) &#123;</span><br><span class="line">						//调用 getBean 方法，触发容器对 Bean 实例化和依赖注入过程</span><br><span class="line">						getBean(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					//调用 getBean 方法，触发容器对 Bean 实例化和依赖注入过程</span><br><span class="line">					getBean(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>通过对 lazy-init 处理源码的分析，我们可以看出，如果设置了 lazy-init 属性，则容器在完成 Bean<br>定义的注册之后，会通过 getBean 方法，触发对指定 Bean 的初始化和依赖注入过程，这样当应用第一<br>次向容器索取所需的 Bean 时，容器不再需要对 Bean 进行初始化和依赖注入，直接从已经完成实例化和<br>依赖注入的 Bean 中取一个现成的 Bean，这样就提高了第一次获取 Bean 的性能。</p><h1><a id="FactoryBean__47"></a>FactoryBean 的实现</h1><p>在 Spring 中，有两个很容易混淆的类：BeanFactory 和 FactoryBean。<br>BeanFactory：Bean 工厂，是一个工厂(Factory)，我们 Spring IOC 容器的最顶层接口就是这个<br>BeanFactory，它的作用是管理 Bean，即实例化、定位、配置应用程序中的对象及建立这些对象间的依<br>赖。</p><p>FactoryBean：工厂 Bean，是一个 Bean，作用是产生其他 bean 实例。通常情况下，这种 bean 没有什么<br>特别的要求，仅需要提供一个工厂方法，该方法用来返回其他 bean 实例。通常情况下，bean 无须自己<br>实现工厂模式，Spring 容器担任工厂角色；但少数情况下，容器中的 bean 本身就是工厂，其作用是产<br>生其它 bean 实例。</p><p>当用户使用容器本身时，可以使用转义字符”&amp;”来得到 FactoryBean 本身，以区别通过 FactoryBean<br>产生的实例对象和 FactoryBean 对象本身。在 BeanFactory 中通过如下代码定义了该转义字符：<br>StringFACTORY_BEAN_PREFIX = “&amp;”;</p><p>如果 myJndiObject 是一个 FactoryBean，则使用&amp;myJndiObject 得到的是 myJndiObject 对象，而不是<br>myJndiObject 产生出来的对象。</p><h2><a id="FactoryBean__65"></a><a class="header-anchor" href="#factorybean-的源码如下">¶</a>FactoryBean 的源码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//工厂 Bean，用于产生其他对象</span><br><span class="line">public interface FactoryBean&lt;T&gt; &#123;</span><br><span class="line">    //获取容器管理的对象实例</span><br><span class="line">    T getObject() throws Exception;</span><br><span class="line">    //获取 Bean 工厂创建的对象的类型</span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line">    //Bean 工厂创建的对象是否是单态模式，如果是单态模式，则整个容器中只有一个实例</span><br><span class="line">    //对象，每次请求都返回同一个实例对象</span><br><span class="line">    boolean isSingleton();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><a id="AbstractBeanFactory__getBean__FactoryBean_68"></a><a class="header-anchor" href="#abstractbeanfactory-的-getbean-方法调用-factorybean">¶</a>AbstractBeanFactory 的 getBean 方法调用 FactoryBean</h2><p>在前面我们分析 Spring IOC 容器实例化 Bean 并进行依赖注入过程的源码时，提到在 getBean 方法触<br>发容器实例化 Bean 的时候会调用 AbstractBeanFactory 的 doGetBean 方法来进行实例化的过程，源码<br>如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line">//真正实现向 IOC 容器获取 Bean 的功能，也是触发依赖注入功能的地方</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">protected &lt;T&gt; T doGetBean(</span><br><span class="line">        final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)</span><br><span class="line">        throws BeansException &#123;</span><br><span class="line">    //根据指定的名称获取被管理 Bean 的名称，剥离指定名称中对容器的相关依赖</span><br><span class="line">    //如果指定的是别名，将别名转换为规范的 Bean 名称</span><br><span class="line">    final String beanName = transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line"></span><br><span class="line">    // Eagerly check singleton cache for manually registered singletons.</span><br><span class="line">    //先从缓存中取是否已经有被创建过的单态类型的 Bean</span><br><span class="line">    //对于单例模式的 Bean 整个 IOC 容器中只创建一次，不需要重复创建</span><br><span class="line">    Object sharedInstance = getSingleton(beanName);</span><br><span class="line">    //IOC 容器创建单例模式 Bean 实例对象</span><br><span class="line">    if (sharedInstance != null &amp;&amp; args == null) &#123;</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            //如果指定名称的 Bean 在容器中已有单例模式的 Bean 被创建</span><br><span class="line">            //直接返回已经创建的 Bean</span><br><span class="line">            if (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                logger.debug(&quot;Returning eagerly cached instance of singleton bean &apos;&quot; + beanName +</span><br><span class="line">                        &quot;&apos; that is not fully initialized yet - a consequence of a circular reference&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                logger.debug(&quot;Returning cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //获取给定 Bean 的实例对象，主要是完成 FactoryBean 的相关处理</span><br><span class="line">        //注意：BeanFactory 是管理容器中 Bean 的工厂，而 FactoryBean 是创建创建对象的工厂 Bean，两者之间有区别</span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else &#123;</span><br><span class="line">        // Fail if we&apos;re already creating this bean instance:</span><br><span class="line">        // We&apos;re assumably within a circular reference.</span><br><span class="line">        //缓存没有正在创建的单例模式 Bean</span><br><span class="line">        //缓存中已经有已经创建的原型模式 Bean</span><br><span class="line">        //但是由于循环引用的问题导致实例化对象失败</span><br><span class="line">        if (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Check if bean definition exists in this factory.</span><br><span class="line">        //对 IOC 容器中是否存在指定名称的 BeanDefinition 进行检查，首先检查是否</span><br><span class="line">        //能在当前的 BeanFactory 中获取的所需要的 Bean，如果不能则委托当前容器</span><br><span class="line">        //的父级容器去查找，如果还是找不到则沿着容器的继承体系向父级容器查找</span><br><span class="line">        // 为什么要委托父容器去找呢？</span><br><span class="line">        // ioc容器是可以被关联的：FileSystemXmlApplicationContext(String[] configLocations, ApplicationContext parent)</span><br><span class="line">        BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">        //当前容器的父级容器存在，且当前容器中不存在指定名称的 Bean</span><br><span class="line">        if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            // Not found -&gt; check parent.</span><br><span class="line">            //解析指定 Bean 名称的原始名称</span><br><span class="line">            // 因为有可能是通过别名去获取bean</span><br><span class="line">            String nameToLookup = originalBeanName(name);</span><br><span class="line">            if (args != null) &#123;</span><br><span class="line">                // Delegation to parent with explicit args.</span><br><span class="line">                //委派父级容器根据指定名称和显式的参数查找</span><br><span class="line">                // 为什么不传类型再去校验一次？</span><br><span class="line">                // 因为这一步是强转成T ， 如果类型不一样, 在后续的调用中会报错ClassCastException</span><br><span class="line">                return (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                // No args -&gt; delegate to standard getBean method.</span><br><span class="line">                //委派父级容器根据指定名称和类型查找</span><br><span class="line">                return parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //创建的 Bean 是否需要进行类型验证，一般不需要</span><br><span class="line">        if (!typeCheckOnly) &#123;</span><br><span class="line">            //向容器标记指定的 Bean 已经被创建</span><br><span class="line">            markBeanAsCreated(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //根据指定 Bean 名称获取其父级的 Bean 定义</span><br><span class="line">            //主要解决 Bean 继承时子类合并父类公共属性问题</span><br><span class="line">            final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            // Guarantee initialization of beans that the current bean depends on.</span><br><span class="line">            //获取当前 Bean 所有依赖 Bean 的名称</span><br><span class="line">            String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            //如果当前 Bean 有依赖 Bean</span><br><span class="line">            if (dependsOn != null) &#123;</span><br><span class="line">                for (String dependsOnBean : dependsOn) &#123;</span><br><span class="line">                    //递归调用 getBean 方法，获取当前 Bean 的依赖 Bean</span><br><span class="line">                    getBean(dependsOnBean);</span><br><span class="line">                    //把被依赖 Bean 注册给当前依赖的 Bean</span><br><span class="line">                    registerDependentBean(dependsOnBean, beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Create bean instance.</span><br><span class="line">            //创建单例模式 Bean 的实例对象</span><br><span class="line">            if (mbd.isSingleton()) &#123;</span><br><span class="line">                //这里使用了一个匿名内部类，创建 Bean 实例对象，并且注册给所依赖的对象</span><br><span class="line">                sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                    public Object getObject() throws BeansException &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            //创建一个指定 Bean 实例对象，如果有父级继承，则合并子类和父类的定义</span><br><span class="line">                            // AbstractAutowireCapableBeanFactory 中实现了该方法</span><br><span class="line">                            return createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        catch (BeansException ex) &#123;</span><br><span class="line">                            // Explicitly remove instance from singleton cache: It might have been put there</span><br><span class="line">                            // eagerly by the creation process, to allow for circular reference resolution.</span><br><span class="line">                            // Also remove any beans that received a temporary reference to the bean.</span><br><span class="line">                            //显式地从容器单例模式 Bean 缓存中清除实例对象</span><br><span class="line">                            // 其实就是从各种map中吧这个对象给remove掉</span><br><span class="line">                            destroySingleton(beanName);</span><br><span class="line">                            throw ex;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                //获取给定 Bean 的实例对象</span><br><span class="line">                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            //IOC 容器创建原型模式 Bean 实例对象</span><br><span class="line">            else if (mbd.isPrototype()) &#123;</span><br><span class="line">                // It&apos;s a prototype -&gt; create a new instance.</span><br><span class="line">                //原型模式(Prototype)是每次都会创建一个新的对象</span><br><span class="line">                Object prototypeInstance = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //回调 beforePrototypeCreation 方法，默认的功能是注册当前创建的原型对象</span><br><span class="line">                    beforePrototypeCreation(beanName);</span><br><span class="line">                    //创建指定 Bean 对象实例</span><br><span class="line">                    prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">                &#125;</span><br><span class="line">                finally &#123;</span><br><span class="line">                    //回调 afterPrototypeCreation 方法，默认的功能告诉 IoC 容器指定 Bean 的原型对象不再创建了</span><br><span class="line">                    //就是该bean已经从ing状态变成了ed状态</span><br><span class="line">                    afterPrototypeCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                //获取给定 Bean 的实例对象</span><br><span class="line">                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            //要创建的 Bean 既不是单例模式，也不是原型模式，则根据 Bean 定义资源中</span><br><span class="line">            //配置的生命周期范围，选择实例化 Bean 的合适方法，这种在 Web 应用程序中</span><br><span class="line">            //比较常用，如：request、session、application 等生命周期</span><br><span class="line">            else &#123;</span><br><span class="line">                String scopeName = mbd.getScope();</span><br><span class="line">                //其实scopt也是用map去管理的, 这样的很多地方就能理解通了</span><br><span class="line">                final Scope scope = this.scopes.get(scopeName);</span><br><span class="line">                //Bean 定义资源中没有配置生命周期范围，则 Bean 定义不合法</span><br><span class="line">                if (scope == null) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;No Scope registered for scope &apos;&quot; + scopeName + &quot;&apos;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //这里又使用了一个匿名内部类，获取一个指定生命周期范围的实例</span><br><span class="line">                    Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                        public Object getObject() throws BeansException &#123;</span><br><span class="line">                            beforePrototypeCreation(beanName);</span><br><span class="line">                            try &#123;</span><br><span class="line">                                // AbstractAutowireCapableBeanFactory 中实现了该方法</span><br><span class="line">                                return createBean(beanName, mbd, args);</span><br><span class="line">                            &#125;</span><br><span class="line">                            finally &#123;</span><br><span class="line">                                afterPrototypeCreation(beanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    //获取给定 Bean 的实例对象</span><br><span class="line">                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (IllegalStateException ex) &#123;</span><br><span class="line">                    throw new BeanCreationException(beanName,</span><br><span class="line">                            &quot;Scope &apos;&quot; + scopeName + &quot;&apos; is not active for the current thread; &quot; +</span><br><span class="line">                            &quot;consider defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,</span><br><span class="line">                            ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (BeansException ex) &#123;</span><br><span class="line">            cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">            throw ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Check if required type matches the type of the actual bean instance.</span><br><span class="line">    //对创建的 Bean 实例对象进行类型检查</span><br><span class="line">    if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (TypeMismatchException ex) &#123;</span><br><span class="line">            if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(&quot;Failed to convert bean &apos;&quot; + name + &quot;&apos; to required type [&quot; +</span><br><span class="line">                        ClassUtils.getQualifiedName(requiredType) + &quot;]&quot;, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">//获取给定 Bean 的实例对象，主要是完成 FactoryBean 的相关处理</span><br><span class="line">protected Object getObjectForBeanInstance(</span><br><span class="line">        Object beanInstance, String name, String beanName, RootBeanDefinition mbd) &#123;</span><br><span class="line"></span><br><span class="line">    //容器已经得到了 Bean 实例对象，这个实例对象可能是一个普通的 Bean，</span><br><span class="line">    //也可能是一个工厂 Bean，如果是一个工厂 Bean，则使用它创建一个 Bean 实例对象，</span><br><span class="line">    //如果调用本身就想获得一个容器的引用，则指定返回这个工厂 Bean 实例对象</span><br><span class="line">    //如果指定的名称是容器的解引用(dereference，即是对象本身而非内存地址)，</span><br><span class="line">    //且 Bean 实例也不是创建 Bean 实例对象的工厂 Bean</span><br><span class="line">    // Don&apos;t let calling code try to dereference the factory if the bean isn&apos;t a factory.</span><br><span class="line">    // name 是否是工厂bean标记</span><br><span class="line">    // beanInstance 是否继承factoryBean</span><br><span class="line">    if (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance instanceof FactoryBean)) &#123;</span><br><span class="line">        throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Now we have the bean instance, which may be a normal bean or a FactoryBean.</span><br><span class="line">    // If it&apos;s a FactoryBean, we use it to create a bean instance, unless the</span><br><span class="line">    // caller actually wants a reference to the factory.</span><br><span class="line">    // 1、true || false 普通类 纯的普通类</span><br><span class="line">    // 2、false || true  工厂类 纯的工厂</span><br><span class="line">    // 3、false || false 普通类 没有定义为工厂的普通工厂类</span><br><span class="line">    //如果 Bean 实例不是工厂 Bean，或者指定名称是容器的解引用，</span><br><span class="line">    //调用者向获取对容器的引用，则直接返回当前的 Bean 实例</span><br><span class="line">    if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">        return beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    //处理指定名称不是容器的解引用，或者根据名称获取的 Bean 实例对象是一个工厂 Bean</span><br><span class="line">    //使用工厂 Bean 创建一个 Bean 的实例对象</span><br><span class="line">    Object object = null;</span><br><span class="line">    if (mbd == null) &#123;</span><br><span class="line">        // 真正的ioc容器</span><br><span class="line">        //从 Bean 工厂缓存中获取给定名称的 Bean 实例对象</span><br><span class="line">        object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    //让 Bean 工厂生产给定名称的 Bean 对象实例</span><br><span class="line">    if (object == null) &#123;</span><br><span class="line">        // Return bean instance from factory.</span><br><span class="line">        FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">        // Caches object obtained from FactoryBean if it is a singleton.</span><br><span class="line">        //如果从 Bean 工厂生产的 Bean 是单态模式的，则缓存</span><br><span class="line">        if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            //从容器中获取指定名称的 Bean 定义，如果继承基类，则合并基类相关属性</span><br><span class="line">            mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        // 是否是合成的，意思就是是否当做工具类来使用</span><br><span class="line">        // 这里的synthetic实际上是为了给用户自定义一些BeanDefinition注册到容器中以当作工具类来使用。</span><br><span class="line">        // 什么是synthetic</span><br><span class="line">        // 就是内部类，java在编译的时候内部类也会编译成单独的一个文件，那实际上，原始类及时两个类的合成类</span><br><span class="line">        // 工具类就没有必要做一些封装、代理等工作，实际上是拿来就用，没有其他处理</span><br><span class="line">        // 对于synthetic类型的BeanDefinition，getObjectFromFactoryBean中是不会对FactoryBean生成的bean用post-processor进行后置处理的。</span><br><span class="line">        // 后置处理的实现是在AbstractAutowireCapableBeanFactory.postProcessObjectFromFactoryBean中，</span><br><span class="line">        // 它会调用容器中的BeanPostProcessor.postProcessAfterInitialization,这里提供了一个扩展点对FactoryBean生成的bean进行封装，代理等</span><br><span class="line">        //如果从容器得到 Bean 定义信息，并且 Bean 定义信息不是虚构的，</span><br><span class="line">        //则让工厂 Bean 生产 Bean 实例对象</span><br><span class="line">        boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic());</span><br><span class="line">        // bean实例化的缓存</span><br><span class="line">        //调用 FactoryBeanRegistrySupport 类的 getObjectFromFactoryBean 方法，</span><br><span class="line">        //实现工厂 Bean 生产 Bean 对象实例的过程</span><br><span class="line">        object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">    &#125;</span><br><span class="line">    return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面获取给定 Bean 的实例对象的 getObjectForBeanInstance 方法中，会调用<br>FactoryBeanRegistrySupport 类的 getObjectFromFactoryBean 方法，该方法实现了 Bean 工厂生产 Bean<br>实例对象。</p><p>Dereference(解引用)：一个在 C/C<ins>中应用比较多的术语，在 C</ins>中，<code>*</code>是解引用符号，而<code>&amp;</code>是<br>引用符号，解引用是指变量指向的是所引用对象的本身数据，而不是引用对象的内存地址。</p><h2><a id="AbstractBeanFactory__Bean__81"></a><a class="header-anchor" href="#abstractbeanfactory-生产-bean-实例对象">¶</a>AbstractBeanFactory 生产 Bean 实例对象</h2><p>AbstractBeanFactory 类中生产 Bean 实例对象的主要源码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//Bean 工厂生产 Bean 实例对象</span><br><span class="line">protected Object getObjectFromFactoryBean(FactoryBean&lt;?&gt; factory, String beanName, boolean shouldPostProcess) &#123;</span><br><span class="line">    //Bean 工厂是单态模式，并且 Bean 工厂缓存中存在指定名称的 Bean 实例对象</span><br><span class="line">    if (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line">        //多线程同步，以防止数据不一致</span><br><span class="line">        synchronized (getSingletonMutex()) &#123;</span><br><span class="line">            //直接从 Bean 工厂缓存中获取指定名称的 Bean 实例对象</span><br><span class="line">            Object object = this.factoryBeanObjectCache.get(beanName);</span><br><span class="line">            if (object == null) &#123;</span><br><span class="line">                //调用 Bean 工厂的 getObject 方法生产指定 Bean 的实例对象</span><br><span class="line">                object = doGetObjectFromFactoryBean(factory, beanName, shouldPostProcess);</span><br><span class="line">                //将生产的实例对象添加到 Bean 工厂缓存中</span><br><span class="line">                this.factoryBeanObjectCache.put(beanName, (object != null ? object : NULL_OBJECT));</span><br><span class="line">            &#125;</span><br><span class="line">            return (object != NULL_OBJECT ? object : null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //调用 Bean 工厂的 getObject 方法生产指定 Bean 的实例对象</span><br><span class="line">    else &#123;</span><br><span class="line">        return doGetObjectFromFactoryBean(factory, beanName, shouldPostProcess);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//调用 Bean 工厂的 getObject 方法生产指定 Bean 的实例对象</span><br><span class="line">private Object doGetObjectFromFactoryBean(</span><br><span class="line">        final FactoryBean&lt;?&gt; factory, final String beanName, final boolean shouldPostProcess)</span><br><span class="line">        throws BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    Object object;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (System.getSecurityManager() != null) &#123;</span><br><span class="line">            AccessControlContext acc = getAccessControlContext();</span><br><span class="line">            try &#123;</span><br><span class="line">                //实现 PrivilegedExceptionAction 接口的匿名内置类</span><br><span class="line">                //根据 JVM 检查权限，然后决定 BeanFactory 创建实例对象</span><br><span class="line">                object = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line">                    public Object run() throws Exception &#123;</span><br><span class="line">                            //调用 BeanFactory 接口实现类的创建对象方法</span><br><span class="line">                            return factory.getObject();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, acc);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (PrivilegedActionException pae) &#123;</span><br><span class="line">                throw pae.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            //调用 BeanFactory 接口实现类的创建对象方法</span><br><span class="line">            object = factory.getObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (FactoryBeanNotInitializedException ex) &#123;</span><br><span class="line">        throw new BeanCurrentlyInCreationException(beanName, ex.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable ex) &#123;</span><br><span class="line">        throw new BeanCreationException(beanName, &quot;FactoryBean threw exception on object creation&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Do not accept a null value for a FactoryBean that&apos;s not fully</span><br><span class="line">    // initialized yet: Many FactoryBeans just return null then.</span><br><span class="line">    //创建出来的实例对象为 null，或者因为单态对象正在创建而返回 null</span><br><span class="line">    if (object == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        throw new BeanCurrentlyInCreationException(</span><br><span class="line">                beanName, &quot;FactoryBean which is currently in creation returned null from getObject&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //为创建出来的 Bean 实例对象添加 BeanPostProcessor 后置处理器</span><br><span class="line">    if (object != null &amp;&amp; shouldPostProcess) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable ex) &#123;</span><br><span class="line">            throw new BeanCreationException(beanName, &quot;Post-processing of the FactoryBean&apos;s object failed&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的源码分析中，我们可以看出，BeanFactory 接口调用其实现类的 getObject 方法来实现创建 Bean<br>实例对象的功能</p><h2><a id="_Bean__getObject__Bean__88"></a><a class="header-anchor" href="#工厂-bean-的实现类-getobject-方法创建-bean-实例对象">¶</a>工厂 Bean 的实现类 getObject 方法创建 Bean 实例对象</h2><p>FactoryBean的实现类有非常多，比如：Proxy、RMI、JNDI、ServletContextFactoryBean等等，FactoryBean<br>接口为 Spring 容器提供了一个很好的封装机制，具体的 getObject 有不同的实现类根据不同的实现策<br>略来具体提供，我们分析一个最简单的 AnnotationTestFactoryBean 的实现源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class AnnotationTestBeanFactory implements FactoryBean&lt;FactoryCreatedAnnotationTestBean&gt; &#123;</span><br><span class="line"></span><br><span class="line">	private final FactoryCreatedAnnotationTestBean instance = new FactoryCreatedAnnotationTestBean();</span><br><span class="line"></span><br><span class="line">	public AnnotationTestBeanFactory() &#123;</span><br><span class="line">		this.instance.setName(&quot;FACTORY&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	//AnnotationTestBeanFactory 产生 Bean 实例对象的实现</span><br><span class="line">	public FactoryCreatedAnnotationTestBean getObject() throws Exception &#123;</span><br><span class="line">		return this.instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Class&lt;? extends IJmxTestBean&gt; getObjectType() &#123;</span><br><span class="line">		return FactoryCreatedAnnotationTestBean.class;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public boolean isSingleton() &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的 Proxy，RMI，JNDI 等等，都是根据相应的策略提供 getObject 的实现。这里不做一一分析，这<br>已经不是 Spring 的核心功能，有需要的时候再去深入研究。</p><h1><a id="BeanPostProcessor__96"></a>BeanPostProcessor 后置处理器的实现</h1><p>BeanPostProcessor 后置处理器是 Spring IOC 容器经常使用到的一个特性，这个 Bean 后置处理器是一<br>个监听器，可以监听容器触发的 Bean 声明周期事件。后置处理器向容器注册以后，容器中管理的 Bean<br>就具备了接收 IOC 容器事件回调的能力。</p><p>BeanPostProcessor 的使用非常简单，只需要提供一个实现接口 BeanPostProcessor 的实现类，然后在<br>Bean 的配置文件中设置即可。</p><h2><a id="BeanPostProcessor__104"></a><a class="header-anchor" href="#beanpostprocessor-的源码如下">¶</a>BeanPostProcessor 的源码如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.beans.factory.config;</span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">public interface BeanPostProcessor &#123;</span><br><span class="line">    //为在 Bean 的初始化前提供回调入口</span><br><span class="line">    Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;</span><br><span class="line">    //为在 Bean 的初始化之后提供回调入口</span><br><span class="line">    Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个回调的入口都是和容器管理的 Bean 的生命周期事件紧密相关，可以为用户提供在 Spring IOC<br>容器初始化 Bean 过程中自定义的处理操作。</p><h2><a id="AbstractAutowireCapableBeanFactory__Bean__109"></a><a class="header-anchor" href="#abstractautowirecapablebeanfactory-类对容器生成的-bean-添加后置处理器">¶</a>AbstractAutowireCapableBeanFactory 类对容器生成的 Bean 添加后置处理器</h2><p>BeanPostProcessor后置处理器的调用发生在Spring IOC容器完成对Bean实例对象的创建和属性的依<br>赖注入完成之后，在对 Spring 依赖注入的源码分析过程中我们知道，当应用程序第一次调用 getBean<br>方法(lazy-init 预实例化除外)向 Spring IOC 容器索取指定 Bean 时触发 Spring IOC 容器创建 Bean<br>实例对象并进行依赖注入的过程，其中真正实现创建 Bean 对象并进行依赖注入的方法是<br>AbstractAutowireCapableBeanFactory 类的 doCreateBean 方法，主要源码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//真正创建 Bean 的方法</span><br><span class="line">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) &#123;</span><br><span class="line">	//创建 Bean 实例对象</span><br><span class="line">	……</span><br><span class="line">	try &#123;</span><br><span class="line">		//对 Bean 属性进行依赖注入</span><br><span class="line">		populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">		if (exposedObject != null) &#123;</span><br><span class="line">			//在对 Bean 实例对象生成和依赖注入完成以后，开始对 Bean 实例对象</span><br><span class="line">			//进行初始化 ，为 Bean 实例对象应用 BeanPostProcessor 后置处理器</span><br><span class="line">			exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException)</span><br><span class="line">				ex).getBeanName())) &#123;</span><br><span class="line">			throw (BeanCreationException) ex;</span><br><span class="line">	&#125;</span><br><span class="line">	……</span><br><span class="line">	//为应用返回所需要的实例对象</span><br><span class="line">	return exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中我们知道，为 Bean 实例对象添加 BeanPostProcessor 后置处理器的入口的是<br>initializeBean 方法。</p><h2><a id="initializeBean__Bean__BeanPostProcessor__119"></a><a class="header-anchor" href="#initializebean-方法为容器产生的-bean-实例对象添加-beanpostprocessor-后置处理器">¶</a>initializeBean 方法为容器产生的 Bean 实例对象添加 BeanPostProcessor 后置处理器</h2><p>同样在 AbstractAutowireCapableBeanFactory 类中，initializeBean 方法实现为容器创建的 Bean 实例<br>对象添加 BeanPostProcessor 后置处理器，源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//初始容器创建的 Bean 实例对象，为其添加 BeanPostProcessor 后置处理器</span><br><span class="line">protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123;</span><br><span class="line">    //JDK 的安全机制验证权限</span><br><span class="line">    if (System.getSecurityManager() != null) &#123;</span><br><span class="line">        //实现 PrivilegedAction 接口的匿名内部类</span><br><span class="line">        AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">            public Object run() &#123;</span><br><span class="line">                invokeAwareMethods(beanName, bean);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        //为 Bean 实例对象包装相关属性，如名称，类加载器，所属容器等信息</span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    //对 BeanPostProcessor 后置处理器的 postProcessBeforeInitialization</span><br><span class="line">    //回调方法的调用，为 Bean 实例初始化前做一些处理</span><br><span class="line">    if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    //调用 Bean 实例对象初始化的方法，这个初始化方法是在 Spring Bean 定义配置</span><br><span class="line">    //文件中通过 init-method 属性指定的</span><br><span class="line">    try &#123;</span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable ex) &#123;</span><br><span class="line">        throw new BeanCreationException(</span><br><span class="line">                (mbd != null ? mbd.getResourceDescription() : null),</span><br><span class="line">                beanName, &quot;Invocation of init method failed&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    //对 BeanPostProcessor 后置处理器的 postProcessAfterInitialization</span><br><span class="line">    //回调方法的调用，为 Bean 实例初始化之后做一些处理</span><br><span class="line">    if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    return wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//调用 BeanPostProcessor 后置处理器实例对象初始化之前的处理方法</span><br><span class="line">public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)</span><br><span class="line">        throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">    Object result = existingBean;</span><br><span class="line">    //遍历容器为所创建的 Bean 添加的所有 BeanPostProcessor 后置处理器</span><br><span class="line">    for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">        //调用 Bean 实例所有的后置处理中的初始化前处理方法，为 Bean 实例对象在</span><br><span class="line">        //初始化之前做一些自定义的处理操作</span><br><span class="line">        result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">        if (result == null) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用 BeanPostProcessor 后置处理器实例对象初始化之后的处理方法</span><br><span class="line">public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)</span><br><span class="line">        throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">    Object result = existingBean;</span><br><span class="line">    //遍历容器为所创建的 Bean 添加的所有 BeanPostProcessor 后置处理器</span><br><span class="line">    for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">        //调用 Bean 实例所有的后置处理中的初始化后处理方法，为 Bean 实例对象在</span><br><span class="line">        //初始化之后做一些自定义的处理操作</span><br><span class="line">        result = beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">        if (result == null) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanPostProcessor 是一个接口，其初始化前的操作方法和初始化后的操作方法均委托其实现子类来实<br>现，在 Spring 中，BeanPostProcessor 的实现子类非常的多，分别完成不同的操作，如：AOP 面向切面<br>编程的注册通知适配器、Bean 对象的数据校验、Bean 继承属性/方法的合并等等，我们以最简单的 AOP<br>切面织入来简单了解其主要的功能。</p><h2><a id="AdvisorAdapterRegistrationManager__Bean__129"></a><a class="header-anchor" href="#advisoradapterregistrationmanager-在-bean-对象初始化后注册通知适配器">¶</a>AdvisorAdapterRegistrationManager 在 Bean 对象初始化后注册通知适配器</h2><p>AdvisorAdapterRegistrationManager 是 BeanPostProcessor 的一个实现类，其主要的作用为容器中管<br>理的 Bean 注册一个面向切面编程的通知适配器，以便在 Spring 容器为所管理的 Bean 进行面向切面编<br>程时提供方便，其源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//为容器中管理的 Bean 注册一个面向切面编程的通知适配器</span><br><span class="line">public class AdvisorAdapterRegistrationManager implements BeanPostProcessor &#123;</span><br><span class="line">	//容器中负责管理切面通知适配器注册的对象</span><br><span class="line">	private AdvisorAdapterRegistry advisorAdapterRegistry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Specify the AdvisorAdapterRegistry to register AdvisorAdapter beans with.</span><br><span class="line">	 * Default is the global AdvisorAdapterRegistry.</span><br><span class="line">	 * @see GlobalAdvisorAdapterRegistry</span><br><span class="line">	 */</span><br><span class="line">	public void setAdvisorAdapterRegistry(AdvisorAdapterRegistry advisorAdapterRegistry) &#123;</span><br><span class="line">		this.advisorAdapterRegistry = advisorAdapterRegistry;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//BeanPostProcessor 在 Bean 对象初始化前的操作</span><br><span class="line">	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">		//没有做任何操作，直接返回容器创建的 Bean 对象</span><br><span class="line">		return bean;</span><br><span class="line">	&#125;</span><br><span class="line">	//BeanPostProcessor 在 Bean 对象初始化后的操作</span><br><span class="line">	public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">		if (bean instanceof AdvisorAdapter)&#123;</span><br><span class="line">			//如果容器创建的 Bean 实例对象是一个切面通知适配器，则向容器的注册</span><br><span class="line">			this.advisorAdapterRegistry.registerAdvisorAdapter((AdvisorAdapter) bean);</span><br><span class="line">		&#125;</span><br><span class="line">		return bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的 BeanPostProcessor 接口实现类的也类似，都是对 Bean 对象使用到的一些特性进行处理，或者<br>向 IOC 容器中注册，为创建的 Bean 实例对象做一些自定义的功能增加，这些操作是容器初始化 Bean 时<br>自动触发的，不需要认为的干预。</p><h1><a id="Spring_IOC__autowiring__138"></a>Spring IOC 容器 autowiring 实现原理</h1><p>Spring IOC 容器提供了两种管理 Bean 依赖关系的方式：</p><ul><li>显式管理：通过 BeanDefinition 的属性值和构造方法实现 Bean 依赖关系管理。</li><li>autowiring：Spring IOC 容器的依赖自动装配功能，不需要对 Bean 属性的依赖关系做显式的声明，只需要在配置好 autowiring 属性，IOC 容器会自动使用反射查找属性的类型和名称，然后基于属性的类型或者名称来自动匹配容器中管理的 Bean，从而自动地完成依赖注入。</li></ul><p>通过对 autowiring 自动装配特性的理解，我们知道容器对 Bean 的自动装配发生在容器对 Bean 依赖注<br>入的过程中。在前面对 Spring IOC 容器的依赖注入过程源码分析中，我们已经知道了容器对 Bean 实<br>例对象的属性注入的处理发生在 AbstractAutoWireCapableBeanFactory 类中的 populateBean 方法中，<br>我们通过程序流程分析 autowiring 的实现原理</p><h2><a id="AbstractAutoWireCapableBeanFactory__Bean__148"></a><a class="header-anchor" href="#abstractautowirecapablebeanfactory-对-bean-实例进行属性依赖注入">¶</a>AbstractAutoWireCapableBeanFactory 对 Bean 实例进行属性依赖注入</h2><p>应用第一次通过 getBean 方法(配置了 lazy-init 预实例化属性的除外)向 IoC 容器索取 Bean 时，容器<br>创建 Bean 实例对象，并且对 Bean 实例对象进行属性依赖注入，AbstractAutoWireCapableBeanFactory<br>的 populateBean 方法就是实现 Bean 属性依赖注入的功能，其主要源码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected void populateBean(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw) &#123;</span><br><span class="line">//获取 Bean 定义的属性值，并对属性值进行处理</span><br><span class="line">PropertyValues pvs = mbd.getPropertyValues();</span><br><span class="line">……</span><br><span class="line">    //对依赖注入处理，首先处理 autowiring 自动装配的依赖注入</span><br><span class="line">    if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">        mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">        </span><br><span class="line">        MutablePropertyValues newPvs = new MutablePropertyValues(pvs);</span><br><span class="line">        //根据 Bean 名称进行 autowiring 自动装配处理</span><br><span class="line">        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">            autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line">        //根据 Bean 类型进行 autowiring 自动装配处理</span><br><span class="line">        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">            autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //对非 autowiring 的属性进行依赖注入处理</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><a id="Spring_IOC__Bean__autowiring__154"></a><a class="header-anchor" href="#spring-ioc-容器根据-bean-名称或者类型进行-autowiring-自动依赖注入：">¶</a>Spring IOC 容器根据 Bean 名称或者类型进行 autowiring 自动依赖注入：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">//根据名称对属性进行自动依赖注入</span><br><span class="line">protected void autowireByName(</span><br><span class="line">        String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) &#123;</span><br><span class="line">    //对 Bean 对象中非简单属性(不是简单继承的对象，如 8 中原始类型，字符串，URL 等都是简单属性)进行处理</span><br><span class="line">    String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">    for (String propertyName : propertyNames) &#123;</span><br><span class="line">        //如果 Spring IOC 容器中包含指定名称的 Bean</span><br><span class="line">        if (containsBean(propertyName)) &#123;</span><br><span class="line">            //使用当前Bean的属性名，在IoC容器中获取对应的bean，让将获取的bean设置为当前的Bean的属性值</span><br><span class="line">            //调用 getBean 方法向 IoC 容器索取指定名称的 Bean 实例，迭代触发属性的初始化和依赖注入</span><br><span class="line">            Object bean = getBean(propertyName);</span><br><span class="line">            //为指定名称的属性赋予属性值</span><br><span class="line">            pvs.add(propertyName, bean);</span><br><span class="line">            //指定名称属性注册依赖 Bean 名称，进行属性依赖注入</span><br><span class="line">            registerDependentBean(propertyName, beanName);</span><br><span class="line">            if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(&quot;Added autowiring by name from bean name &apos;&quot; + beanName +</span><br><span class="line">                        &quot;&apos; via property &apos;&quot; + propertyName + &quot;&apos; to bean named &apos;&quot; + propertyName + &quot;&apos;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            if (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(&quot;Not autowiring property &apos;&quot; + propertyName + &quot;&apos; of bean &apos;&quot; + beanName +</span><br><span class="line">                        &quot;&apos; by name: no matching bean found&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//根据类型对属性进行自动依赖注入</span><br><span class="line">protected void autowireByType(</span><br><span class="line">        String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) &#123;</span><br><span class="line">    //获取用户定义的类型转换器</span><br><span class="line">    TypeConverter converter = getCustomTypeConverter();</span><br><span class="line">    if (converter == null) &#123;</span><br><span class="line">        converter = bw;</span><br><span class="line">    &#125;</span><br><span class="line">    //存放解析的要注入的属性</span><br><span class="line">    Set&lt;String&gt; autowiredBeanNames = new LinkedHashSet&lt;String&gt;(4);</span><br><span class="line">    //对 Bean 对象中非简单属性(不是简单继承的对象，如 8 中原始类型，字符</span><br><span class="line">    //URL 等都是简单属性)进行处理</span><br><span class="line">    String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">    for (String propertyName : propertyNames) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //获取指定属性名称的属性描述器</span><br><span class="line">            PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);</span><br><span class="line">            // Don&apos;t try autowiring by type for type Object: never makes sense,</span><br><span class="line">            // even if it technically is a unsatisfied, non-simple property.</span><br><span class="line">            //不对 Object 类型的属性进行 autowiring 自动依赖注入</span><br><span class="line">            if (!Object.class.equals(pd.getPropertyType())) &#123;</span><br><span class="line">                //获取属性的 setter 方法</span><br><span class="line">                MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);</span><br><span class="line">                // Do not allow eager init for type matching in case of a prioritized post-processor.</span><br><span class="line">                //检查指定类型是否可以被转换为目标对象的类型</span><br><span class="line">                boolean eager = !PriorityOrdered.class.isAssignableFrom(bw.getWrappedClass());</span><br><span class="line">                //创建一个要被注入的依赖描述</span><br><span class="line">                DependencyDescriptor desc = new AutowireByTypeDependencyDescriptor(methodParam, eager);</span><br><span class="line">                //根据容器的 Bean 定义解析依赖关系，返回所有要被注入的 Bean 对象</span><br><span class="line">                Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);</span><br><span class="line">                if (autowiredArgument != null) &#123;</span><br><span class="line">                    //为属性赋值所引用的对象</span><br><span class="line">                    pvs.add(propertyName, autowiredArgument);</span><br><span class="line">                &#125;</span><br><span class="line">                for (String autowiredBeanName : autowiredBeanNames) &#123;</span><br><span class="line">                    //指定名称属性注册依赖 Bean 名称，进行属性依赖注入</span><br><span class="line">                    registerDependentBean(autowiredBeanName, beanName);</span><br><span class="line">                    if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                        logger.debug(&quot;Autowiring by type from bean name &apos;&quot; + beanName + &quot;&apos; via property &apos;&quot; +</span><br><span class="line">                                propertyName + &quot;&apos; to bean named &apos;&quot; + autowiredBeanName + &quot;&apos;&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //释放已自动注入的属性</span><br><span class="line">                autowiredBeanNames.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (BeansException ex) &#123;</span><br><span class="line">            throw new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的源码分析，我们可以看出来通过属性名进行自动依赖注入的相对比通过属性类型进行自动依<br>赖注入要稍微简单一些，但是真正实现属性注入的是 DefaultSingletonBeanRegistry 类的<br>registerDependentBean 方法。</p><h2><a id="DefaultSingletonBeanRegistry__registerDependentBean__160"></a><a class="header-anchor" href="#defaultsingletonbeanregistry-的-registerdependentbean-方法对属性注入">¶</a>DefaultSingletonBeanRegistry 的 registerDependentBean 方法对属性注入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//为指定的 Bean 注入依赖的 Bean</span><br><span class="line">public void registerDependentBean(String beanName, String dependentBeanName) &#123;</span><br><span class="line">    //处理 Bean 名称，将别名转换为规范的 Bean 名称</span><br><span class="line">    String canonicalName = canonicalName(beanName);</span><br><span class="line">    // 翻译一下就是：set里的bean都要依赖 key</span><br><span class="line">    //先从容器中：bean 名称--&gt;全部依赖 Bean 名称集合找查找给定名称 Bean 的依赖 Bean</span><br><span class="line">    //多线程同步，保证容器内数据的一致性</span><br><span class="line">    synchronized (this.dependentBeanMap) &#123;</span><br><span class="line">        //获取给定名称 Bean 的所有依赖 Bean 名称</span><br><span class="line">        Set&lt;String&gt; dependentBeans = this.dependentBeanMap.get(canonicalName);</span><br><span class="line">        if (dependentBeans == null) &#123;</span><br><span class="line">            //为 Bean 设置依赖 Bean 信息</span><br><span class="line">            dependentBeans = new LinkedHashSet&lt;String&gt;(8);</span><br><span class="line">            this.dependentBeanMap.put(canonicalName, dependentBeans);</span><br><span class="line">        &#125;</span><br><span class="line">        //向容器中：bean 名称--&gt;全部依赖 Bean 名称集合添加 Bean 的依赖信息</span><br><span class="line">        //即，将 Bean 所依赖的 Bean 添加到容器的集合中</span><br><span class="line">        dependentBeans.add(dependentBeanName);</span><br><span class="line">    &#125;</span><br><span class="line">    // 翻译一下就是：key需要依赖set中的bean</span><br><span class="line">    //从容器中：bean 名称--&gt;指定名称 Bean 的依赖 Bean 集合找查找给定名称 Bean 的依赖 Bean</span><br><span class="line">    synchronized (this.dependenciesForBeanMap) &#123;</span><br><span class="line">        Set&lt;String&gt; dependenciesForBean = this.dependenciesForBeanMap.get(dependentBeanName);</span><br><span class="line">        if (dependenciesForBean == null) &#123;</span><br><span class="line">            dependenciesForBean = new LinkedHashSet&lt;String&gt;(8);</span><br><span class="line">            this.dependenciesForBeanMap.put(dependentBeanName, dependenciesForBean);</span><br><span class="line">        &#125;</span><br><span class="line">        //向容器中：bean 名称--&gt;指定 Bean 的依赖 Bean 名称集合添加 Bean 的依赖信息</span><br><span class="line">        //即，将 Bean 所依赖的 Bean 添加到容器的集合中</span><br><span class="line">        dependenciesForBean.add(canonicalName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对 autowiring 的源码分析，我们可以看出，autowiring 的实现过程：</p><ul><li>对 Bean 的属性代调用 getBean 方法，完成依赖 Bean 的初始化和依赖注入。</li><li>将依赖 Bean 的属性引用设置到被依赖的 Bean 属性上。</li><li>将依赖 Bean 的名称和被依赖 Bean 的名称存储在 IOC 容器的集合中。</li></ul><p>Spring IOC 容器的 autowiring 属性自动依赖注入是一个很方便的特性，可以简化开发时的配置，但是凡是都有两面性，<br>自动属性依赖注入也有不足，首先，Bean 的依赖关系在配置文件中无法很清楚地看出来，对于维护造成一定困难。其<br>次，由于自动依赖注入是 Spring 容器自动执行的，容器是不会智能判断的，如果配置不当，将会带来无法预料的后果，<br>所以自动依赖注入特性在使用时还是综合考虑。</p></div><div id="wechat_subscriber" style="display:block;padding:10px 0;margin:20px auto;width:100%;text-align:center"><img id="wechat_subscriber_qcode" src="/blog/uploads/wechat-qcode.png" alt="Jeff-Eric wechat" style="width:200px;max-width:100%"><div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Jeff-Eric</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://jeff-eric.github.com/blog/2019/10/22/spring%20-%20IOC%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" title="spring - IOC高级特性">https:&#x2F;&#x2F;jeff-eric.github.com&#x2F;blog&#x2F;2019&#x2F;10&#x2F;22&#x2F;spring%20-%20IOC%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7&#x2F;</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank">&lt;i class=&quot;fa fa-fw fa-creative-commons&quot;&gt;&lt;&#x2F;i&gt;BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/blog/tags/%E6%9E%B6%E6%9E%84%E5%B8%88/" rel="tag"># 架构师</a></div><div class="post-widgets"><div class="social_share"><div id="needsharebutton-postbottom"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/blog/2019/10/22/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/" rel="next" title="软件架构设计的七大原则"><i class="fa fa-chevron-left"></i> 软件架构设计的七大原则</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/blog/2019/10/22/fq%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" rel="prev" title="fq软件安装">fq软件安装 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/blog/uploads/avatar.jpg" alt="Jeff-Eric"><p class="site-author-name" itemprop="name">Jeff-Eric</p><div class="site-description motion-element" itemprop="description"></div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/blog/archives/%20%7C%7C%20archive"><span class="site-state-item-count">42</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/blog/categories/%20%7C%7C%20th"><span class="site-state-item-count">12</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/blog/tags/%20%7C%7C%20tags"><span class="site-state-item-count">28</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/jeff-eric" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;jeff-eric" rel="noopener" target="_blank">&lt;i class=&quot;fa fa-fw fa-github&quot;&gt;&lt;&#x2F;i&gt;GitHub</a> </span><span class="links-of-author-item"><a href="/blog/jphoebe4086824@gmail.com" title="E-Mail &amp;rarr; jphoebe4086824@gmail.com">&lt;i class=&quot;fa fa-fw fa-envelope&quot;&gt;&lt;&#x2F;i&gt;E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank">&lt;img src=&quot;&#x2F;blog&#x2F;images&#x2F;cc-by-nc-sa.svg&quot; alt=&quot;Creative Commons&quot;&#x2F;&gt;</a></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">2.</span> <span class="nav-text">Spring IOC 容器的 lazy-init 属性实现预实例化：</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">2.1.</span> <span class="nav-text">¶refresh()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">2.2.</span> <span class="nav-text">¶finishBeanFactoryInitialization 处理预实例化 Bean</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">2.3.</span> <span class="nav-text">¶DefaultListableBeanFactory 对配置 lazy-init 属性单态 Bean 的预实例化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">3.</span> <span class="nav-text">FactoryBean 的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">3.1.</span> <span class="nav-text">¶FactoryBean 的源码如下</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">3.2.</span> <span class="nav-text">¶AbstractBeanFactory 的 getBean 方法调用 FactoryBean</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">3.3.</span> <span class="nav-text">¶AbstractBeanFactory 生产 Bean 实例对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">3.4.</span> <span class="nav-text">¶工厂 Bean 的实现类 getObject 方法创建 Bean 实例对象</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">4.</span> <span class="nav-text">BeanPostProcessor 后置处理器的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">4.1.</span> <span class="nav-text">¶BeanPostProcessor 的源码如下</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">4.2.</span> <span class="nav-text">¶AbstractAutowireCapableBeanFactory 类对容器生成的 Bean 添加后置处理器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">4.3.</span> <span class="nav-text">¶initializeBean 方法为容器产生的 Bean 实例对象添加 BeanPostProcessor 后置处理器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">4.4.</span> <span class="nav-text">¶AdvisorAdapterRegistrationManager 在 Bean 对象初始化后注册通知适配器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">5.</span> <span class="nav-text">Spring IOC 容器 autowiring 实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">5.1.</span> <span class="nav-text">¶AbstractAutoWireCapableBeanFactory 对 Bean 实例进行属性依赖注入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">5.2.</span> <span class="nav-text">¶Spring IOC 容器根据 Bean 名称或者类型进行 autowiring 自动依赖注入：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">5.3.</span> <span class="nav-text">¶DefaultSingletonBeanRegistry 的 registerDependentBean 方法对属性注入</span></a></li></ol></li></ol></div></div></div><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Jeff-Eric</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0</div><span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.0.1</div></div></footer><div id="needsharebutton-float"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script><script id="ribbon" size="300" alpha="0.6" zindex="-1" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@2/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/npm/fastclick@1/lib/fastclick.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery-lazyload@1/jquery.lazyload.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three-waves.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_lines.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_sphere.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-reading-progress@1/reading_progress.min.js"></script><script src="/blog/js/src/utils.js?v=7.0.1"></script><script src="/blog/js/src/motion.js?v=7.0.1"></script><script src="/blog/js/src/affix.js?v=7.0.1"></script><script src="/blog/js/src/schemes/pisces.js?v=7.0.1"></script><script src="/blog/js/src/scrollspy.js?v=7.0.1"></script><script src="/blog/js/src/post-details.js?v=7.0.1"></script><script src="/blog/js/src/next-boot.js?v=7.0.1"></script><script src="/blog/js/src/js.cookie.js?v=7.0.1"></script><script src="/blog/js/src/scroll-cookie.js?v=7.0.1"></script><script src="//cdn.jsdelivr.net/npm/leancloud-storage@3/dist/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js"></script><script>var GUEST=["nick","mail","link"],guest="nick,mail,link";guest=guest.split(",").filter(function(e){return GUEST.indexOf(e)>-1}),new Valine({el:"#comments",verify:!0,notify:!1,appId:"MKGyMx7EafphCr9hAbMPAwAc-gzGzoHsz",appKey:"4SB8MPoE51bFPHDoKtPM8vLG",placeholder:"Just go go",avatar:"mm",meta:guest,pageSize:"10",visitor:!0})</script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var e=$("#local-search-input");e.attr("autocapitalize","none"),e.attr("autocorrect","off"),e.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/blog/"+search_path,onPopupClose=function(e){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(e,t,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:e,dataType:isXml?"xml":"json",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,r=document.getElementById(t),s=document.getElementById(o),a=function(){var e=r.value.trim().toLowerCase(),t=e.split(/[\s\-]+/);t.length>1&&t.push(e);var o=[];if(e.length>0&&n.forEach(function(n){function r(t,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===e&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(e,t){var o="",n=t.start;return t.hits.forEach(function(t){o+=e.substring(n,t.position);var r=t.position+t.length;o+='<b class="search-keyword">'+e.substring(t.position,r)+"</b>",n=r}),o+=e.substring(n,t.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url).replace(/\/{2,}/g,"/"),d=[],g=[];if(""!=l&&(t.forEach(function(e){function t(e,t,o){var n=e.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(t=t.toLowerCase(),e=e.toLowerCase());(s=t.indexOf(e,r))>-1;)a.push({position:s,word:e}),r=s+n;return a}d=d.concat(t(e,h,!1)),g=g.concat(t(e,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(e){e.sort(function(e,t){return t.position!==e.position?t.position-e.position:e.word.length-t.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hits.length!==t.hits.length?t.hits.length-e.hits.length:e.start-t.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(e){b+="<a href='"+f+'\'><p class="search-result">'+s(p,e)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===t.length&&""===t[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x"></i></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>';else{o.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hitCount!==t.hitCount?t.hitCount-e.hitCount:t.id-e.id});var a='<ul class="search-result-list">';o.forEach(function(e){a+=e.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(e){e.stopPropagation()}),$(document).on("keyup",function(e){var t=27===e.which&&$(".search-popup").is(":visible");t&&onPopupClose()})</script><script src="https://www.gstatic.com/firebasejs/4.6.0/firebase.js"></script><script src="https://www.gstatic.com/firebasejs/4.6.0/firebase-firestore.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/bluebird/3.5.1/bluebird.core.min.js"></script><script>!function(){function getCount(t,e){return t.get().then(function(a){var n;return a.exists?(n=a.data().count,e&&(window.localStorage&&window.localStorage.getItem(title)||(t.set({count:n+1}),n++))):e?(t.set({count:1}),n=1):n=0,window.localStorage&&e&&localStorage.setItem(title,!0),n})}function appendCountTo(t){return function(e){$(t).append($("<span>").addClass("post-visitors-count").append($("<span>").addClass("post-meta-divider").text("|")).append($("<span>").addClass("post-meta-item-icon").append($("<i>").addClass("fa fa-users"))).append($("<span>").text("阅读次数 "+e)))}}firebase.initializeApp({apiKey:"AIzaSyD-BIMnFQcvrv1utthoP5z5shcYP8JMKmY",projectId:"blog-6cbe0"});var db=firebase.firestore(),articles=db.collection("articles"),isPost="spring - IOC高级特性".length>0,isArchive=!1,isCategory="".length>0,isTag="".length>0;if(isPost){var title="spring - IOC高级特性",doc=articles.doc(title);getCount(doc,!0).then(appendCountTo($(".post-meta")))}else if(!isArchive&&!isCategory&&!isTag){var titles=[],postsstr="";eval(postsstr);var promises=titles.map(function(t){return articles.doc(t)}).map(function(t){return getCount(t)});Promise.all(promises).then(function(t){var e=$(".post-meta");t.forEach(function(t,a){appendCountTo(e[a])(t)})})}}()</script><style>.pdfobject-container{position:relative;overflow:auto;width:100%}</style><script>$("body").find("div.pdf").length&&$.ajax({type:"GET",url:"//cdn.jsdelivr.net/npm/pdfobject@2.1.1/pdfobject.min.js",dataType:"script",cache:!0,success:function(){$("body").find("div.pdf").each(function(e,t){PDFObject.embed($(t).attr("target"),$(t),{pdfOpenParams:{navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"},PDFJS_URL:"/lib/pdf/web/viewer.html",height:$(t).attr("height")||"500px"})})}})</script><script>$("body").find("pre.mermaid").length&&$.ajax({type:"GET",url:"//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js",dataType:"script",cache:!0,success:function(){mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})}})</script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script><script>pbOptions={},pbOptions.iconStyle="box",pbOptions.boxForm="horizontal",pbOptions.position="bottomCenter",pbOptions.networks="Weibo,Wechat,Douban,QQZone,Twitter,Facebook",new needShareButton("#needsharebutton-postbottom",pbOptions),flOptions={},flOptions.iconStyle="box",flOptions.boxForm="horizontal",flOptions.position="middleRight",flOptions.networks="Weibo,Wechat,Douban,QQZone,Twitter,Facebook",new needShareButton("#needsharebutton-float",flOptions)</script><script src="//cdn.jsdelivr.net/npm/pangu@3/dist/browser/pangu.min.js"></script><script>pangu.spacingPage()</script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@1/bookmark.min.js"></script><script>bookmark.scrollToMark("auto","#更多")</script><style>.copy-btn{display:inline-block;padding:6px 12px;font-size:13px;font-weight:700;line-height:20px;color:#333;white-space:nowrap;vertical-align:middle;cursor:pointer;background-color:#eee;background-image:linear-gradient(#fcfcfc,#eee);border:1px solid #d5d5d5;border-radius:3px;user-select:none;outline:0}.highlight-wrap .copy-btn{transition:opacity .3s ease-in-out;opacity:0;padding:2px 6px;position:absolute;right:4px;top:8px}.highlight-wrap .copy-btn:focus,.highlight-wrap:hover .copy-btn{opacity:1}.highlight-wrap{position:relative}</style><script>$(".highlight").each(function(t,e){var n=$("<div>").addClass("highlight-wrap");$(e).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(t){var e=$(this).parent().find(".code").find(".line").map(function(t,e){return $(e).text()}).toArray().join("\n"),n=document.createElement("textarea"),o=window.pageYOffset||document.documentElement.scrollTop;n.style.top=o+"px",n.style.position="absolute",n.style.opacity="0",n.readOnly=!0,n.value=e,document.body.appendChild(n),n.select(),n.setSelectionRange(0,e.length),n.readOnly=!1;var a=document.execCommand("copy");a?$(this).text("复制成功"):$(this).text("复制失败"),n.blur(),$(this).blur()})).on("mouseleave",function(t){var e=$(this).find(".copy-btn");setTimeout(function(){e.text("复制")},300)}).append(e)})</script></body></html><!-- rebuild by neat -->