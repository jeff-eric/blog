<!-- build time:Tue Nov 26 2019 14:32:22 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-CN,zh-HK,zh-TW,en,default"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/han-css@3/dist/han.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css"><link rel="stylesheet" href="/blog/css/main.css?v=7.0.1"><link rel="apple-touch-icon" sizes="180x180" href="/blog/uploads/avatar.jpg?v=7.0.1"><link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/avatar.jpg?v=7.0.1"><link rel="icon" type="image/png" sizes="16x16" href="/blog/blog/uploads/avatar.jpg?v=7.0.1"><link rel="mask-icon" href="/blog/uploads/avatar.jpg?v=7.0.1" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/blog/",scheme:"Gemini",version:"7.0.1",sidebar:{position:"left",display:"always",offset:12,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!0,fancybox:!0,fastclick:!0,lazyload:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="依赖注入发生的时间当 Spring IOC 容器完成了 Bean 定义资源的定位、载入和解析注册以后，IOC 容器中已经管理类 Bean定义的相关数据，但是此时 IOC 容器还没有对所管理的 Bean 进行依赖注入，依赖注入在以下两种情况发生：用户第一次通过 getBean 方法向 IOC 容索要 Bean 时，IOC 容器触发依赖注入。当用户在 Bean 定义资源中为&amp;lt;Bean&amp;gt;元素"><meta name="keywords" content="架构师"><meta property="og:type" content="article"><meta property="og:title" content="spring - DI"><meta property="og:url" content="https:&#x2F;&#x2F;jeff-eric.github.com&#x2F;blog&#x2F;2019&#x2F;10&#x2F;22&#x2F;spring%20-%20DI&#x2F;index.html"><meta property="og:site_name" content="纯天然绿色学渣"><meta property="og:description" content="依赖注入发生的时间当 Spring IOC 容器完成了 Bean 定义资源的定位、载入和解析注册以后，IOC 容器中已经管理类 Bean定义的相关数据，但是此时 IOC 容器还没有对所管理的 Bean 进行依赖注入，依赖注入在以下两种情况发生：用户第一次通过 getBean 方法向 IOC 容索要 Bean 时，IOC 容器触发依赖注入。当用户在 Bean 定义资源中为&amp;lt;Bean&amp;gt;元素"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191108193417.png"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191114115523.png"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;DI%E6%B5%81%E7%A8%8B%E5%9B%BE.png"><meta property="og:updated_time" content="2019-11-14T06:46:22.531Z"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191108193417.png"><link rel="canonical" href="https://jeff-eric.github.com/blog/2019/10/22/spring - DI/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>spring - DI | 纯天然绿色学渣</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?bb5d4f8207d7c2bd1aa936180430bbaa";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/blog/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">纯天然绿色学渣</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-home&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;首页</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-tags&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;标签&lt;span class=&quot;badge&quot;&gt;28&lt;&#x2F;span&gt;</a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-th&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;分类&lt;span class=&quot;badge&quot;&gt;12&lt;&#x2F;span&gt;</a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-archive&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;归档&lt;span class=&quot;badge&quot;&gt;42&lt;&#x2F;span&gt;</a></li><li class="menu-item menu-item-tools"><a href="/blog/tools/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-tree&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;工具</a></li><li class="menu-item menu-item-search"><a href="javascript:;" target="_blank" rel="noopener" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><div class="reading-progress-bar"></div><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jeff-eric.github.com/blog/blog/2019/10/22/spring%20-%20DI/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jeff-Eric"><meta itemprop="description" content=""><meta itemprop="image" content="/blog/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="纯天然绿色学渣"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">spring - DI</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-22 18:51:56" itemprop="dateCreated datePublished" datetime="2019-10-22T18:51:56+08:00">2019-10-22</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-11-14 14:46:22" itemprop="dateModified" datetime="2019-11-14T14:46:22+08:00">2019-11-14</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/blog/2019/10/22/spring%20-%20DI/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/2019/10/22/spring%20-%20DI/" itemprop="commentCount"></span> </a></span><span id="/blog/2019/10/22/spring%20-%20DI/" class="leancloud_visitors" data-flag-title="spring - DI"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body han-init-context" itemprop="articleBody"><h1><a id="_1"></a>依赖注入发生的时间</h1><p>当 Spring IOC 容器完成了 Bean 定义资源的定位、载入和解析注册以后，IOC 容器中已经管理类 Bean<br>定义的相关数据，但是此时 IOC 容器还没有对所管理的 Bean 进行依赖注入，依赖注入在以下两种情况<br>发生：</p><ul><li>用户第一次通过 getBean 方法向 IOC 容索要 Bean 时，IOC 容器触发依赖注入。</li><li>当用户在 Bean 定义资源中为<code>&lt;Bean&gt;</code>元素配置了 lazy-init 属性, 默认是false，即让容器在解析注册 Bean 定义时进行预实例化，触发依赖注入。<br>BeanFactory 接口定义了 Spring IOC 容器的基本功能规范，是 Spring IOC 容器所应遵守的最底层和<br>最基本的编程规范。BeanFactory 接口中定义了几个 getBean 方法，就是用户向 IOC 容器索取管理的 Bean<br>的方法，我们通过分析其子类的具体实现，理解 Spring IOC 容器在用户索取 Bean 时如何完成依赖注<br>入。<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191108193417.png" alt><br>在 BeanFactory 中我们看到 getBean（String…）函数，它的具体实现在 AbstractBeanFactory 中</li></ul><h1><a id="AbstractBeanFactory__getBean__IOC__Bean_14"></a>AbstractBeanFactory 通过 getBean 向 IOC 容器获取被管理的 Bean</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"> //获取 IOC 容器中指定名称的 Bean</span><br><span class="line"> public Object getBean(String name) throws BeansException &#123;</span><br><span class="line">     //doGetBean 才是真正向 IoC 容器获取被管理 Bean 的过程</span><br><span class="line">     return doGetBean(name, null, null, false);</span><br><span class="line"> &#125;</span><br><span class="line"> //获取 IOC 容器中指定名称和类型的 Bean</span><br><span class="line"> public &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException &#123;</span><br><span class="line">     //doGetBean 才是真正向 IoC 容器获取被管理 Bean 的过程</span><br><span class="line">     return doGetBean(name, requiredType, null, false);</span><br><span class="line"> &#125;</span><br><span class="line"> //获取 IOC 容器中指定名称和参数的 Bean</span><br><span class="line"> public Object getBean(String name, Object... args) throws BeansException &#123;</span><br><span class="line">     //doGetBean 才是真正向 IoC 容器获取被管理 Bean 的过程</span><br><span class="line">     return doGetBean(name, null, args, false);</span><br><span class="line"> &#125;</span><br><span class="line"> //获取 IOC 容器中指定名称、类型和参数的 Bean</span><br><span class="line"> public &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType, Object... args) throws BeansException &#123;</span><br><span class="line">     //doGetBean 才是真正向 IoC 容器获取被管理 Bean 的过程</span><br><span class="line">     return doGetBean(name, requiredType, args, false);</span><br><span class="line"> &#125;</span><br><span class="line"> //真正实现向 IOC 容器获取 Bean 的功能，也是触发依赖注入功能的地方</span><br><span class="line"> @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line"> protected &lt;T&gt; T doGetBean(</span><br><span class="line">         final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)</span><br><span class="line">         throws BeansException &#123;</span><br><span class="line">     //根据指定的名称获取被管理 Bean 的名称，剥离指定名称中对容器的相关依赖</span><br><span class="line">     //如果指定的是别名，将别名转换为规范的 Bean 名称</span><br><span class="line">     final String beanName = transformedBeanName(name);</span><br><span class="line">     Object bean;</span><br><span class="line">     //先从缓存中取是否已经有被创建过的单态类型的 Bean</span><br><span class="line">     //对于单例模式的 Bean 整个 IOC 容器中只创建一次，不需要重复创建</span><br><span class="line">     Object sharedInstance = getSingleton(beanName);</span><br><span class="line">     //IOC 容器创建单例模式 Bean 实例对象</span><br><span class="line">     if (sharedInstance != null &amp;&amp; args == null) &#123;</span><br><span class="line">         if (logger.isDebugEnabled()) &#123;</span><br><span class="line">             //如果指定名称的 Bean 在容器中已有单例模式的 Bean 被创建</span><br><span class="line">             //直接返回已经创建的 Bean</span><br><span class="line">             if (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                 logger.debug(&quot;Returning eagerly cached instance of singleton bean &apos;&quot; + beanName +</span><br><span class="line">                         &quot;&apos; that is not fully initialized yet - a consequence of a circular reference&quot;);</span><br><span class="line">             &#125;</span><br><span class="line">             else &#123;</span><br><span class="line">                 logger.debug(&quot;Returning cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos;&quot;);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         //获取给定 Bean 的实例对象，主要是完成 FactoryBean 的相关处理</span><br><span class="line">         //注意：BeanFactory 是管理容器中 Bean 的工厂，而 FactoryBean 是</span><br><span class="line">         //创建创建对象的工厂 Bean，两者之间有区别</span><br><span class="line">         bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);</span><br><span class="line">     &#125;</span><br><span class="line">     else &#123;</span><br><span class="line">         //缓存没有正在创建的单例模式 Bean</span><br><span class="line">         //缓存中已经有已经创建的原型模式 Bean</span><br><span class="line">         //但是由于循环引用的问题导致实例化对象失败</span><br><span class="line">         if (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">             throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">         //对 IOC 容器中是否存在指定名称的 BeanDefinition 进行检查，首先检查是否</span><br><span class="line">         //能在当前的 BeanFactory 中获取的所需要的 Bean，如果不能则委托当前容器</span><br><span class="line">         //的父级容器去查找，如果还是找不到则沿着容器的继承体系向父级容器查找</span><br><span class="line">         // 为什么要委托父容器去找呢？</span><br><span class="line">// ioc容器是可以被关联的：FileSystemXmlApplicationContext(String[] configLocations, ApplicationContext parent)</span><br><span class="line">         BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">         //当前容器的父级容器存在，且当前容器中不存在指定名称的 Bean</span><br><span class="line">         if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">             //解析指定 Bean 名称的原始名称</span><br><span class="line">             // 因为有可能是通过别名去获取bean</span><br><span class="line">             String nameToLookup = originalBeanName(name);</span><br><span class="line">             if (args != null) &#123;</span><br><span class="line">                 //委派父级容器根据指定名称和显式的参数查找</span><br><span class="line">                 // 为什么不传类型再去校验一次？</span><br><span class="line">		// 因为这一步是强转成T ， 如果类型不一样, 在后续的调用中会报错ClassCastException</span><br><span class="line">                 return (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">             &#125;</span><br><span class="line">             else &#123;</span><br><span class="line">                 //委派父级容器根据指定名称和类型查找</span><br><span class="line">                 return parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         //如果不是只检查类型，那就标记这个Bean被创建了~~添加到缓存里 也就是所谓的  当前创建Bean池</span><br><span class="line">         if (!typeCheckOnly) &#123;</span><br><span class="line">             //向容器标记指定的 Bean 已经被创建</span><br><span class="line">             markBeanAsCreated(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">         //根据指定 Bean 名称获取其父级的 Bean 定义</span><br><span class="line">         //主要解决 Bean 继承时子类合并父类公共属性问题</span><br><span class="line">         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">         checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">         //获取当前 Bean 所有依赖 Bean 的名称</span><br><span class="line">         String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">         //如果当前 Bean 有依赖 Bean</span><br><span class="line">         if (dependsOn != null) &#123;</span><br><span class="line">             for (String dependsOnBean : dependsOn) &#123;</span><br><span class="line">                 //递归调用 getBean 方法，获取当前 Bean 的依赖 Bean</span><br><span class="line">                 getBean(dependsOnBean);</span><br><span class="line">                 //把被依赖 Bean 注册给当前依赖的 Bean</span><br><span class="line">                 registerDependentBean(dependsOnBean, beanName);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         //创建单例模式 Bean 的实例对象</span><br><span class="line">         if (mbd.isSingleton()) &#123;</span><br><span class="line">             //这里使用了一个匿名内部类，创建 Bean 实例对象，并且注册给所依赖的对象</span><br><span class="line">             sharedInstance = getSingleton(beanName, new ObjectFactory() &#123;</span><br><span class="line">                 public Object getObject() throws BeansException &#123;</span><br><span class="line">                     try &#123;</span><br><span class="line">                         //创建一个指定 Bean 实例对象，如果有父级继承，则合并子类和父类的定义</span><br><span class="line">                         return createBean(beanName, mbd, args);</span><br><span class="line">                     &#125;</span><br><span class="line">                     catch (BeansException ex) &#123;</span><br><span class="line">                         //显式地从容器单例模式 Bean 缓存中清除实例对象</span><br><span class="line">                         destroySingleton(beanName);</span><br><span class="line">                         throw ex;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">             //获取给定 Bean 的实例对象</span><br><span class="line">             bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line">         //IOC 容器创建原型模式 Bean 实例对象</span><br><span class="line">         else if (mbd.isPrototype()) &#123;</span><br><span class="line">             //原型模式(Prototype)是每次都会创建一个新的对象</span><br><span class="line">             Object prototypeInstance = null;</span><br><span class="line">             try &#123;</span><br><span class="line">                 //回调 beforePrototypeCreation 方法，默认的功能是注册当前创//建的原型对象</span><br><span class="line">                 beforePrototypeCreation(beanName);</span><br><span class="line">                 //创建指定 Bean 对象实例</span><br><span class="line">                 prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">             &#125;</span><br><span class="line">             finally &#123;</span><br><span class="line">                 //回调 afterPrototypeCreation 方法，默认的功能告诉 IoC 容器指定 Bean 的原型对象不再创建了</span><br><span class="line">                 //就是该bean已经从ing状态变成了ed状态</span><br><span class="line">                 afterPrototypeCreation(beanName);</span><br><span class="line">             &#125;</span><br><span class="line">             //获取给定 Bean 的实例对象</span><br><span class="line">             bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line">         //要创建的 Bean 既不是单例模式，也不是原型模式，则根据 Bean 定义资源中</span><br><span class="line">         //配置的生命周期范围，选择实例化 Bean 的合适方法，这种在 Web 应用程序中</span><br><span class="line">         //比较常用，如：request、session、application 等生命周期</span><br><span class="line">         else &#123;</span><br><span class="line">             String scopeName = mbd.getScope();</span><br><span class="line">             //其实scopt也是用map去管理的, 这样的很多地方就能理解通了</span><br><span class="line">             //private final Map&lt;String, Scope&gt; scopes = new HashMap&lt;String, Scope&gt;(8);</span><br><span class="line">             final Scope scope = this.scopes.get(scopeName);</span><br><span class="line">             //Bean 定义资源中没有配置生命周期范围，则 Bean 定义不合法</span><br><span class="line">             if (scope == null) &#123;</span><br><span class="line">                 throw new IllegalStateException(&quot;No Scope registered for scope &apos;&quot; + scopeName + &quot;&apos;&quot;);</span><br><span class="line">             &#125;</span><br><span class="line">             try &#123;</span><br><span class="line">                 //这里又使用了一个匿名内部类，获取一个指定生命周期范围的实例</span><br><span class="line">                 Object scopedInstance = scope.get(beanName, new ObjectFactory() &#123;</span><br><span class="line">                     public Object getObject() throws BeansException &#123;</span><br><span class="line">                         beforePrototypeCreation(beanName);</span><br><span class="line">                         try &#123;</span><br><span class="line">                             return createBean(beanName, mbd, args);</span><br><span class="line">                         &#125;</span><br><span class="line">                         finally &#123;</span><br><span class="line">                             afterPrototypeCreation(beanName);</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;);</span><br><span class="line">                 //获取给定 Bean 的实例对象</span><br><span class="line">                 bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">             &#125;</span><br><span class="line">             catch (IllegalStateException ex) &#123;</span><br><span class="line">                 throw new BeanCreationException(beanName,</span><br><span class="line">                         &quot;Scope &apos;&quot; + scopeName + &quot;&apos; is not active for the current thread; &quot; +</span><br><span class="line">                                 &quot;consider defining a scoped proxy for this bean if you intend to refer to</span><br><span class="line">                         it from a singleton&quot;,</span><br><span class="line">                         ex);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     //对创建的 Bean 实例对象进行类型检查</span><br><span class="line">     if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass()))</span><br><span class="line">     &#123;</span><br><span class="line">         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">     &#125;</span><br><span class="line">     return (T) bean;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">protected Object getObjectForBeanInstance(</span><br><span class="line">			Object beanInstance, String name, String beanName, RootBeanDefinition mbd) &#123;</span><br><span class="line"></span><br><span class="line">		// Don&apos;t let calling code try to dereference the factory if the bean isn&apos;t a factory.</span><br><span class="line">		// name 是否是工厂bean标记</span><br><span class="line">		// beanInstance 是否继承factoryBean</span><br><span class="line">		if (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance instanceof FactoryBean)) &#123;</span><br><span class="line">			throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Now we have the bean instance, which may be a normal bean or a FactoryBean.</span><br><span class="line">		// If it&apos;s a FactoryBean, we use it to create a bean instance, unless the</span><br><span class="line">		// caller actually wants a reference to the factory.</span><br><span class="line">		// 1、true || false 普通类 纯的普通类</span><br><span class="line">		// 2、false || true  工厂类 纯的工厂</span><br><span class="line">		// 3、false || false 普通类 没有定义为工厂的普通工厂类</span><br><span class="line">		if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">			return beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object object = null;</span><br><span class="line">		if (mbd == null) &#123;</span><br><span class="line">			object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		if (object == null) &#123;</span><br><span class="line">			// Return bean instance from factory.</span><br><span class="line">			FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">			// Caches object obtained from FactoryBean if it is a singleton.</span><br><span class="line">			if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">				mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			// 是否是合成的，意思就是是否当做工具类来使用</span><br><span class="line">			// 这里的synthetic实际上是为了给用户自定义一些BeanDefinition注册到容器中以当作工具类来使用。</span><br><span class="line">			// 什么是synthetic</span><br><span class="line">			// 就是内部类，java在编译的时候内部类也会编译成单独的一个文件，那实际上，原始类及时两个类的合成类</span><br><span class="line">			// 工具类就没有必要做一些封装、代理等工作，实际上是拿来就用，没有其他处理</span><br><span class="line">			// 对于synthetic类型的BeanDefinition，getObjectFromFactoryBean中是不会对FactoryBean生成的bean用post-processor进行后置处理的。</span><br><span class="line">			// 后置处理的实现是在AbstractAutowireCapableBeanFactory.postProcessObjectFromFactoryBean中，</span><br><span class="line">			// 它会调用容器中的BeanPostProcessor.postProcessAfterInitialization,这里提供了一个扩展点对FactoryBean生成的bean进行封装，代理等</span><br><span class="line">			boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic());</span><br><span class="line">			// bean实例化的缓存</span><br><span class="line">            // private final Map&lt;String, Object&gt; factoryBeanObjectCache = new ConcurrentHashMap&lt;String, Object&gt;(16);</span><br><span class="line">			object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">		&#125;</span><br><span class="line">		return object;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//对 FactoryBean 的转义定义，因为如果使用 bean 的名字检索 FactoryBean 得到的对象是工厂生成的对象，</span><br><span class="line">	//如果需要得到工厂本身，需要转义</span><br><span class="line">	String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;</span><br><span class="line">public static boolean isFactoryDereference(String name) &#123;</span><br><span class="line">		return (name != null &amp;&amp; name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private final ThreadLocal&lt;Object&gt; prototypesCurrentlyInCreation =</span><br><span class="line">			new NamedThreadLocal&lt;Object&gt;(&quot;Prototype beans currently in creation&quot;);</span><br><span class="line">protected boolean isPrototypeCurrentlyInCreation(String beanName) &#123;</span><br><span class="line">		Object curVal = this.prototypesCurrentlyInCreation.get();</span><br><span class="line">		return (curVal != null &amp;&amp;</span><br><span class="line">				(curVal.equals(beanName) || (curVal instanceof Set &amp;&amp; ((Set&lt;?&gt;) curVal).contains(beanName))));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protected void beforePrototypeCreation(String beanName) &#123;</span><br><span class="line">		Object curVal = this.prototypesCurrentlyInCreation.get();</span><br><span class="line">		if (curVal == null) &#123;</span><br><span class="line">			this.prototypesCurrentlyInCreation.set(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		else if (curVal instanceof String) &#123;</span><br><span class="line">			Set&lt;String&gt; beanNameSet = new HashSet&lt;String&gt;(2);</span><br><span class="line">			beanNameSet.add((String) curVal);</span><br><span class="line">			beanNameSet.add(beanName);</span><br><span class="line">			this.prototypesCurrentlyInCreation.set(beanNameSet);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			Set&lt;String&gt; beanNameSet = (Set&lt;String&gt;) curVal;</span><br><span class="line">			beanNameSet.add(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected void afterPrototypeCreation(String beanName) &#123;</span><br><span class="line">		Object curVal = this.prototypesCurrentlyInCreation.get();</span><br><span class="line">		if (curVal instanceof String) &#123;</span><br><span class="line">			this.prototypesCurrentlyInCreation.remove();</span><br><span class="line">		&#125;</span><br><span class="line">		else if (curVal instanceof Set) &#123;</span><br><span class="line">			Set&lt;String&gt; beanNameSet = (Set&lt;String&gt;) curVal;</span><br><span class="line">			beanNameSet.remove(beanName);</span><br><span class="line">			if (beanNameSet.isEmpty()) &#123;</span><br><span class="line">				this.prototypesCurrentlyInCreation.remove();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>通过上面对向 IOC 容器获取 Bean 方法的分析，我们可以看到在 Spring 中，如果 Bean 定义的单例模式<br>(Singleton)，则容器在创建之前先从缓存中查找，以确保整个容器中只存在一个实例对象。如果 Bean<br>定义的是原型模式(Prototype)，则容器每次都会创建一个新的实例对象。除此之外，Bean 定义还可以<br>扩展为指定其生命周期范围。</p><p>上面的源码只是定义了根据 Bean 定义的模式，采取的不同创建 Bean 实例对象的策略，具体的 Bean 实<br>例对象的创建过程由实现了 ObejctFactory 接口的匿名内部类的 createBean 方法完成，ObejctFactory<br>使用委派模式，具体的 Bean 实例创建过程交由其实现类 AbstractAutowireCapableBeanFactory 完成，<br>我们继续分析 AbstractAutowireCapableBeanFactory 的 createBean 方法的源码，理解其创建 Bean 实<br>例的具体实现过程。</p><h1><a id="_37"></a>循环依赖的产生和解决的前提</h1><ul><li>A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象</li><li>A的构造方法中依赖了B的实例对象，同时B的某个field或者setter需要A的实例对象</li><li>A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象<br>当然，Spring对于循环依赖的解决不是无条件的，首先前提条件是针对scope单例并且没有显式指明不需要解决循环依赖的对象，而且要求该对象没有被代理过。同时Spring解决循环依赖也不是万能，以上三种情况只能解决两种，第一种在构造方法中相互依赖的情况Spring也无力回天。结论先给在这，下面来看看Spring的解决方法，知道了解决方案就能明白为啥第一种情况无法解决了。<br>Spring单例对象的初始化其实可以分为三步：</li><li>createBeanInstance， 实例化，实际上就是调用对应的构造方法构造对象，此时只是调用了构造方法，spring xml中指定的property并没有进行populate</li><li>populateBean 填充属性，这步对spring xml中指定的property进行populate</li><li>initializeBean 调用spring xml中指定的init方法，或者AfterPropertiesSet方法会发生循环依赖的步骤集中在第一步和第二步。</li></ul><h2><a id="_47"></a><a class="header-anchor" href="#三级缓存">¶</a>三级缓存</h2><p>对于单例对象来说，在Spring的整个容器的生命周期内，有且只存在一个对象，很容易想到这个对象应该存在Cache中，Spring大量运用了Cache的手段，在循环依赖问题的解决过程中甚至使用了“三级缓存”。<br>“三级缓存”主要是指</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 完美并且已经在使用的bean</span><br><span class="line">/** Cache of singleton objects: bean name --&gt; bean instance */</span><br><span class="line">private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(256);</span><br><span class="line">// bean的工厂方法</span><br><span class="line">/** Cache of early singleton objects: bean name --&gt; bean instance */</span><br><span class="line">private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;String, Object&gt;(16);</span><br><span class="line">// 新创建或不完美的bean</span><br><span class="line">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span><br><span class="line">private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(16);</span><br></pre></td></tr></table></figure><p>从字面意思来说：singletonObjects指单例对象的cache，singletonFactories指单例对象工厂的cache，earlySingletonObjects指提前曝光的单例对象的cache。以上三个cache构成了三级缓存，Spring就用这三级缓存巧妙的解决了循环依赖问题。<br>首先Spring会尝试从缓存中获取，这个缓存就是指singletonObjects，主要调用的方法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class="line">   Object singletonObject = this.singletonObjects.get(beanName);</span><br><span class="line">   if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      synchronized (this.singletonObjects) &#123;</span><br><span class="line">         singletonObject = this.earlySingletonObjects.get(beanName);</span><br><span class="line">         if (singletonObject == null &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">            ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);</span><br><span class="line">            if (singletonFactory != null) &#123;</span><br><span class="line">               singletonObject = singletonFactory.getObject();</span><br><span class="line">               this.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">               this.singletonFactories.remove(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return (singletonObject != NULL_OBJECT ? singletonObject : null);&#125;</span><br></pre></td></tr></table></figure><p>首先解释两个参数：</p><ul><li>isSingletonCurrentlyInCreation 判断对应的单例对象是否在创建中，当单例对象没有被初始化完全(例如A定义的构造函数依赖了B对象，得先去创建B对象，或者在populatebean过程中依赖了B对象，得先去创建B对象，此时A处于创建中)</li><li>allowEarlyReference 是否允许从singletonFactories中通过getObject拿到对象，其实就是是否允许我重新创建一个</li></ul><p>分析getSingleton的整个过程，Spring首先从singletonObjects（一级缓存）中尝试获取，如果获取不到并且对象在创建中，则尝试从earlySingletonObjects(二级缓存)中获取，如果还是获取不到并且允许从singletonFactories通过getObject获取，则通过singletonFactory.getObject()(三级缓存)获取。如果获取到了则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">this.singletonFactories.remove(beanName);</span><br></pre></td></tr></table></figure><p>Spring解决循环依赖的诀窍就在于singletonFactories这个cache，这个cache中存的是类型为ObjectFactory，其定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface ObjectFactory&lt;T&gt; &#123;</span><br><span class="line">    T getObject() throws BeansException;&#125;</span><br></pre></td></tr></table></figure><p>在bean创建过程中，有两处比较重要的匿名内部类实现了该接口。一处是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">   @Override   public Object getObject() throws BeansException &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         return createBean(beanName, mbd, args);</span><br><span class="line">      &#125;      catch (BeansException ex) &#123;</span><br><span class="line">         destroySingleton(beanName);</span><br><span class="line">         throw ex;</span><br><span class="line">      &#125;   &#125;</span><br></pre></td></tr></table></figure><p>另一处就是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">   @Override   public Object getObject() throws BeansException &#123;</span><br><span class="line">      return getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">   &#125;&#125;);</span><br></pre></td></tr></table></figure><p>此处就是解决循环依赖的关键，这段代码发生在createBeanInstance之后，也就是说单例对象此时已经被创建出来的。这个对象已经被生产出来了，虽然还不完美（还没有进行初始化的第二步和第三步），但是已经能被人认出来了（根据对象引用能定位到堆中的对象），所以Spring此时将这个对象提前曝光出来让大家认识，让大家使用。</p><p>这样做有什么好处呢？让我们来分析一下“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。A首先完成了初始化的第一步，并且将自己提前曝光到singletonFactories中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程，B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，长大成人，进去了一级缓存singletonObjects中，而且更加幸运的是，由于B拿到了A的对象引用，所以B现在hold住的A对象也蜕变完美了！</p><p>知道了这个原理时候，肯定就知道为啥Spring不能解决“A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象”这类问题了！</p><h1><a id="AbstractAutowireCapableBeanFactory__Bean__74"></a>AbstractAutowireCapableBeanFactory 创建 Bean 实例对象</h1><p>AbstractAutowireCapableBeanFactory 类实现了 ObejctFactory 接口，创建容器指定的 Bean 实例对象，<br>同时还对创建的 Bean 实例对象进行初始化处理。其创建 Bean 实例对象的方法源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">  //创建 Bean 实例对象</span><br><span class="line">  protected Object createBean(final String beanName, final RootBeanDefinition mbd, final Object[]</span><br><span class="line">          args)</span><br><span class="line">          throws BeanCreationException &#123;</span><br><span class="line">      if (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(&quot;Creating instance of bean &apos;&quot; + beanName + &quot;&apos;&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      //判断需要创建的 Bean 是否可以实例化，即是否可以通过当前的类加载器加载</span><br><span class="line">      resolveBeanClass(mbd, beanName);</span><br><span class="line">      //校验和准备 Bean 中的方法覆盖</span><br><span class="line">//除了原型模式，其他的bean基本上都会使用代理去创建</span><br><span class="line">//默认使用cglib创建代理，好处就是spring有了代理类的控制权，同时也兼容接口代理</span><br><span class="line">      try &#123;</span><br><span class="line">          mbd.prepareMethodOverrides();</span><br><span class="line">      &#125;</span><br><span class="line">      catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">          throw new BeanDefinitionStoreException(mbd.getResourceDescription(),</span><br><span class="line">                  beanName, &quot;Validation of method overrides failed&quot;, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      try &#123;</span><br><span class="line">          //如果 Bean 配置了初始化前和初始化后的处理器，则试图返回一个需要创建 Bean 的代理对象</span><br><span class="line">          Object bean = resolveBeforeInstantiation(beanName, mbd);</span><br><span class="line">          if (bean != null) &#123;</span><br><span class="line">              return bean;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Throwable ex) &#123;</span><br><span class="line">          throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      //创建 Bean 的入口</span><br><span class="line">      Object beanInstance = doCreateBean(beanName, mbd, args);</span><br><span class="line">      if (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(&quot;Finished creating instance of bean &apos;&quot; + beanName + &quot;&apos;&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      return beanInstance;</span><br><span class="line">  &#125;</span><br><span class="line">  //真正创建 Bean 的方法</span><br><span class="line">  protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[]</span><br><span class="line">          args) &#123;</span><br><span class="line">      //封装被创建的 Bean 对象</span><br><span class="line">      BeanWrapper instanceWrapper = null;</span><br><span class="line">      if (mbd.isSingleton())&#123;</span><br><span class="line">          //单例模式的 Bean，先从容器中缓存中获取同名 Bean</span><br><span class="line">          instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      if (instanceWrapper == null) &#123;</span><br><span class="line">          //创建实例对象</span><br><span class="line">	//生成 Bean 所包含的 java 对象实例</span><br><span class="line">          instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">      &#125;</span><br><span class="line">      final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);</span><br><span class="line">      //获取实例化对象的类型</span><br><span class="line">      Class beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);</span><br><span class="line">      //调用 PostProcessor 后置处理器</span><br><span class="line">//就是类似aware监听器一样，监听对象什么时候初始化成功</span><br><span class="line">      synchronized (mbd.postProcessingLock) &#123;</span><br><span class="line">          if (!mbd.postProcessed) &#123;</span><br><span class="line">              applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">              mbd.postProcessed = true;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // Eagerly cache singletons to be able to resolve circular references</span><br><span class="line">      //向容器中缓存单例模式的 Bean 对象，以防循环引用</span><br><span class="line">      boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class="line">              isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">      //earlySingletonExposure：如果你的bean允许被早期暴露出去 也就是说可以被循环引用  那这里就会进行检查</span><br><span class="line">      if (earlySingletonExposure) &#123;</span><br><span class="line">          if (logger.isDebugEnabled()) &#123;</span><br><span class="line">              logger.debug(&quot;Eagerly caching bean &apos;&quot; + beanName +</span><br><span class="line">                      &quot;&apos; to allow for resolving potential circular references&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          //这里是一个匿名内部类，为了防止循环引用，尽早持有对象的引用</span><br><span class="line">          addSingletonFactory(beanName, new ObjectFactory() &#123;</span><br><span class="line">              public Object getObject() throws BeansException &#123;</span><br><span class="line">                  return getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      //Bean 对象的初始化，依赖注入在此触发</span><br><span class="line">      //这个 exposedObject 在初始化完成之后返回作为依赖注入完成后的 Bean</span><br><span class="line">      Object exposedObject = bean;</span><br><span class="line">      try &#123;</span><br><span class="line">          //将 Bean 实例对象封装，并且 Bean 定义中配置的属性值赋值给实例对象</span><br><span class="line">	//对 Bean 属性的依赖注入进行处理。</span><br><span class="line">          populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">          if (exposedObject != null) &#123;</span><br><span class="line">              //初始化 Bean 对象</span><br><span class="line">              exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Throwable ex) &#123;</span><br><span class="line">          if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException)</span><br><span class="line">                  ex).getBeanName())) &#123;</span><br><span class="line">              throw (BeanCreationException) ex;</span><br><span class="line">          &#125;</span><br><span class="line">          else &#123;</span><br><span class="line">              throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                      &quot;Initialization of bean failed&quot;, ex);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //此时一级缓存肯定还没数据，但是呢此时候二级缓存earlySingletonObjects也没数据</span><br><span class="line">      if (earlySingletonExposure) &#123;</span><br><span class="line">          //获取指定名称的已注册的单例模式 Bean 对象</span><br><span class="line">          //此时一级缓存肯定还没数据，但是呢此时候二级缓存earlySingletonObjects也没数据</span><br><span class="line">          //第二参数为false  表示不会再去三级缓存里查了~~~</span><br><span class="line">          Object earlySingletonReference = getSingleton(beanName, false);</span><br><span class="line">          if (earlySingletonReference != null) &#123;</span><br><span class="line">              //根据名称获取的已注册的 Bean 和正在实例化的 Bean 是同一个</span><br><span class="line">              if (exposedObject == bean) &#123;</span><br><span class="line">                  //当前实例化的 Bean 初始化完成</span><br><span class="line">                  exposedObject = earlySingletonReference;</span><br><span class="line">              &#125;</span><br><span class="line">              //当前 Bean 依赖其他 Bean，并且当发生循环引用时不允许新创建实例对象</span><br><span class="line">              // allowRawInjectionDespiteWrapping这个值默认是false</span><br><span class="line">		// hasDependentBean：若它有依赖的bean 那就需要继续校验了~~~(若没有依赖的 就放过它~)</span><br><span class="line">              else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                  String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                  Set&lt;String&gt; actualDependentBeans = new</span><br><span class="line">                          LinkedHashSet&lt;String&gt;(dependentBeans.length);</span><br><span class="line">                  //获取当前 Bean 所依赖的其他 Bean</span><br><span class="line">                  // 一个个检查它所以Bean</span><br><span class="line">			// removeSingletonIfCreatedForTypeCheckOnly这个放见下面  在AbstractBeanFactory里面</span><br><span class="line">			// 简单的说，它如果判断到该dependentBean并没有在创建中的了的情况下,那就把它从所有缓存中移除~~~  并且返回true</span><br><span class="line">			// 否则（比如确实在创建中） 那就返回false 进入我们的if里面~  表示所谓的真正依赖</span><br><span class="line">			//（解释：就是真的需要依赖它先实例化，才能实例化自己的依赖）</span><br><span class="line">                  for (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                      //对依赖 Bean 进行类型检查</span><br><span class="line">                      if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                          actualDependentBeans.add(dependentBean);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  if (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                      throw new BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                              &quot;Bean with name &apos;&quot; + beanName + &quot;&apos; has been injected into other beans</span><br><span class="line">                                      [&quot; +</span><br><span class="line">                              StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                                      &quot;] in its raw version as part of a circular reference, but has eventually</span><br><span class="line">                              been &quot; +</span><br><span class="line">                              &quot;wrapped. This means that said other beans do not use the final version</span><br><span class="line">                              of the &quot; +</span><br><span class="line">                              &quot;bean. This is often the result of over-eager type matching - consider</span><br><span class="line">                              using &quot; +</span><br><span class="line">                              &quot;&apos;getBeanNamesOfType&apos; with the &apos;allowEagerInit&apos; flag turned off, for</span><br><span class="line">                              example.&quot;);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //注册完成依赖注入的 Bean</span><br><span class="line">      try &#123;</span><br><span class="line">          registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">      catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">          throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Invalid</span><br><span class="line">                  destruction signature&quot;, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      return exposedObject;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191114115523.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/ 虽然是remove方法 但是它的返回值也非常重要</span><br><span class="line">// 该方法唯一调用的地方就是循环依赖的最后检查处</span><br><span class="line">protected boolean removeSingletonIfCreatedForTypeCheckOnly(String beanName) &#123;</span><br><span class="line">        // 如果这个bean不在创建中  比如是ForTypeCheckOnly的  那就移除掉</span><br><span class="line">		if (!this.alreadyCreated.containsKey(beanName)) &#123;</span><br><span class="line">			removeSingleton(beanName);</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>通过对方法源码的分析，我们看到具体的依赖注入实现在以下两个方法中：</p><ul><li>createBeanInstance：生成 Bean 所包含的 java 对象实例</li><li>populateBean ：对 Bean 属性的依赖注入进行处理。</li></ul><h1><a id="createBeanInstance__Bean__java__86"></a>createBeanInstance 方法创建 Bean 的 java 实例对象</h1><p>在 createBeanInstance 方法中，根据指定的初始化策略，使用静态工厂、工厂方法或者容器的自动装<br>配特性生成 java 实例对象，创建对象的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">//创建 Bean 的实例对象</span><br><span class="line">protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args)</span><br><span class="line">&#123;</span><br><span class="line">    //检查确认 Bean 是可实例化的</span><br><span class="line">    Class beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    //使用工厂方法对 Bean 进行实例化</span><br><span class="line">    if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers())</span><br><span class="line">            &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">        throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                &quot;Bean class isn&apos;t public, and non-public access not allowed: &quot; +</span><br><span class="line">                        beanClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    if (mbd.getFactoryMethodName() != null) &#123;</span><br><span class="line">        //调用工厂方法实例化</span><br><span class="line">        return instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    //使用容器的自动装配方法进行实例化</span><br><span class="line">    boolean resolved = false;</span><br><span class="line">    boolean autowireNecessary = false;</span><br><span class="line">    if (args == null) &#123;</span><br><span class="line">        synchronized (mbd.constructorArgumentLock) &#123;</span><br><span class="line">            if (mbd.resolvedConstructorOrFactoryMethod != null) &#123;</span><br><span class="line">                resolved = true;</span><br><span class="line">                autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (resolved) &#123;</span><br><span class="line">        if (autowireNecessary) &#123;</span><br><span class="line">            //配置了自动装配属性，使用容器的自动装配实例化</span><br><span class="line">            //容器的自动装配是根据参数类型匹配 Bean 的构造方法</span><br><span class="line">            return autowireConstructor(beanName, mbd, null, null);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            //使用默认的无参构造方法实例化</span><br><span class="line">            return instantiateBean(beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //使用 Bean 的构造方法进行实例化</span><br><span class="line">    Constructor[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">    if (ctors != null ||</span><br><span class="line">            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">            mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">        //使用容器的自动装配特性，调用匹配的构造方法实例化</span><br><span class="line">        return autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">    &#125;</span><br><span class="line">    //使用默认的无参构造方法实例化</span><br><span class="line">    return instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">//使用默认的无参构造方法实例化 Bean 对象</span><br><span class="line">protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Object beanInstance;</span><br><span class="line">        final BeanFactory parent = this;</span><br><span class="line">        //获取系统的安全管理接口，JDK 标准的安全管理 API</span><br><span class="line">        if (System.getSecurityManager() != null) &#123;</span><br><span class="line">            //这里是一个匿名内置类，根据实例化策略创建实例对象</span><br><span class="line">            beanInstance = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                public Object run() &#123;</span><br><span class="line">                    return getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            //将实例化的对象封装起来</span><br><span class="line">            beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">        &#125;</span><br><span class="line">        BeanWrapper bw = new BeanWrapperImpl(beanInstance);</span><br><span class="line">        initBeanWrapper(bw);</span><br><span class="line">        return bw;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable ex) &#123;</span><br><span class="line">        throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Instantiation of</span><br><span class="line">                bean failed&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过对上面的代码分析，我们可以看出，对使用工厂方法和自动装配特性的 Bean 的实例化相当比较清<br>楚，调用相应的工厂方法或者参数匹配的构造方法即可完成实例化对象的工作，但是对于我们最常使用<br>的默认无参构造方法就需要使用相应的初始化策略(JDK 的反射机制或者 CGLIB)来进行初始化了，在方<br>法 getInstantiationStrategy().instantiate 中就具体实现类使用初始策略实例化对象</p><h1><a id="SimpleInstantiationStrategy__Bean__95"></a>SimpleInstantiationStrategy 类使用默认的无参构造方法创建 Bean 实例化对象</h1><p>在使用默认的无参构造方法创建Bean的实例化对象时，方法getInstantiationStrategy().instantiate<br>调用了 SimpleInstantiationStrategy 类中的实例化 Bean 的方法，其源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">  //使用初始化策略实例化 Bean 对象</span><br><span class="line">  public Object instantiate(RootBeanDefinition beanDefinition, String beanName, BeanFactory owner)</span><br><span class="line">  &#123;</span><br><span class="line">      //如果 Bean 定义中没有方法覆盖，则就不需要 CGLIB </span><br><span class="line">//那么是什么条件才会触发这个MethodOverrides呢？</span><br><span class="line">//其实是Spring配置文件中的lookup-method和replace-method，</span><br><span class="line">//这其实是两个方法级别的注入，和一般的属性(Property)注入是不一样的，</span><br><span class="line">//它们注入的是方法(Method)。</span><br><span class="line">//两者的差别是这样的</span><br><span class="line">//如果需要替换的方法没有返回值，那么只能使用replace-method来替换，而不能用lookup-method来替换。</span><br><span class="line">//replace-method必须实现MethodReplacer接口的Bean才能替换，而lookup-method则由BeanFactory自动为我们处理了。，</span><br><span class="line">      if (beanDefinition.getMethodOverrides().isEmpty()) &#123;</span><br><span class="line">          Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">          synchronized (beanDefinition.constructorArgumentLock) &#123;</span><br><span class="line">              //获取对象的构造方法或工厂方法</span><br><span class="line">              constructorToUse = (Constructor&lt;?&gt;)</span><br><span class="line">                      beanDefinition.resolvedConstructorOrFactoryMethod;</span><br><span class="line">              //如果没有构造方法且没有工厂方法</span><br><span class="line">              if (constructorToUse == null) &#123;</span><br><span class="line">                  //使用 JDK 的反射机制，判断要实例化的 Bean 是否是接口</span><br><span class="line">                  final Class clazz = beanDefinition.getBeanClass();</span><br><span class="line">                  if (clazz.isInterface()) &#123;</span><br><span class="line">                      throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;);</span><br><span class="line">                  &#125;</span><br><span class="line">                  try &#123;</span><br><span class="line">                      if (System.getSecurityManager() != null) &#123;</span><br><span class="line">                          //这里是一个匿名内置类，使用反射机制获取 Bean 的构造方法</span><br><span class="line">                          constructorToUse = AccessController.doPrivileged(new</span><br><span class="line">                                                                                   PrivilegedExceptionAction&lt;Constructor&gt;() &#123;</span><br><span class="line">                                                                                       public Constructor run() throws Exception &#123;</span><br><span class="line">                                                                                           return clazz.getDeclaredConstructor((Class[]) null);</span><br><span class="line">                                                                                       &#125;</span><br><span class="line">                                                                                   &#125;);</span><br><span class="line">                      &#125;</span><br><span class="line">                      else &#123;</span><br><span class="line">                          constructorToUse = clazz.getDeclaredConstructor((Class[]) null);</span><br><span class="line">                      &#125;</span><br><span class="line">                      beanDefinition.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">                  &#125;</span><br><span class="line">                  catch (Exception ex) &#123;</span><br><span class="line">                      throw new BeanInstantiationException(clazz, &quot;No default constructor found&quot;,</span><br><span class="line">                              ex);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          //使用 BeanUtils 实例化，通过反射机制调用”构造方法.newInstance(arg)”来进行实例化</span><br><span class="line">          return BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">          //使用 CGLIB 来实例化对象</span><br><span class="line">          return instantiateWithMethodInjection(beanDefinition, beanName, owner);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码分析，我们看到了如果 Bean 有方法被覆盖了，则使用 JDK 的反射机制进行实例化，否<br>则，使用 CGLIB 进行实例化。</p><p>instantiateWithMethodInjection 方法调用 SimpleInstantiationStrategy 的子类<br>CglibSubclassingInstantiationStrategy 使用 CGLIB 来进行初始化，其源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//使用 CGLIB 进行 Bean 对象实例化</span><br><span class="line">public Object instantiate(Constructor ctor, Object[] args) &#123;</span><br><span class="line">    //CGLIB 中的类</span><br><span class="line">    Enhancer enhancer = new Enhancer();</span><br><span class="line">    //将 Bean 本身作为其基类</span><br><span class="line">    enhancer.setSuperclass(this.beanDefinition.getBeanClass());</span><br><span class="line">    enhancer.setCallbackFilter(new CallbackFilterImpl());</span><br><span class="line">    enhancer.setCallbacks(new Callback[] &#123;</span><br><span class="line">            NoOp.INSTANCE,</span><br><span class="line">            new LookupOverrideMethodInterceptor(),</span><br><span class="line">            new ReplaceOverrideMethodInterceptor()</span><br><span class="line">    &#125;);</span><br><span class="line">    //使用 CGLIB 的 create 方法生成实例对象</span><br><span class="line">    return (ctor == null) ?</span><br><span class="line">            enhancer.create() :</span><br><span class="line">            enhancer.create(ctor.getParameterTypes(), args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CGLIB 是一个常用的字节码生成器的类库，它提供了一系列 API 实现 java 字节码的生成和转换功能。我<br>们在学习 JDK 的动态代理时都知道，JDK 的动态代理只能针对接口，如果一个类没有实现任何接口，要<br>对其进行动态代理只能使用 CGLIB。</p><h1><a id="populateBean__Bean__109"></a>populateBean 方法对 Bean 属性的依赖注入</h1><p>在上面的分析中我们已经了解到 Bean 的依赖注入分为以下两个过程</p><ul><li>createBeanInstance：生成 Bean 所包含的 java 对象实例</li><li>populateBean ：对 Bean 属性的依赖注入进行处理</li></ul><p>我们已经分析了容器初始化生成 Bean 所包含的 Java 实例对象的过程，现在我们继续分析<br>生成对象后，Spring IOC 容器是如何将 Bean 的属性依赖关系注入 Bean 实例对象中并设置好的，属性<br>依赖注入的代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line">   //将 Bean 属性设置到生成的实例对象上</span><br><span class="line">   protected void populateBean(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw) &#123;</span><br><span class="line">       //获取容器在解析 Bean 定义资源时为 BeanDefiniton 中设置的属性值</span><br><span class="line">       PropertyValues pvs = mbd.getPropertyValues();</span><br><span class="line">       //实例对象为 null</span><br><span class="line">       if (bw == null) &#123;</span><br><span class="line">           //属性值不为空</span><br><span class="line">           if (!pvs.isEmpty()) &#123;</span><br><span class="line">               throw new BeanCreationException(</span><br><span class="line">                       mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null</span><br><span class="line">                       instance&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           else &#123;</span><br><span class="line">               //实例对象为 null，属性值也为空，不需要设置属性值，直接返回</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //在设置属性之前调用 Bean 的 PostProcessor 后置处理器</span><br><span class="line">       boolean continueWithPropertyPopulation = true;</span><br><span class="line">       if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">           for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">               if (bp instanceof InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                   InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)</span><br><span class="line">                           bp;</span><br><span class="line">                   if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">                       continueWithPropertyPopulation = false;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (!continueWithPropertyPopulation) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       //依赖注入开始，首先处理 autowire 自动装配的注入</span><br><span class="line">       if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">               mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">           MutablePropertyValues newPvs = new MutablePropertyValues(pvs);</span><br><span class="line">           //对 autowire 自动装配的处理，根据 Bean 名称自动装配注入</span><br><span class="line">           if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">               autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">           &#125;</span><br><span class="line">           //根据 Bean 类型自动装配注入</span><br><span class="line">           if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">               autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">           &#125;</span><br><span class="line">           pvs = newPvs;</span><br><span class="line">       &#125;</span><br><span class="line">       //检查容器是否持有用于处理单例模式 Bean 关闭时的后置处理器</span><br><span class="line">       boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">       //Bean 实例对象没有依赖，即没有继承基类</span><br><span class="line">       boolean needsDepCheck = (mbd.getDependencyCheck() !=</span><br><span class="line">               RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line">       if (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line">           //从实例对象中提取属性描述符</span><br><span class="line">           PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw);</span><br><span class="line">           if (hasInstAwareBpps) &#123;</span><br><span class="line">               for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">                   if (bp instanceof InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                       InstantiationAwareBeanPostProcessor ibp =</span><br><span class="line">                               (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                       //使用 BeanPostProcessor 处理器处理属性值</span><br><span class="line">                       pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(),</span><br><span class="line">                               beanName);</span><br><span class="line">                       if (pvs == null) &#123;</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (needsDepCheck) &#123;</span><br><span class="line">               //为要设置的属性进行依赖检查</span><br><span class="line">               checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //对属性进行注入</span><br><span class="line">       applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   protected void autowireByName(</span><br><span class="line">		String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) &#123;</span><br><span class="line"></span><br><span class="line">	String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">	for (String propertyName : propertyNames) &#123;</span><br><span class="line">		if (containsBean(propertyName)) &#123;</span><br><span class="line">			//使用当前Bean的属性名，在IoC容器中获取对应的bean，让将获取的bean设置为当前的Bean的属性值</span><br><span class="line">			Object bean = getBean(propertyName);</span><br><span class="line">			pvs.add(propertyName, bean);</span><br><span class="line">			registerDependentBean(propertyName, beanName);</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Added autowiring by name from bean name &apos;&quot; + beanName +</span><br><span class="line">						&quot;&apos; via property &apos;&quot; + propertyName + &quot;&apos; to bean named &apos;&quot; + propertyName + &quot;&apos;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			if (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(&quot;Not autowiring property &apos;&quot; + propertyName + &quot;&apos; of bean &apos;&quot; + beanName +</span><br><span class="line">						&quot;&apos; by name: no matching bean found&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   public void registerDependentBean(String beanName, String dependentBeanName) &#123;</span><br><span class="line">	String canonicalName = canonicalName(beanName);</span><br><span class="line">	// 翻译一下就是：set里的bean都要依赖 key</span><br><span class="line">	synchronized (this.dependentBeanMap) &#123;</span><br><span class="line">		Set&lt;String&gt; dependentBeans = this.dependentBeanMap.get(canonicalName);</span><br><span class="line">		if (dependentBeans == null) &#123;</span><br><span class="line">			dependentBeans = new LinkedHashSet&lt;String&gt;(8);</span><br><span class="line">			this.dependentBeanMap.put(canonicalName, dependentBeans);</span><br><span class="line">		&#125;</span><br><span class="line">		dependentBeans.add(dependentBeanName);</span><br><span class="line">	&#125;</span><br><span class="line">	// 翻译一下就是：key需要依赖set中的bean</span><br><span class="line">	synchronized (this.dependenciesForBeanMap) &#123;</span><br><span class="line">		Set&lt;String&gt; dependenciesForBean = this.dependenciesForBeanMap.get(dependentBeanName);</span><br><span class="line">		if (dependenciesForBean == null) &#123;</span><br><span class="line">			dependenciesForBean = new LinkedHashSet&lt;String&gt;(8);</span><br><span class="line">			this.dependenciesForBeanMap.put(dependentBeanName, dependenciesForBean);</span><br><span class="line">		&#125;</span><br><span class="line">		dependenciesForBean.add(canonicalName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   protected Map&lt;String, Object&gt; findAutowireCandidates(</span><br><span class="line">		String beanName, Class&lt;?&gt; requiredType, DependencyDescriptor descriptor) &#123;</span><br><span class="line"></span><br><span class="line">	//找一下所有的Bean定义中指定Type的实现类或者子类</span><br><span class="line">	String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">			this, requiredType, true, descriptor.isEager());</span><br><span class="line">	Map&lt;String, Object&gt; result = new LinkedHashMap&lt;String, Object&gt;(candidateNames.length);</span><br><span class="line">	//要自动装配的类型是不是要自动装配的纠正类型，这个在</span><br><span class="line">	// 非懒加载的单例Bean初始化前后的一些操作，如果要自动装配的类型是纠正类型，</span><br><span class="line">	// 比如是一个ResourceLoader，那么就会为该类型生成一个代理实例，</span><br><span class="line">	// 具体可以看一下 AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType);</span><br><span class="line">	for (Class&lt;?&gt; autowiringType : this.resolvableDependencies.keySet()) &#123;</span><br><span class="line">		if (autowiringType.isAssignableFrom(requiredType)) &#123;</span><br><span class="line">			Object autowiringValue = this.resolvableDependencies.get(autowiringType);</span><br><span class="line">			autowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType);</span><br><span class="line">			if (requiredType.isInstance(autowiringValue)) &#123;</span><br><span class="line">				result.put(ObjectUtils.identityToString(autowiringValue), autowiringValue);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//逐个判断查找一下beanName对应的BeanDefinition，判断一下是不是自动装配候选者，默认都是的，如果&lt;bean&gt;的autowire-candidate属性设置为false就不是</span><br><span class="line">	for (String candidateName : candidateNames) &#123;</span><br><span class="line">		if (!candidateName.equals(beanName) &amp;&amp; isAutowireCandidate(candidateName, descriptor)) &#123;</span><br><span class="line">			result.put(candidateName, getBean(candidateName));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   @Override</span><br><span class="line">public String[] getBeanNamesForType(Class&lt;?&gt; type, boolean includeNonSingletons, boolean allowEagerInit) &#123;</span><br><span class="line">	if (!isConfigurationFrozen()  || type == null || !allowEagerInit) &#123;</span><br><span class="line">		return doGetBeanNamesForType(type, includeNonSingletons, allowEagerInit);</span><br><span class="line">	&#125;</span><br><span class="line">	Map&lt;Class&lt;?&gt;, String[]&gt; cache =</span><br><span class="line">			(includeNonSingletons ? this.allBeanNamesByType : this.singletonBeanNamesByType);</span><br><span class="line">	String[] resolvedBeanNames = cache.get(type);</span><br><span class="line">	if (resolvedBeanNames != null) &#123;</span><br><span class="line">		return resolvedBeanNames;</span><br><span class="line">	&#125;</span><br><span class="line">	resolvedBeanNames = doGetBeanNamesForType(type, includeNonSingletons, allowEagerInit);</span><br><span class="line">	cache.put(type, resolvedBeanNames);</span><br><span class="line">	return resolvedBeanNames;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   //解析并注入依赖属性的过程</span><br><span class="line">   protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw,</span><br><span class="line">                                      PropertyValues pvs) &#123;</span><br><span class="line">       if (pvs == null || pvs.isEmpty()) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       //封装属性值</span><br><span class="line">       MutablePropertyValues mpvs = null;</span><br><span class="line">       List&lt;PropertyValue&gt; original;</span><br><span class="line">       if (System.getSecurityManager()!= null) &#123;</span><br><span class="line">           if (bw instanceof BeanWrapperImpl) &#123;</span><br><span class="line">               //设置安全上下文，JDK 安全机制</span><br><span class="line">               ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (pvs instanceof MutablePropertyValues) &#123;</span><br><span class="line">           mpvs = (MutablePropertyValues) pvs;</span><br><span class="line">           //属性值已经转换</span><br><span class="line">           if (mpvs.isConverted()) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   //为实例化对象设置属性值</span><br><span class="line">                   bw.setPropertyValues(mpvs);</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">               catch (BeansException ex) &#123;</span><br><span class="line">                   throw new BeanCreationException(</span><br><span class="line">                           mbd.getResourceDescription(), beanName, &quot;Error setting property values&quot;,</span><br><span class="line">                           ex);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           //获取属性值对象的原始类型值</span><br><span class="line">           original = mpvs.getPropertyValueList();</span><br><span class="line">       &#125;</span><br><span class="line">       else &#123;</span><br><span class="line">           original = Arrays.asList(pvs.getPropertyValues());</span><br><span class="line">       &#125;</span><br><span class="line">       //获取用户自定义的类型转换</span><br><span class="line">       TypeConverter converter = getCustomTypeConverter();</span><br><span class="line">       if (converter == null) &#123;</span><br><span class="line">           converter = bw;</span><br><span class="line">       &#125;</span><br><span class="line">       //创建一个 Bean 定义属性值解析器，将 Bean 定义中的属性值解析为 Bean 实例对象的实际值</span><br><span class="line">       BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName,</span><br><span class="line">               mbd, converter);</span><br><span class="line">       //为属性的解析值创建一个拷贝，将拷贝的数据注入到实例对象中</span><br><span class="line">       List&lt;PropertyValue&gt; deepCopy = new ArrayList&lt;PropertyValue&gt;(original.size());</span><br><span class="line">       boolean resolveNecessary = false;</span><br><span class="line">       for (PropertyValue pv : original) &#123;</span><br><span class="line">           //属性值不需要转换</span><br><span class="line">           if (pv.isConverted()) &#123;</span><br><span class="line">               deepCopy.add(pv);</span><br><span class="line">           &#125;</span><br><span class="line">           //属性值需要转换</span><br><span class="line">           else &#123;</span><br><span class="line">               String propertyName = pv.getName();</span><br><span class="line">               //原始的属性值，即转换之前的属性值</span><br><span class="line">               Object originalValue = pv.getValue();</span><br><span class="line">               //转换属性值，例如将引用转换为 IOC 容器中实例化对象引用</span><br><span class="line">			//检查，接口和类、父类和子类之间的关系是否正确</span><br><span class="line">			//同时处理ref类型数据</span><br><span class="line">			/**</span><br><span class="line">			 * &lt;bean class=&quot;com.jphoebe.xxx&quot;&gt;</span><br><span class="line">			 *     &lt;property name=&quot;referBeanName&quot; ref=&quot;otherBeanName&quot; /&gt;</span><br><span class="line">			 * &lt;/bean&gt;</span><br><span class="line">			 */</span><br><span class="line">               Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">               //转换之后的属性值</span><br><span class="line">               Object convertedValue = resolvedValue;</span><br><span class="line">               //属性值是否可以转换</span><br><span class="line">               boolean convertible = bw.isWritableProperty(propertyName) &amp;&amp;</span><br><span class="line">                       !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</span><br><span class="line">               if (convertible) &#123;</span><br><span class="line">                   //使用用户自定义的类型转换器转换属性值</span><br><span class="line">                   convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);</span><br><span class="line">               &#125;</span><br><span class="line">               //存储转换后的属性值，避免每次属性注入时的转换工作</span><br><span class="line">               if (resolvedValue == originalValue) &#123;</span><br><span class="line">                   if (convertible) &#123;</span><br><span class="line">                       //设置属性转换之后的值</span><br><span class="line">                       pv.setConvertedValue(convertedValue);</span><br><span class="line">                   &#125;</span><br><span class="line">                   deepCopy.add(pv);</span><br><span class="line">               &#125;</span><br><span class="line">               //属性是可转换的，且属性原始值是字符串类型，且属性的原始类型值不是</span><br><span class="line">               //动态生成的字符串，且属性的原始值不是集合或者数组类型</span><br><span class="line">               else if (convertible &amp;&amp; originalValue instanceof TypedStringValue &amp;&amp;</span><br><span class="line">                       !((TypedStringValue) originalValue).isDynamic() &amp;&amp;</span><br><span class="line">                       !(convertedValue instanceof Collection ||</span><br><span class="line">                               ObjectUtils.isArray(convertedValue))) &#123;</span><br><span class="line">                   pv.setConvertedValue(convertedValue);</span><br><span class="line">                   deepCopy.add(pv);</span><br><span class="line">               &#125;</span><br><span class="line">               else &#123;</span><br><span class="line">                   resolveNecessary = true;</span><br><span class="line">                   //重新封装属性的值</span><br><span class="line">                   deepCopy.add(new PropertyValue(pv, convertedValue));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (mpvs != null &amp;&amp; !resolveNecessary) &#123;</span><br><span class="line">           //标记属性值已经转换过</span><br><span class="line">           mpvs.setConverted();</span><br><span class="line">       &#125;</span><br><span class="line">       //进行属性依赖注入</span><br><span class="line">       try &#123;</span><br><span class="line">           bw.setPropertyValues(new MutablePropertyValues(deepCopy));</span><br><span class="line">       &#125;</span><br><span class="line">       catch (BeansException ex) &#123;</span><br><span class="line">           throw new BeanCreationException(</span><br><span class="line">                   mbd.getResourceDescription(), beanName, &quot;Error setting property values&quot;, ex);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>分析上述代码，我们可以看出，对属性的注入过程分以下两种情况:</p><ul><li>属性值类型不需要转换时，不需要解析属性值，直接准备进行依赖注入</li><li>属性值需要进行类型转换时，如对其他对象的引用等，首先需要解析属性值，然后对解析后的属性值进行依赖注入。</li></ul><p>对属性值的解析是在 BeanDefinitionValueResolver 类中的 resolveValueIfNecessary 方法中进行的，<br>对属性值的依赖注入是通过 bw.setPropertyValues 方法实现的，在分析属性值的依赖注入之前，我们<br>先分析一下对属性值的解析过程。</p><h1><a id="BeanDefinitionValueResolver__126"></a>BeanDefinitionValueResolver 解析属性值</h1><p>当容器在对属性进行依赖注入时，如果发现属性值需要进行类型转换，如属性值是容器中另一个 Bean<br>实例对象的引用，则容器首先需要根据属性值解析出所引用的对象，然后才能将该引用对象注入到目标<br>实例对象的属性上去，对属性进行解析的由 resolveValueIfNecessary 方法实现，其源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">//解析属性值，对注入类型进行转换</span><br><span class="line">    public Object resolveValueIfNecessary(Object argName, Object value) &#123;</span><br><span class="line">        //对引用类型的属性进行解析</span><br><span class="line">        if (value instanceof RuntimeBeanReference) &#123;</span><br><span class="line">            RuntimeBeanReference ref = (RuntimeBeanReference) value;</span><br><span class="line">            //调用引用类型属性的解析方法</span><br><span class="line">            return resolveReference(argName, ref);</span><br><span class="line">        &#125;</span><br><span class="line">        //对属性值是引用容器中另一个 Bean 名称的解析</span><br><span class="line">        else if (value instanceof RuntimeBeanNameReference) &#123;</span><br><span class="line">            String refName = ((RuntimeBeanNameReference) value).getBeanName();</span><br><span class="line">            refName = String.valueOf(evaluate(refName));</span><br><span class="line">            //从容器中获取指定名称的 Bean</span><br><span class="line">            if (!this.beanFactory.containsBean(refName)) &#123;</span><br><span class="line">                throw new BeanDefinitionStoreException(</span><br><span class="line">                        &quot;Invalid bean name &apos;&quot; + refName + &quot;&apos; in bean reference for &quot; + argName);</span><br><span class="line">            &#125;</span><br><span class="line">            return refName;</span><br><span class="line">        &#125;</span><br><span class="line">        //对 Bean 类型属性的解析，主要是 Bean 中的内部类</span><br><span class="line">        else if (value instanceof BeanDefinitionHolder) &#123;</span><br><span class="line">            BeanDefinitionHolder bdHolder = (BeanDefinitionHolder) value;</span><br><span class="line">            return resolveInnerBean(argName, bdHolder.getBeanName(), bdHolder.getBeanDefinition());</span><br><span class="line">        &#125;</span><br><span class="line">        else if (value instanceof BeanDefinition) &#123;</span><br><span class="line">            BeanDefinition bd = (BeanDefinition) value;</span><br><span class="line">            return resolveInnerBean(argName, &quot;(inner bean)&quot;, bd);</span><br><span class="line">        &#125;</span><br><span class="line">        //对集合数组类型的属性解析</span><br><span class="line">        else if (value instanceof ManagedArray) &#123;</span><br><span class="line">            ManagedArray array = (ManagedArray) value;</span><br><span class="line">            //获取数组的类型</span><br><span class="line">            Class elementType = array.resolvedElementType;</span><br><span class="line">            if (elementType == null) &#123;</span><br><span class="line">                //获取数组元素的类型</span><br><span class="line">                String elementTypeName = array.getElementTypeName();</span><br><span class="line">                if (StringUtils.hasText(elementTypeName)) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        //使用反射机制创建指定类型的对象</span><br><span class="line">                        elementType = ClassUtils.forName(elementTypeName,</span><br><span class="line">                                this.beanFactory.getBeanClassLoader());</span><br><span class="line">                        array.resolvedElementType = elementType;</span><br><span class="line">                    &#125;</span><br><span class="line">                    catch (Throwable ex) &#123;</span><br><span class="line">                        throw new BeanCreationException(</span><br><span class="line">                                this.beanDefinition.getResourceDescription(), this.beanName,</span><br><span class="line">                                &quot;Error resolving array type for &quot; + argName, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //没有获取到数组的类型，也没有获取到数组元素的类型</span><br><span class="line">                //则直接设置数组的类型为 Object</span><br><span class="line">                else &#123;</span><br><span class="line">                    elementType = Object.class;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //创建指定类型的数组</span><br><span class="line">            return resolveManagedArray(argName, (List&lt;?&gt;) value, elementType);</span><br><span class="line">        &#125;</span><br><span class="line">        //解析 list 类型的属性值</span><br><span class="line">        else if (value instanceof ManagedList) &#123;</span><br><span class="line">            return resolveManagedList(argName, (List&lt;?&gt;) value);</span><br><span class="line">        &#125;</span><br><span class="line">        //解析 set 类型的属性值</span><br><span class="line">        else if (value instanceof ManagedSet) &#123;</span><br><span class="line">            return resolveManagedSet(argName, (Set&lt;?&gt;) value);</span><br><span class="line">        &#125;</span><br><span class="line">        //解析 map 类型的属性值</span><br><span class="line">        else if (value instanceof ManagedMap) &#123;</span><br><span class="line">            return resolveManagedMap(argName, (Map&lt;?, ?&gt;) value);</span><br><span class="line">        &#125;</span><br><span class="line">        //解析 props 类型的属性值，props 其实就是 key 和 value 均为字符串的 map</span><br><span class="line">        else if (value instanceof ManagedProperties) &#123;</span><br><span class="line">            Properties original = (Properties) value;</span><br><span class="line">            //创建一个拷贝，用于作为解析后的返回值</span><br><span class="line">            Properties copy = new Properties();</span><br><span class="line">            for (Map.Entry propEntry : original.entrySet()) &#123;</span><br><span class="line">                Object propKey = propEntry.getKey();</span><br><span class="line">                Object propValue = propEntry.getValue();</span><br><span class="line">                if (propKey instanceof TypedStringValue) &#123;</span><br><span class="line">                    propKey = evaluate((TypedStringValue) propKey);</span><br><span class="line">                &#125;</span><br><span class="line">                if (propValue instanceof TypedStringValue) &#123;</span><br><span class="line">                    propValue = evaluate((TypedStringValue) propValue);</span><br><span class="line">                &#125;</span><br><span class="line">                copy.put(propKey, propValue);</span><br><span class="line">            &#125;</span><br><span class="line">            return copy;</span><br><span class="line">        &#125;</span><br><span class="line">        //解析字符串类型的属性值</span><br><span class="line">        else if (value instanceof TypedStringValue) &#123;</span><br><span class="line">            TypedStringValue typedStringValue = (TypedStringValue) value;</span><br><span class="line">            Object valueObject = evaluate(typedStringValue);</span><br><span class="line">            try &#123;</span><br><span class="line">                //获取属性的目标类型</span><br><span class="line">                Class&lt;?&gt; resolvedTargetType = resolveTargetType(typedStringValue);</span><br><span class="line">                if (resolvedTargetType != null) &#123;</span><br><span class="line">                    //对目标类型的属性进行解析，递归调用</span><br><span class="line">                    return this.typeConverter.convertIfNecessary(valueObject, resolvedTargetType);</span><br><span class="line">                &#125;</span><br><span class="line">                //没有获取到属性的目标对象，则按 Object 类型返回</span><br><span class="line">                else &#123;</span><br><span class="line">                    return valueObject;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Throwable ex) &#123;</span><br><span class="line">                throw new BeanCreationException(</span><br><span class="line">                        this.beanDefinition.getResourceDescription(), this.beanName,</span><br><span class="line">                        &quot;Error converting typed String value for &quot; + argName, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return evaluate(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //解析引用类型的属性值</span><br><span class="line">    private Object resolveReference(Object argName, RuntimeBeanReference ref) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //获取引用的 Bean 名称</span><br><span class="line">            String refName = ref.getBeanName();</span><br><span class="line">            refName = String.valueOf(evaluate(refName));</span><br><span class="line">            //如果引用的对象在父类容器中，则从父类容器中获取指定的引用对象</span><br><span class="line">            if (ref.isToParent()) &#123;</span><br><span class="line">                if (this.beanFactory.getParentBeanFactory() == null) &#123;</span><br><span class="line">                    throw new BeanCreationException(</span><br><span class="line">                            this.beanDefinition.getResourceDescription(), this.beanName,</span><br><span class="line">                            &quot;Can&apos;t resolve reference to bean &apos;&quot; + refName +</span><br><span class="line">                                    &quot;&apos; in parent factory: no parent factory available&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                return this.beanFactory.getParentBeanFactory().getBean(refName);</span><br><span class="line">            &#125;</span><br><span class="line">            //从当前的容器中获取指定的引用 Bean 对象，如果指定的 Bean 没有被实例化</span><br><span class="line">            //则会递归触发引用 Bean 的初始化和依赖注入</span><br><span class="line">            else &#123;</span><br><span class="line">                Object bean = this.beanFactory.getBean(refName);</span><br><span class="line">                //将当前实例化对象的依赖引用对象</span><br><span class="line">                this.beanFactory.registerDependentBean(refName, this.beanName);</span><br><span class="line">                return bean;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (BeansException ex) &#123;</span><br><span class="line">            throw new BeanCreationException(</span><br><span class="line">                    this.beanDefinition.getResourceDescription(), this.beanName,</span><br><span class="line">                    &quot;Cannot resolve reference to bean &apos;&quot; + ref.getBeanName() + &quot;&apos; while setting &quot; +</span><br><span class="line">                            argName, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //解析 array 类型的属性</span><br><span class="line">    private Object resolveManagedArray(Object argName, List&lt;?&gt; ml, Class elementType) &#123;</span><br><span class="line">        //创建一个指定类型的数组，用于存放和返回解析后的数组</span><br><span class="line">        Object resolved = Array.newInstance(elementType, ml.size());</span><br><span class="line">        for (int i = 0; i &lt; ml.size(); i++) &#123;</span><br><span class="line">            //递归解析 array 的每一个元素，并将解析后的值设置到 resolved 数组中，索引为 i</span><br><span class="line">            Array.set(resolved, i,</span><br><span class="line">                    resolveValueIfNecessary(new KeyedArgName(argName, i), ml.get(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        return resolved;</span><br><span class="line">    &#125;</span><br><span class="line">    //解析 list 类型的属性</span><br><span class="line">    private List resolveManagedList(Object argName, List&lt;?&gt; ml) &#123;</span><br><span class="line">        List&lt;Object&gt; resolved = new ArrayList&lt;Object&gt;(ml.size());</span><br><span class="line">        for (int i = 0; i &lt; ml.size(); i++) &#123;</span><br><span class="line">            //递归解析 list 的每一个元素</span><br><span class="line">            resolved.add(</span><br><span class="line">                    resolveValueIfNecessary(new KeyedArgName(argName, i), ml.get(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        return resolved;</span><br><span class="line">    &#125;</span><br><span class="line">    //解析 set 类型的属性</span><br><span class="line">    private Set resolveManagedSet(Object argName, Set&lt;?&gt; ms) &#123;</span><br><span class="line">        Set&lt;Object&gt; resolved = new LinkedHashSet&lt;Object&gt;(ms.size());</span><br><span class="line">        int i = 0;</span><br><span class="line">        //递归解析 set 的每一个元素</span><br><span class="line">        for (Object m : ms) &#123;</span><br><span class="line">            resolved.add(resolveValueIfNecessary(new KeyedArgName(argName, i), m));</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return resolved;</span><br><span class="line">    &#125;</span><br><span class="line">    //解析 map 类型的属性</span><br><span class="line">    private Map resolveManagedMap(Object argName, Map&lt;?, ?&gt; mm) &#123;</span><br><span class="line">        Map&lt;Object, Object&gt; resolved = new LinkedHashMap&lt;Object, Object&gt;(mm.size());</span><br><span class="line">        //递归解析 map 中每一个元素的 key 和 value</span><br><span class="line">        for (Map.Entry entry : mm.entrySet()) &#123;</span><br><span class="line">            Object resolvedKey = resolveValueIfNecessary(argName, entry.getKey());</span><br><span class="line">            Object resolvedValue = resolveValueIfNecessary(</span><br><span class="line">                    new KeyedArgName(argName, entry.getKey()), entry.getValue());</span><br><span class="line">            resolved.put(resolvedKey, resolvedValue);</span><br><span class="line">        &#125;</span><br><span class="line">        return resolved;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码分析，我们明白了 Spring 是如何将引用类型，内部类以及集合类型等属性进行解析的，<br>属性值解析完成后就可以进行依赖注入了，依赖注入的过程就是 Bean 对象实例设置到它所依赖的 Bean<br>对象属性上去，在第 7 步中我们已经说过，依赖注入是通过 bw.setPropertyValues 方法实现的，该方<br>法也使用了委托模式，在 BeanWrapper 接口中至少定义了方法声明，依赖注入的具体实现交由其实现类<br>BeanWrapperImpl 来完成，下面我们就分析依 BeanWrapperImpl 中赖注入相关的源码。</p><h1><a id="BeanWrapperImpl__Bean__137"></a>BeanWrapperImpl 对 Bean 属性的依赖注入</h1><p>BeanWrapperImpl 类主要是对容器中完成初始化的 Bean 实例对象进行属性的依赖注入，即把 Bean 对象<br>设置到它所依赖的另一个 Bean 的属性中去，依赖注入的相关源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line">//实现属性依赖注入功能</span><br><span class="line">    private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException &#123;</span><br><span class="line">        //PropertyTokenHolder 主要保存属性的名称、路径，以及集合的 size 等信息</span><br><span class="line">        String propertyName = tokens.canonicalName;</span><br><span class="line">        String actualName = tokens.actualName;</span><br><span class="line">        //keys 是用来保存集合类型属性的 size</span><br><span class="line">        if (tokens.keys != null) &#123;</span><br><span class="line">            //将属性信息拷贝</span><br><span class="line">            PropertyTokenHolder getterTokens = new PropertyTokenHolder();</span><br><span class="line">            getterTokens.canonicalName = tokens.canonicalName;</span><br><span class="line">            getterTokens.actualName = tokens.actualName;</span><br><span class="line">            getterTokens.keys = new String[tokens.keys.length - 1];</span><br><span class="line">            System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);</span><br><span class="line">            Object propValue;</span><br><span class="line">            try &#123;</span><br><span class="line">                //获取属性值，该方法内部使用 JDK 的内省( Introspector)机制</span><br><span class="line">                //调用属性的 getter(readerMethod)方法，获取属性的值</span><br><span class="line">                propValue = getPropertyValue(getterTokens);</span><br><span class="line">            &#125; catch (NotReadablePropertyException ex) &#123;</span><br><span class="line">                throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,</span><br><span class="line">                        &quot;Cannot access indexed value in property referenced &quot; +</span><br><span class="line">                                &quot;in indexed property path &apos;&quot; + propertyName + &quot;&apos;&quot;, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            //获取集合类型属性的长度</span><br><span class="line">            String key = tokens.keys[tokens.keys.length - 1];</span><br><span class="line">            if (propValue == null) &#123;</span><br><span class="line">                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath +</span><br><span class="line">                        propertyName,</span><br><span class="line">                        &quot;Cannot access indexed value in property referenced &quot; +</span><br><span class="line">                                &quot;in indexed property path &apos;&quot; + propertyName + &quot;&apos;: returned null&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            //注入 array 类型的属性值</span><br><span class="line">            else if (propValue.getClass().isArray()) &#123;</span><br><span class="line">                //获取属性的描述符</span><br><span class="line">                PropertyDescriptor pd =</span><br><span class="line">                        getCachedIntrospectionResults().getPropertyDescriptor(actualName);</span><br><span class="line">                //获取数组的类型</span><br><span class="line">                Class requiredType = propValue.getClass().getComponentType();</span><br><span class="line">                //获取数组的长度</span><br><span class="line">                int arrayIndex = Integer.parseInt(key);</span><br><span class="line">                Object oldValue = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //获取数组以前初始化的值</span><br><span class="line">                    if (isExtractOldValueForEditor()) &#123;</span><br><span class="line">                        oldValue = Array.get(propValue, arrayIndex);</span><br><span class="line">                    &#125;</span><br><span class="line">                    //将属性的值赋值给数组中的元素</span><br><span class="line">                    Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),</span><br><span class="line">                            requiredType,</span><br><span class="line">                            new PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(),</span><br><span class="line">                                    -1), requiredType));</span><br><span class="line">                    Array.set(propValue, arrayIndex, convertedValue);</span><br><span class="line">                &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                    throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,</span><br><span class="line">                            &quot;Invalid array index in property path &apos;&quot; + propertyName + &quot;&apos;&quot;, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //注入 list 类型的属性值</span><br><span class="line">            else if (propValue instanceof List) &#123;</span><br><span class="line">                PropertyDescriptor pd =</span><br><span class="line">                        getCachedIntrospectionResults().getPropertyDescriptor(actualName);</span><br><span class="line">                //获取 list 集合的类型</span><br><span class="line">                Class requiredType = GenericCollectionTypeResolver.getCollectionReturnType(</span><br><span class="line">                        pd.getReadMethod(), tokens.keys.length);</span><br><span class="line">                List list = (List) propValue;</span><br><span class="line">                //获取 list 集合的 size</span><br><span class="line">                int index = Integer.parseInt(key);</span><br><span class="line">                Object oldValue = null;</span><br><span class="line">                if (isExtractOldValueForEditor() &amp;&amp; index &lt; list.size()) &#123;</span><br><span class="line">                    oldValue = list.get(index);</span><br><span class="line">                &#125;</span><br><span class="line">                //获取 list 解析后的属性值</span><br><span class="line">                Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),</span><br><span class="line">                        requiredType,</span><br><span class="line">                        new PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1),</span><br><span class="line">                                requiredType));</span><br><span class="line">                if (index &lt; list.size()) &#123;</span><br><span class="line">                    //为 list 属性赋值</span><br><span class="line">                    list.set(index, convertedValue);</span><br><span class="line">                &#125;</span><br><span class="line">                //如果 list 的长度大于属性值的长度，则多余的元素赋值为 null</span><br><span class="line">                else if (index &gt;= list.size()) &#123;</span><br><span class="line">                    for (int i = list.size(); i &lt; index; i++) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            list.add(null);</span><br><span class="line">                        &#125; catch (NullPointerException ex) &#123;</span><br><span class="line">                            throw new InvalidPropertyException(getRootClass(), this.nestedPath +</span><br><span class="line">                                    propertyName,</span><br><span class="line">                                    &quot;Cannot set element with index &quot; + index + &quot; in List of size &quot; +</span><br><span class="line">                                            list.size() + &quot;, accessed using property path &apos;&quot; + propertyName +</span><br><span class="line">                                            &quot;&apos;: List does not support filling up gaps with null elements&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    list.add(convertedValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //注入 map 类型的属性值</span><br><span class="line">            else if (propValue instanceof Map) &#123;</span><br><span class="line">                PropertyDescriptor pd =</span><br><span class="line">                        getCachedIntrospectionResults().getPropertyDescriptor(actualName);</span><br><span class="line">                //获取 map 集合 key 的类型</span><br><span class="line">                Class mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(</span><br><span class="line">                        pd.getReadMethod(), tokens.keys.length);</span><br><span class="line">                //获取 map 集合 value 的类型</span><br><span class="line">                Class mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(</span><br><span class="line">                        pd.getReadMethod(), tokens.keys.length);</span><br><span class="line">                Map map = (Map) propValue;</span><br><span class="line">                //解析 map 类型属性 key 值</span><br><span class="line">                Object convertedMapKey = convertIfNecessary(null, null, key, mapKeyType,</span><br><span class="line">                        new PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1),</span><br><span class="line">                                mapKeyType));</span><br><span class="line">                Object oldValue = null;</span><br><span class="line">                if (isExtractOldValueForEditor()) &#123;</span><br><span class="line">                    oldValue = map.get(convertedMapKey);</span><br><span class="line">                &#125;</span><br><span class="line">                //解析 map 类型属性 value 值</span><br><span class="line">                Object convertedMapValue = convertIfNecessary(</span><br><span class="line">                        propertyName, oldValue, pv.getValue(), mapValueType,</span><br><span class="line">                        new TypeDescriptor(new MethodParameter(pd.getReadMethod(), -1,</span><br><span class="line">                                tokens.keys.length + 1)));</span><br><span class="line">                //将解析后的 key 和 value 值赋值给 map 集合属性</span><br><span class="line">                map.put(convertedMapKey, convertedMapValue);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,</span><br><span class="line">                        &quot;Property referenced in indexed property path &apos;&quot; + propertyName +</span><br><span class="line">                                &quot;&apos; is neither an array nor a List nor a Map; returned value was [&quot; + pv.getValue()</span><br><span class="line">                                + &quot;]&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //对非集合类型的属性注入</span><br><span class="line">        else &#123;</span><br><span class="line">            PropertyDescriptor pd = pv.resolvedDescriptor;</span><br><span class="line">            if (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) &#123;</span><br><span class="line">                pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);</span><br><span class="line">                //无法获取到属性名或者属性没有提供 setter(写方法)方法</span><br><span class="line">                if (pd == null || pd.getWriteMethod() == null) &#123;</span><br><span class="line">                    //如果属性值是可选的，即不是必须的，则忽略该属性值</span><br><span class="line">                    if (pv.isOptional()) &#123;</span><br><span class="line">                        logger.debug(&quot;Ignoring optional value for property &apos;&quot; + actualName +</span><br><span class="line">                                &quot;&apos; - property not found on bean class [&quot; + getRootClass().getName() +</span><br><span class="line">                                &quot;]&quot;);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //如果属性值是必须的，则抛出无法给属性赋值，因为没提供 setter 方法异常</span><br><span class="line">                    else &#123;</span><br><span class="line">                        PropertyMatches matches = PropertyMatches.forProperty(propertyName,</span><br><span class="line">                                getRootClass());</span><br><span class="line">                        throw new NotWritablePropertyException(</span><br><span class="line">                                getRootClass(), this.nestedPath + propertyName,</span><br><span class="line">                                matches.buildErrorMessage(), matches.getPossibleMatches());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                pv.getOriginalPropertyValue().resolvedDescriptor = pd;</span><br><span class="line">            &#125;</span><br><span class="line">            Object oldValue = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                Object originalValue = pv.getValue();</span><br><span class="line">                Object valueToApply = originalValue;</span><br><span class="line">                if (!Boolean.FALSE.equals(pv.conversionNecessary)) &#123;</span><br><span class="line">                    if (pv.isConverted()) &#123;</span><br><span class="line">                        valueToApply = pv.getConvertedValue();</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        if (isExtractOldValueForEditor() &amp;&amp; pd.getReadMethod() != null) &#123;</span><br><span class="line">                            //获取属性的 getter 方法(读方法)，JDK 内省机制</span><br><span class="line">                            final Method readMethod = pd.getReadMethod();</span><br><span class="line">                            //如果属性的 getter 方法不是 public 访问控制权限的，即访问控制权限比较严格，</span><br><span class="line">                            //则使用 JDK 的反射机制强行访问非 public 的方法(暴力读取属性值)</span><br><span class="line">                            if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &amp;&amp;</span><br><span class="line">                                    !readMethod.isAccessible()) &#123;</span><br><span class="line">                                if (System.getSecurityManager() != null) &#123;</span><br><span class="line">                                    //匿名内部类，根据权限修改属性的读取控制限制</span><br><span class="line">                                    AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                                        public Object run() &#123;</span><br><span class="line">                                            readMethod.setAccessible(true);</span><br><span class="line">                                            return null;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;);</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                    readMethod.setAccessible(true);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                //属性没有提供 getter 方法时，调用潜在的读取属性值的方法，获取属性值</span><br><span class="line">                                if (System.getSecurityManager() != null) &#123;</span><br><span class="line">                                    oldValue = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line">                                         public Object run() throws Exception &#123;</span><br><span class="line">                                             return readMethod.invoke(object);</span><br><span class="line">                                         &#125;</span><br><span class="line">                                     &#125;, acc);</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                    oldValue = readMethod.invoke(object);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; catch (Exception ex) &#123;</span><br><span class="line">                                if (ex instanceof PrivilegedActionException) &#123;</span><br><span class="line">                                    ex = ((PrivilegedActionException) ex).getException();</span><br><span class="line">                                &#125;</span><br><span class="line">                                if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                                    logger.debug(&quot;Could not read previous value of property &apos;&quot; +</span><br><span class="line">                                            this.nestedPath + propertyName + &quot;&apos;&quot;, ex);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //设置属性的注入值</span><br><span class="line">                        valueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);</span><br><span class="line">                    &#125;</span><br><span class="line">                    pv.getOriginalPropertyValue().conversionNecessary = (valueToApply !=</span><br><span class="line">                            originalValue);</span><br><span class="line">                &#125;</span><br><span class="line">                //根据 JDK 的内省机制，获取属性的 setter(写方法)方法</span><br><span class="line">                final Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?</span><br><span class="line">                        ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :</span><br><span class="line">                        pd.getWriteMethod());</span><br><span class="line">                //如果属性的 setter 方法是非 public，即访问控制权限比较严格，则使用 JDK 的反射机制，</span><br><span class="line">                //强行设置 setter 方法可访问(暴力为属性赋值)</span><br><span class="line">                if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())</span><br><span class="line">                        &amp;&amp; !writeMethod.isAccessible()) &#123;</span><br><span class="line">                    //如果使用了 JDK 的安全机制，则需要权限验证</span><br><span class="line">                    if (System.getSecurityManager() != null) &#123;</span><br><span class="line">                        AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                            public Object run() &#123;</span><br><span class="line">                                writeMethod.setAccessible(true);</span><br><span class="line">                                return null;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        writeMethod.setAccessible(true);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                final Object value = valueToApply;</span><br><span class="line">                if (System.getSecurityManager() != null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        //将属性值设置到属性上去</span><br><span class="line">                        AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line">                            public Object run() throws Exception &#123;</span><br><span class="line">                                writeMethod.invoke(object, value);</span><br><span class="line">                                return null;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;, acc);</span><br><span class="line">                    &#125; catch (PrivilegedActionException ex) &#123;</span><br><span class="line">                        throw ex.getException();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    writeMethod.invoke(this.object, value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (TypeMismatchException ex) &#123;</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125; catch (InvocationTargetException ex) &#123;</span><br><span class="line">                PropertyChangeEvent propertyChangeEvent =</span><br><span class="line">                        new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName,</span><br><span class="line">                                oldValue, pv.getValue());</span><br><span class="line">                if (ex.getTargetException() instanceof ClassCastException) &#123;</span><br><span class="line">                    throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(),</span><br><span class="line">                            ex.getTargetException());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new MethodInvocationException(propertyChangeEvent,</span><br><span class="line">                            ex.getTargetException());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception ex) &#123;</span><br><span class="line">                PropertyChangeEvent pce =</span><br><span class="line">                        new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName,</span><br><span class="line">                                oldValue, pv.getValue());</span><br><span class="line">                throw new MethodInvocationException(pce, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过对上面注入依赖代码的分析，我们已经明白了 Spring IOC 容器是如何将属性的值注入到 Bean 实<br>例对象中去的：</p><ul><li>对于集合类型的属性，将其属性值解析为目标类型的集合后直接赋值给属性。</li><li>对于非集合类型的属性，大量使用了 JDK 的反射和内省机制，通过属性的 getter 方法(reader method)获取指定属性注入以前的值，同时调用属性的 setter 方法(writer method)为属性设置注入后的值。看到这里相信很多人都明白了 Spring 的 setter 注入原理。</li></ul><p>至此 Spring IOC 容器对 Bean 定义资源文件的定位，载入、解析和依赖注入已经全部分析完毕，现在<br>Spring IOC 容器中管理了一系列靠依赖关系联系起来的 Bean，程序不需要应用自己手动创建所需的对<br>象，Spring IOC 容器会在我们使用的时候自动为我们创建，并且为我们注入好相关的依赖，这就是<br>Spring 核心功能的控制反转和依赖注入的相关功能。</p><p><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/DI%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt></p></div><div id="wechat_subscriber" style="display:block;padding:10px 0;margin:20px auto;width:100%;text-align:center"><img id="wechat_subscriber_qcode" src="/blog/uploads/wechat-qcode.png" alt="Jeff-Eric wechat" style="width:200px;max-width:100%"><div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Jeff-Eric</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://jeff-eric.github.com/blog/2019/10/22/spring%20-%20DI/" title="spring - DI">https:&#x2F;&#x2F;jeff-eric.github.com&#x2F;blog&#x2F;2019&#x2F;10&#x2F;22&#x2F;spring%20-%20DI&#x2F;</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank">&lt;i class=&quot;fa fa-fw fa-creative-commons&quot;&gt;&lt;&#x2F;i&gt;BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/blog/tags/%E6%9E%B6%E6%9E%84%E5%B8%88/" rel="tag"># 架构师</a></div><div class="post-widgets"><div class="social_share"><div id="needsharebutton-postbottom"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/blog/2019/10/22/spring%20-%20%E7%AE%80%E4%BB%8B/" rel="next" title="spring - 简介"><i class="fa fa-chevron-left"></i> spring - 简介</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/blog/2019/10/22/spring%20-%20AOP/" rel="prev" title="spring - AOP">spring - AOP <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/blog/uploads/avatar.jpg" alt="Jeff-Eric"><p class="site-author-name" itemprop="name">Jeff-Eric</p><div class="site-description motion-element" itemprop="description"></div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/blog/archives/%20%7C%7C%20archive"><span class="site-state-item-count">42</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/blog/categories/%20%7C%7C%20th"><span class="site-state-item-count">12</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/blog/tags/%20%7C%7C%20tags"><span class="site-state-item-count">28</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/jeff-eric" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;jeff-eric" rel="noopener" target="_blank">&lt;i class=&quot;fa fa-fw fa-github&quot;&gt;&lt;&#x2F;i&gt;GitHub</a> </span><span class="links-of-author-item"><a href="/blog/jphoebe4086824@gmail.com" title="E-Mail &amp;rarr; jphoebe4086824@gmail.com">&lt;i class=&quot;fa fa-fw fa-envelope&quot;&gt;&lt;&#x2F;i&gt;E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank">&lt;img src=&quot;&#x2F;blog&#x2F;images&#x2F;cc-by-nc-sa.svg&quot; alt=&quot;Creative Commons&quot;&#x2F;&gt;</a></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">1.</span> <span class="nav-text">依赖注入发生的时间</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">2.</span> <span class="nav-text">AbstractBeanFactory 通过 getBean 向 IOC 容器获取被管理的 Bean</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">3.</span> <span class="nav-text">循环依赖的产生和解决的前提</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">3.1.</span> <span class="nav-text">¶三级缓存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">4.</span> <span class="nav-text">AbstractAutowireCapableBeanFactory 创建 Bean 实例对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">5.</span> <span class="nav-text">createBeanInstance 方法创建 Bean 的 java 实例对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">6.</span> <span class="nav-text">SimpleInstantiationStrategy 类使用默认的无参构造方法创建 Bean 实例化对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">7.</span> <span class="nav-text">populateBean 方法对 Bean 属性的依赖注入</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">8.</span> <span class="nav-text">BeanDefinitionValueResolver 解析属性值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">9.</span> <span class="nav-text">BeanWrapperImpl 对 Bean 属性的依赖注入</span></a></li></ol></div></div></div><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Jeff-Eric</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0</div><span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.0.1</div></div></footer><div id="needsharebutton-float"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script><script id="ribbon" size="300" alpha="0.6" zindex="-1" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@2/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/npm/fastclick@1/lib/fastclick.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery-lazyload@1/jquery.lazyload.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three-waves.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_lines.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_sphere.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-reading-progress@1/reading_progress.min.js"></script><script src="/blog/js/src/utils.js?v=7.0.1"></script><script src="/blog/js/src/motion.js?v=7.0.1"></script><script src="/blog/js/src/affix.js?v=7.0.1"></script><script src="/blog/js/src/schemes/pisces.js?v=7.0.1"></script><script src="/blog/js/src/scrollspy.js?v=7.0.1"></script><script src="/blog/js/src/post-details.js?v=7.0.1"></script><script src="/blog/js/src/next-boot.js?v=7.0.1"></script><script src="/blog/js/src/js.cookie.js?v=7.0.1"></script><script src="/blog/js/src/scroll-cookie.js?v=7.0.1"></script><script src="//cdn.jsdelivr.net/npm/leancloud-storage@3/dist/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js"></script><script>var GUEST=["nick","mail","link"],guest="nick,mail,link";guest=guest.split(",").filter(function(e){return GUEST.indexOf(e)>-1}),new Valine({el:"#comments",verify:!0,notify:!1,appId:"MKGyMx7EafphCr9hAbMPAwAc-gzGzoHsz",appKey:"4SB8MPoE51bFPHDoKtPM8vLG",placeholder:"Just go go",avatar:"mm",meta:guest,pageSize:"10",visitor:!0})</script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var e=$("#local-search-input");e.attr("autocapitalize","none"),e.attr("autocorrect","off"),e.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/blog/"+search_path,onPopupClose=function(e){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(e,t,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:e,dataType:isXml?"xml":"json",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,r=document.getElementById(t),s=document.getElementById(o),a=function(){var e=r.value.trim().toLowerCase(),t=e.split(/[\s\-]+/);t.length>1&&t.push(e);var o=[];if(e.length>0&&n.forEach(function(n){function r(t,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===e&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(e,t){var o="",n=t.start;return t.hits.forEach(function(t){o+=e.substring(n,t.position);var r=t.position+t.length;o+='<b class="search-keyword">'+e.substring(t.position,r)+"</b>",n=r}),o+=e.substring(n,t.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url).replace(/\/{2,}/g,"/"),d=[],g=[];if(""!=l&&(t.forEach(function(e){function t(e,t,o){var n=e.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(t=t.toLowerCase(),e=e.toLowerCase());(s=t.indexOf(e,r))>-1;)a.push({position:s,word:e}),r=s+n;return a}d=d.concat(t(e,h,!1)),g=g.concat(t(e,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(e){e.sort(function(e,t){return t.position!==e.position?t.position-e.position:e.word.length-t.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hits.length!==t.hits.length?t.hits.length-e.hits.length:e.start-t.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(e){b+="<a href='"+f+'\'><p class="search-result">'+s(p,e)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===t.length&&""===t[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x"></i></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>';else{o.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hitCount!==t.hitCount?t.hitCount-e.hitCount:t.id-e.id});var a='<ul class="search-result-list">';o.forEach(function(e){a+=e.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(e){e.stopPropagation()}),$(document).on("keyup",function(e){var t=27===e.which&&$(".search-popup").is(":visible");t&&onPopupClose()})</script><script src="https://www.gstatic.com/firebasejs/4.6.0/firebase.js"></script><script src="https://www.gstatic.com/firebasejs/4.6.0/firebase-firestore.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/bluebird/3.5.1/bluebird.core.min.js"></script><script>!function(){function getCount(t,e){return t.get().then(function(a){var n;return a.exists?(n=a.data().count,e&&(window.localStorage&&window.localStorage.getItem(title)||(t.set({count:n+1}),n++))):e?(t.set({count:1}),n=1):n=0,window.localStorage&&e&&localStorage.setItem(title,!0),n})}function appendCountTo(t){return function(e){$(t).append($("<span>").addClass("post-visitors-count").append($("<span>").addClass("post-meta-divider").text("|")).append($("<span>").addClass("post-meta-item-icon").append($("<i>").addClass("fa fa-users"))).append($("<span>").text("阅读次数 "+e)))}}firebase.initializeApp({apiKey:"AIzaSyD-BIMnFQcvrv1utthoP5z5shcYP8JMKmY",projectId:"blog-6cbe0"});var db=firebase.firestore(),articles=db.collection("articles"),isPost="spring - DI".length>0,isArchive=!1,isCategory="".length>0,isTag="".length>0;if(isPost){var title="spring - DI",doc=articles.doc(title);getCount(doc,!0).then(appendCountTo($(".post-meta")))}else if(!isArchive&&!isCategory&&!isTag){var titles=[],postsstr="";eval(postsstr);var promises=titles.map(function(t){return articles.doc(t)}).map(function(t){return getCount(t)});Promise.all(promises).then(function(t){var e=$(".post-meta");t.forEach(function(t,a){appendCountTo(e[a])(t)})})}}()</script><style>.pdfobject-container{position:relative;overflow:auto;width:100%}</style><script>$("body").find("div.pdf").length&&$.ajax({type:"GET",url:"//cdn.jsdelivr.net/npm/pdfobject@2.1.1/pdfobject.min.js",dataType:"script",cache:!0,success:function(){$("body").find("div.pdf").each(function(e,t){PDFObject.embed($(t).attr("target"),$(t),{pdfOpenParams:{navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"},PDFJS_URL:"/lib/pdf/web/viewer.html",height:$(t).attr("height")||"500px"})})}})</script><script>$("body").find("pre.mermaid").length&&$.ajax({type:"GET",url:"//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js",dataType:"script",cache:!0,success:function(){mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})}})</script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script><script>pbOptions={},pbOptions.iconStyle="box",pbOptions.boxForm="horizontal",pbOptions.position="bottomCenter",pbOptions.networks="Weibo,Wechat,Douban,QQZone,Twitter,Facebook",new needShareButton("#needsharebutton-postbottom",pbOptions),flOptions={},flOptions.iconStyle="box",flOptions.boxForm="horizontal",flOptions.position="middleRight",flOptions.networks="Weibo,Wechat,Douban,QQZone,Twitter,Facebook",new needShareButton("#needsharebutton-float",flOptions)</script><script src="//cdn.jsdelivr.net/npm/pangu@3/dist/browser/pangu.min.js"></script><script>pangu.spacingPage()</script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@1/bookmark.min.js"></script><script>bookmark.scrollToMark("auto","#更多")</script><style>.copy-btn{display:inline-block;padding:6px 12px;font-size:13px;font-weight:700;line-height:20px;color:#333;white-space:nowrap;vertical-align:middle;cursor:pointer;background-color:#eee;background-image:linear-gradient(#fcfcfc,#eee);border:1px solid #d5d5d5;border-radius:3px;user-select:none;outline:0}.highlight-wrap .copy-btn{transition:opacity .3s ease-in-out;opacity:0;padding:2px 6px;position:absolute;right:4px;top:8px}.highlight-wrap .copy-btn:focus,.highlight-wrap:hover .copy-btn{opacity:1}.highlight-wrap{position:relative}</style><script>$(".highlight").each(function(t,e){var n=$("<div>").addClass("highlight-wrap");$(e).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(t){var e=$(this).parent().find(".code").find(".line").map(function(t,e){return $(e).text()}).toArray().join("\n"),n=document.createElement("textarea"),o=window.pageYOffset||document.documentElement.scrollTop;n.style.top=o+"px",n.style.position="absolute",n.style.opacity="0",n.readOnly=!0,n.value=e,document.body.appendChild(n),n.select(),n.setSelectionRange(0,e.length),n.readOnly=!1;var a=document.execCommand("copy");a?$(this).text("复制成功"):$(this).text("复制失败"),n.blur(),$(this).blur()})).on("mouseleave",function(t){var e=$(this).find(".copy-btn");setTimeout(function(){e.text("复制")},300)}).append(e)})</script></body></html><!-- rebuild by neat -->