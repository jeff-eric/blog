<!-- build time:Tue Nov 26 2019 14:32:21 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-CN,zh-HK,zh-TW,en,default"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/han-css@3/dist/han.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css"><link rel="stylesheet" href="/blog/css/main.css?v=7.0.1"><link rel="apple-touch-icon" sizes="180x180" href="/blog/uploads/avatar.jpg?v=7.0.1"><link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/avatar.jpg?v=7.0.1"><link rel="icon" type="image/png" sizes="16x16" href="/blog/blog/uploads/avatar.jpg?v=7.0.1"><link rel="mask-icon" href="/blog/uploads/avatar.jpg?v=7.0.1" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/blog/",scheme:"Gemini",version:"7.0.1",sidebar:{position:"left",display:"always",offset:12,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!0,fancybox:!0,fastclick:!0,lazyload:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="IOC体系结构¶BeanFactoryClassPathXmlApplicationContext 使用代码执行xml文件的类，是一个入口方法通过这个文件向上找，会发现最终会继承ListableBeanFactory、HierarchicalBeanFactory等等一些实现了BeanFactory的抽象类所以通过这个入口，我们发现BeanFactory是spring一切的基础，最顶级的抽象类Li"><meta name="keywords" content="架构师"><meta property="og:type" content="article"><meta property="og:title" content="spring - IOC"><meta property="og:url" content="https:&#x2F;&#x2F;jeff-eric.github.com&#x2F;blog&#x2F;2019&#x2F;10&#x2F;22&#x2F;spring%20-%20IOC&#x2F;index.html"><meta property="og:site_name" content="纯天然绿色学渣"><meta property="og:description" content="IOC体系结构¶BeanFactoryClassPathXmlApplicationContext 使用代码执行xml文件的类，是一个入口方法通过这个文件向上找，会发现最终会继承ListableBeanFactory、HierarchicalBeanFactory等等一些实现了BeanFactory的抽象类所以通过这个入口，我们发现BeanFactory是spring一切的基础，最顶级的抽象类Li"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191106110226.png"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191106155603.png"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191106162927.png"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191106163217.png"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191106163655.png"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191106164041.png"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191106165946.png"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191106202131.png"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191106202401.png"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191106202419.png"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191107114157.png"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;ioc%20%E6%B5%81%E7%A8%8B%E5%9B%BE.png"><meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191114174000.png"><meta property="og:updated_time" content="2019-11-14T09:40:59.363Z"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;jeff-eric&#x2F;images_bed&#x2F;master&#x2F;blog&#x2F;20191106110226.png"><link rel="canonical" href="https://jeff-eric.github.com/blog/2019/10/22/spring - IOC/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>spring - IOC | 纯天然绿色学渣</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?bb5d4f8207d7c2bd1aa936180430bbaa";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/blog/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">纯天然绿色学渣</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-home&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;首页</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-tags&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;标签&lt;span class=&quot;badge&quot;&gt;28&lt;&#x2F;span&gt;</a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-th&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;分类&lt;span class=&quot;badge&quot;&gt;12&lt;&#x2F;span&gt;</a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-archive&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;归档&lt;span class=&quot;badge&quot;&gt;42&lt;&#x2F;span&gt;</a></li><li class="menu-item menu-item-tools"><a href="/blog/tools/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-tree&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;工具</a></li><li class="menu-item menu-item-search"><a href="javascript:;" target="_blank" rel="noopener" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><div class="reading-progress-bar"></div><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jeff-eric.github.com/blog/blog/2019/10/22/spring%20-%20IOC/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jeff-Eric"><meta itemprop="description" content=""><meta itemprop="image" content="/blog/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="纯天然绿色学渣"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">spring - IOC</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-22 18:51:56" itemprop="dateCreated datePublished" datetime="2019-10-22T18:51:56+08:00">2019-10-22</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-11-14 17:40:59" itemprop="dateModified" datetime="2019-11-14T17:40:59+08:00">2019-11-14</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/blog/2019/10/22/spring%20-%20IOC/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/2019/10/22/spring%20-%20IOC/" itemprop="commentCount"></span> </a></span><span id="/blog/2019/10/22/spring%20-%20IOC/" class="leancloud_visitors" data-flag-title="spring - IOC"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body han-init-context" itemprop="articleBody"><h1><a id="IOC_1"></a>IOC体系结构</h1><h2><a id="BeanFactory_2"></a><a class="header-anchor" href="#beanfactory">¶</a>BeanFactory</h2><p><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191106110226.png" alt><br>ClassPathXmlApplicationContext 使用代码执行xml文件的类，是一个入口方法<br>通过这个文件向上找，会发现最终会继承ListableBeanFactory、HierarchicalBeanFactory等等一些实现了BeanFactory的抽象类</p><p>所以通过这个入口，我们发现BeanFactory是spring一切的基础，最顶级的抽象类<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191106155603.png" alt></p><ul><li>ListableBeanFactory：可列表化的bean工厂</li><li>HierarchicalBeanFactory：有层级关系的bean工厂（有父子继承关系的）</li><li>AutowireCapableBeanFactory：可自动注入的Bean工厂</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanFactory &#123;</span><br><span class="line">    //对 FactoryBean 的转义定义，因为如果使用 bean 的名字检索 FactoryBean 得到的对象是工厂生成的对象，</span><br><span class="line">    //如果需要得到工厂本身，需要转义</span><br><span class="line">    String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;</span><br><span class="line">    </span><br><span class="line">    //根据 bean 的名字，获取在 IOC 容器中得到 bean 实例</span><br><span class="line">    Object getBean(String name) throws BeansException;</span><br><span class="line">    </span><br><span class="line">    //根据 bean 的名字和 Class 类型来得到 bean 实例，增加了类型安全验证机制。</span><br><span class="line">    Object getBean(String name, Class requiredType) throws BeansException;</span><br><span class="line">    </span><br><span class="line">    //提供对 bean 的检索，看看是否在 IOC 容器有这个名字的 bean</span><br><span class="line">    boolean containsBean(String name);</span><br><span class="line">    </span><br><span class="line">    //根据 bean 名字得到 bean 实例，并同时判断这个 bean 是不是单例</span><br><span class="line">    boolean isSingleton(String name) throws NoSuchBeanDefinitionException;</span><br><span class="line">    </span><br><span class="line">    //得到 bean 实例的 Class 类型</span><br><span class="line">    Class getType(String name) throws NoSuchBeanDefinitionException;</span><br><span class="line">    </span><br><span class="line">    //得到 bean 的别名，如果根据别名检索，那么其原名也会被检索出来</span><br><span class="line">    String[] getAliases(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 BeanFactory 里只对 IOC 容器的基本行为作了定义，根本不关心你的 bean 是如何定义怎样加载的。<br>正如我们只关心工厂里得到什么的产品对象，至于工厂是怎么生产这些对象的，这个基本的接口不关心。</p><p>要知道工厂是如何产生对象的，我们需要看具体的 IOC 容器实现，Spring 提供了许多 IOC 容器的<br>实现。比如 XmlBeanFactory，ClasspathXmlApplicationContext 等。其中 XmlBeanFactory 就是针对最<br>基本的 IOC 容器的实现，这个 IOC 容器可以读取 XML 文件定义的 BeanDefinition（XML 文件中对 bean<br>的描述）,如果说 XmlBeanFactory 是容器中的低配屌丝，ApplicationContext 应该算容器中的高帅富</p><p>从 ApplicationContext 接口的实现，我们看出其特点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,</span><br><span class="line">		MessageSource, ApplicationEventPublisher, ResourcePatternResolver &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.支持信息源，可以实现国际化。（实现 MessageSource 接口）<br>2.访问资源。(实现 ResourcePatternResolver 接口)<br>3.支持应用事件。(实现 ApplicationEventPublisher 接口)</p><h2><a id="BeanDefinition_27"></a><a class="header-anchor" href="#beandefinition">¶</a>BeanDefinition</h2><p>这个主要是存储了bean定义的一些配置信息（其实就是讲xml中配置的信息，保存到BeanDefinition）</p><p>SpringIOC 容器管理了我们定义的各种 Bean 对象及其相互的关系，Bean 对象在 Spring 实现中是以<br>BeanDefinition 来描述的，其继承体系如下：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191106162927.png" alt><br>Bean 的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵<br>活性，以应对可能的变化。Bean 的解析主要就是对 Spring 配置文件的解析。这个解析过程主要通<br>过下图中的类完成：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191106163217.png" alt></p><h1><a id="IOC_38"></a>IOC容器的初始化</h1><p>IOC 容器的初始化包括 BeanDefinition 的 Resource 定位、载入和注册这三个基本的过程</p><ul><li>定位：就是找到定义的xml配置文件在哪里<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191106163655.png" alt></li><li>加载：通过xml解析工具解析xml文件</li><li>注册：将配置信息交给beanFactory，对xml中的bean进行创建生产<br>以ApplicationContext 为例，ApplicationContext 系列容器也许是我们最熟悉的，因为 web 项目中<br>使用的 XmlWebApplicationContext 就属于这个继承体系，还有 ClasspathXmlApplicationContext 等，<br>其继承体系如下图所示：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191106164041.png" alt><br>ApplicationContext 允许上下文嵌套，通过保持父上下文可以维持一个上下文体系。对于 bean 的查找<br>可以在这个上下文体系中发生，首先检查当前上下文，其次是父上下文，逐级向上，这样为不同的 Spring<br>应用提供了一个共享的 bean 定义环境。</li></ul><p>使用FileSystemXmlApplicationContext和使用ClassPathXmlApplicationContext的区别在于：</p><ul><li>FileSystemXmlApplicationContext在指定的文件系统路径下查找xml文件和本项目下的classPath<br>ApplicationContext context = new FileSystemXmlApplicationContext(“C:/bean.xml, classPath: bean.xml”);</li><li>ClassPathXmlApplicationContext是在所有的类路径（包含JAR文件） 下查找xml文件(classPath*)<br>ApplicationContext context = new ClassPathXmlApplicationContext(“bean.xml”);</li></ul><h2><a id="XmlBeanFactory_58"></a><a class="header-anchor" href="#xmlbeanfactory">¶</a>XmlBeanFactory</h2><p>低配BeanFactory的整个流程<br>先看下XmlBeanFactory的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class XmlBeanFactory extends DefaultListableBeanFactory&#123;</span><br><span class="line">    private final XmlBeanDefinitionReader reader;</span><br><span class="line">    public XmlBeanFactory(Resource resource)throws BeansException&#123;</span><br><span class="line">        this(resource, null);</span><br><span class="line">    &#125;</span><br><span class="line">    public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException&#123;</span><br><span class="line">        super(parentBeanFactory);</span><br><span class="line">        this.reader = new XmlBeanDefinitionReader(this);</span><br><span class="line">        this.reader.loadBeanDefinitions(resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还原一下调用过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//根据 Xml 配置文件创建 Resource 资源对象，该对象中包含了 BeanDefinition 的信息</span><br><span class="line">ClassPathResource resource =new ClassPathResource(&quot;application-context.xml&quot;);</span><br><span class="line"></span><br><span class="line">//创建 DefaultListableBeanFactory</span><br><span class="line">DefaultListableBeanFactory factory =new DefaultListableBeanFactory();</span><br><span class="line"></span><br><span class="line">//创建 XmlBeanDefinitionReader 读取器，用于载入 BeanDefinition。之所以需要 BeanFactory 作为参数，是因为会将读取的信息配置回调给 factory</span><br><span class="line">XmlBeanDefinitionReader reader =new XmlBeanDefinitionReader(factory);</span><br><span class="line"></span><br><span class="line">//XmlBeanDefinitionReader 执行载入 BeanDefinition 的方法，最后会完成 Bean 的载入和注册。完成后 Bean 就成功</span><br><span class="line">的放置到 IOC 容器当中，以后我们就可以从中取得 Bean 来使用</span><br><span class="line">reader.loadBeanDefinitions(resource);</span><br></pre></td></tr></table></figure><p>然后我们看下loadBeanDefinitions方法<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191106165946.png" alt><br>其实就是对xml文件的解析，并把解析出来的bean 定义配置回传给factory，让其进行new对象</p><h2><a id="FileSystemXmlApplicationContext_68"></a><a class="header-anchor" href="#filesystemxmlapplicationcontext">¶</a>FileSystemXmlApplicationContext</h2><p>最主要的构造方法，其余构造方法都是调用这个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Create a new FileSystemXmlApplicationContext, loading the definitions</span><br><span class="line">* from the given XML files and automatically refreshing the context.</span><br><span class="line">* @param configLocations array of file paths</span><br><span class="line">* @throws BeansException if context creation failed</span><br><span class="line">*/</span><br><span class="line">public FileSystemXmlApplicationContext(String... configLocations) throws BeansException &#123;</span><br><span class="line">    this(configLocations, true, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public FileSystemXmlApplicationContext(String[] configLocations, boolean refresh,</span><br><span class="line">ApplicationContext parent) throws BeansException &#123;</span><br><span class="line">    // 为了动态的确定用什么加载器去加载配置文件</span><br><span class="line">    super(parent);</span><br><span class="line">    // 告诉读取器reader 配置文件在哪里：定位配置文件，为了加载配置文件</span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    // 刷新</span><br><span class="line">    if (refresh) &#123;</span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为spring的context是可以自定义的，所以如果不设置，则使用默认的资源加载器，如果配置则使用用户自定义的ApplicationContext</p><p>设置资源加载器和资源定位<br>通过分析 FileSystemXmlApplicationContext 的源代码可以知道，在创建<br>FileSystemXmlApplicationContext 容器时，构造方法做以下两项重要工作：<br>1.调用父类容器的构造方法(super(parent)方法)为容器设置好 Bean 资源加载器。<br>2.再调用父类 AbstractRefreshableConfigApplicationContext 的<br>setConfigLocations(configLocations)方法设置 Bean 定义资源文件的定位路径。<br>通过追踪 FileSystemXmlApplicationContext 的继承体系，发现其父类的父类<br>AbstractApplicationContext 中初始化 IOC 容器所做的主要源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext, DisposableBean &#123;</span><br><span class="line">    //静态初始化块，在整个容器创建过程中只执行一次</span><br><span class="line">    static &#123;</span><br><span class="line">        //为了避免应用程序在 Weblogic8.1 关闭时出现类加载异常加载问题，加载 IoC 容器关闭事件(ContextClosedEvent)类</span><br><span class="line">        ContextClosedEvent.class.getName();</span><br><span class="line">    &#125;</span><br><span class="line">    public AbstractApplicationContext() &#123;</span><br><span class="line">        // 解析资源文件，动态的匹配</span><br><span class="line">        this.resourcePatternResolver = getResourcePatternResolver();</span><br><span class="line">    &#125;</span><br><span class="line">    //FileSystemXmlApplicationContext 调用父类构造方法调用的就是该方法</span><br><span class="line">    public AbstractApplicationContext(ApplicationContext parent) &#123;</span><br><span class="line">        this();</span><br><span class="line">        setParent(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    //获取一个 Spring Source 的加载器用于读入 Spring Bean 定义资源文件</span><br><span class="line">    protected ResourcePatternResolver getResourcePatternResolver() &#123;</span><br><span class="line">        //AbstractApplicationContext 继承 DefaultResourceLoader，因此也是一个资源加载器</span><br><span class="line">        //Spring 资源加载器，其 getResource(String location)方法用于载入资源</span><br><span class="line">        return new PathMatchingResourcePatternResolver(this);</span><br><span class="line">    &#125;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractApplicationContext构造方法中调用PathMatchingResourcePatternResolver的构造方法创建<br>Spring 资源加载器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public PathMatchingResourcePatternResolver(ResourceLoader resourceLoader) &#123;</span><br><span class="line">    Assert.notNull(resourceLoader, &quot;ResourceLoader must not be null&quot;);</span><br><span class="line">    //设置 Spring 的资源加载器</span><br><span class="line">    this.resourceLoader = resourceLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在设置容器的资源加载器之后，接下来 FileSystemXmlApplicationContet 执行 setConfigLocations 方<br>法通过调用其父类 AbstractRefreshableConfigApplicationContext 的方法进行对 Bean 定义资源文件<br>的定位，该方法的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//处理单个资源文件路径为一个字符串的情况</span><br><span class="line">public void setConfigLocation(String location) &#123;</span><br><span class="line">    //String CONFIG_LOCATION_DELIMITERS = &quot;,; /t/n&quot;;</span><br><span class="line">    //即多个资源文件路径之间用” ,; /t/n”分隔，解析成数组形式</span><br><span class="line">    setConfigLocations(StringUtils.tokenizeToStringArray(location, CONFIG_LOCATION_DELIMITERS));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//解析 Bean 定义资源文件的路径，处理多个资源文件字符串数组</span><br><span class="line">public void setConfigLocations(String[] locations) &#123;</span><br><span class="line">    if (locations != null) &#123;</span><br><span class="line">        Assert.noNullElements(locations, &quot;Config locations must not be null&quot;);</span><br><span class="line">        this.configLocations = new String[locations.length];</span><br><span class="line">        for (int i = 0; i &lt; locations.length; i++) &#123;</span><br><span class="line">            // resolvePath 将字符串解析为路径的方法</span><br><span class="line">            this.configLocations[i] = resolvePath(locations[i]).trim();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.configLocations = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这两个方法的源码我们可以看出，我们既可以使用一个字符串来配置多个 Spring Bean 定义资源<br>文件，也可以使用字符串数组，即下面两种方式都是可以的：<br>1.ClasspathResource res = new ClasspathResource(“a.xml,b.xml,……”);<br>多个资源文件路径之间可以是用” ,; /t/n”等分隔。<br>2.ClasspathResource res = new ClasspathResource(newString[]{“a.xml”,”b.xml”,……});<br>Spring IOC 容器在初始化时将配置的 Bean 定义资源文件定位为 Spring 封装的 Resource。<br>3.AbstractApplicationContext 的 refresh 函数载入 Bean 定义过程：<br>Spring IOC 容器对 Bean 定义资源的载入是从 refresh()函数开始的，refresh()是一个模板方法，<br>refresh()方法的作用是：在创建 IOC 容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，<br>以保证在 refresh 之后使用的是新建立起来的 IOC 容器。refresh 的作用类似于对 IOC 容器的重启，在<br>新建立好的容器中对容器进行初始化，对 Bean 定义资源进行载入</p><h3><a id="refresh_102"></a><a class="header-anchor" href="#refresh">¶</a>refresh()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public FileSystemXmlApplicationContext(String[] configLocations, boolean refresh,</span><br><span class="line">ApplicationContext parent) throws BeansException &#123;</span><br><span class="line">    // 为了动态的确定用什么加载器去加载配置文件</span><br><span class="line">    super(parent);</span><br><span class="line">    // 告诉读取器reader 配置文件在哪里：定位配置文件，为了加载配置文件</span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    // 刷新</span><br><span class="line">    if (refresh) &#123;</span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FileSystemXmlApplicationContext 通过调用其父类 AbstractApplicationContext 的 refresh()函数启<br>动整个 IoC 容器对 Bean 定义的载入过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">        synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">            //调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识</span><br><span class="line">            prepareRefresh();</span><br><span class="line">            //告诉子类启动 refreshBeanFactory()方法，Bean 定义资源文件的载入从子类的 refreshBeanFactory()方法启动</span><br><span class="line">            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">            //为 BeanFactory 配置容器特性，例如类加载器、事件处理器等</span><br><span class="line">            prepareBeanFactory(beanFactory);</span><br><span class="line">            try &#123;</span><br><span class="line">                //以下三个方法其实都是加载一些所谓的监听器（ApplicationAware/SessionAware等等）</span><br><span class="line">            </span><br><span class="line">                //为容器的某些子类指定特殊的 BeanPost 事件处理器</span><br><span class="line">                //比如监听spring是否启动，ApplicationAware中的setApplicationContext方法就可以进行一些容器初始化事件操作</span><br><span class="line">                postProcessBeanFactory(beanFactory);</span><br><span class="line">                //调用所有注册的 BeanFactoryPostProcessor 的 Bean</span><br><span class="line">                invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">                //为 BeanFactory 注册 BeanPost 事件处理器.</span><br><span class="line">                //BeanPostProcessor 是 Bean 后置处理器，用于监听容器触发的事件</span><br><span class="line">                registerBeanPostProcessors(beanFactory);</span><br><span class="line">                </span><br><span class="line">                //初始化信息源，和国际化相关.</span><br><span class="line">                initMessageSource();</span><br><span class="line">                </span><br><span class="line">                //初始化容器事件传播器.</span><br><span class="line">                initApplicationEventMulticaster();</span><br><span class="line">                //调用子类的某些特殊 Bean 初始化方法</span><br><span class="line">                onRefresh();</span><br><span class="line">                //为事件传播器注册事件监听器.</span><br><span class="line">                registerListeners();</span><br><span class="line">                //初始化所有剩余的单例 Bean.</span><br><span class="line">                finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">                //初始化容器的生命周期事件处理器，并发布容器的生命周期事件</span><br><span class="line">                finishRefresh();</span><br><span class="line">            &#125; catch (BeansException ex) &#123;</span><br><span class="line">                //销毁以创建的单态 Bean</span><br><span class="line">                destroyBeans();</span><br><span class="line">                //取消 refresh 操作，重置容器的同步标识.</span><br><span class="line">                cancelRefresh(ex);</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>refresh()方法主要为 IOC 容器 Bean 的生命周期管理提供条件，Spring IOC 容器载入 Bean 定义资源文<br>件从其子类容器的 refreshBeanFactory()方法启动，所以整个 refresh()中<br>“ConfigurableListableBeanFactory beanFactory =obtainFreshBeanFactory();”这句以后代码的<br>都是注册容器的信息源和生命周期事件，载入过程就是从这句代码启动。</p><p>refresh()方法的作用是：在创建 IOC 容器前，如果已经有容器存在，则需要把已有的容器销毁和关<br>闭，以保证在 refresh 之后使用的是新建立起来的 IOC 容器。refresh 的作用类似于对 IOC 容器的重启，<br>在新建立好的容器中对容器进行初始化，对 Bean 定义资源进行载入</p><p>AbstractApplicationContext的obtainFreshBeanFactory()方法调用子类容器的refreshBeanFactory()<br>方法，启动容器载入 Bean 定义资源文件的过程，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;</span><br><span class="line">    //这里使用了委派设计模式，父类定义了抽象的 refreshBeanFactory()方法，具体实现调用子类容器的refreshBeanFactory()方法</span><br><span class="line">    refreshBeanFactory();</span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">    if (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    return beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractApplicationContext 子类的 refreshBeanFactory()方法：<br>AbstractApplicationContext 类中只抽象定义了 refreshBeanFactory()方法，容器真正调用的是<br>其子类AbstractRefreshableApplicationContext实现的refreshBeanFactory()方法，方法的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected final void refreshBeanFactory() throws BeansException &#123;</span><br><span class="line">    //如果已经有容器，销毁容器中的 bean，关闭容器</span><br><span class="line">    if (hasBeanFactory()) &#123;</span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        //创建 IOC 容器</span><br><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        //对 IOC 容器进行定制化，如设置启动参数，开启注解的自动装配等</span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line">        //调用载入 Bean 定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的 loadBeanDefinitions方法，具体的实现调用子类容器</span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        synchronized (this.beanFactoryMonitor) &#123;</span><br><span class="line">            this.beanFactory = beanFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;catch (IOException ex) &#123;</span><br><span class="line">        throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，先判断 BeanFactory 是否存在，如果存在则先销毁 beans 并关闭 beanFactory，接着创<br>建 DefaultListableBeanFactory，并调用 loadBeanDefinitions(beanFactory)装载 bean 定义。</p><p>AbstractRefreshableApplicationContext 子类的 loadBeanDefinitions 方法：<br>AbstractRefreshableApplicationContext 中只定义了抽象的 loadBeanDefinitions 方法，容器真正调<br>用的是其子类 AbstractXmlApplicationContext 对该方法的实现，AbstractXmlApplicationContext 的<br>主要源码如下：<br>loadBeanDefinitions 方法同样是抽象方法，是由其子类实现的，也即在<br>AbstractXmlApplicationContext 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractXmlApplicationContext extends AbstractRefreshableConfigApplicationContext &#123;</span><br><span class="line">    </span><br><span class="line">    ……</span><br><span class="line"></span><br><span class="line">    //实现父类抽象的载入 Bean 定义方法</span><br><span class="line">    @Override</span><br><span class="line">    protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException,</span><br><span class="line">            IOException &#123;</span><br><span class="line">        //创建 XmlBeanDefinitionReader，即创建 Bean 读取器，并通过回调设置到容器中去，容 器使用该读取器读取 Bean 定义资源</span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">        //为 Bean 读取器设置 Spring 资源加载器，AbstractXmlApplicationContext 的祖先父类 AbstractApplicationContext 继承 DefaultResourceLoader，因此，容器本身也是一个资源加载器</span><br><span class="line">        beanDefinitionReader.setEnvironment(this.getEnvironment());</span><br><span class="line">        beanDefinitionReader.setResourceLoader(this);</span><br><span class="line">        //为 Bean 读取器设置 SAX xml 解析器</span><br><span class="line">        beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</span><br><span class="line">        //当 Bean 读取器读取 Bean 定义的 Xml 资源文件时，启用 Xml 的校验机制</span><br><span class="line">        initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">        //Bean 读取器真正实现加载的方法</span><br><span class="line">        loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //Xml Bean 读取器加载 Bean 定义资源</span><br><span class="line">    protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException,IOException &#123;</span><br><span class="line">        //获取 Bean 定义资源的定位</span><br><span class="line">        Resource[] configResources = getConfigResources();</span><br><span class="line">        if (configResources != null) &#123;</span><br><span class="line">            //Xml Bean 读取器调用其父类 AbstractBeanDefinitionReader 读取定位的 Bean 定义资源</span><br><span class="line">            reader.loadBeanDefinitions(configResources);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子类中获取的 Bean 定义资源定位为空，则获取 FileSystemXmlApplicationContext 构造方法中setConfigLocations 方法设置的资源</span><br><span class="line">        String[] configLocations = getConfigLocations();</span><br><span class="line">        if (configLocations != null) &#123;</span><br><span class="line">            //Xml Bean 读取器调用其父类 AbstractBeanDefinitionReader 读取定位的 Bean 定义资源</span><br><span class="line">            reader.loadBeanDefinitions(configLocations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //这里又使用了一个委托模式，调用子类的获取 Bean 定义资源定位的方法</span><br><span class="line">    //该方法在 ClassPathXmlApplicationContext 中进行实现，对于我们</span><br><span class="line">    //举例分析源码的 FileSystemXmlApplicationContext 没有使用该方法</span><br><span class="line">    protected Resource[] getConfigResources() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125; </span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Xml Bean 读取器(XmlBeanDefinitionReader)调用其父类 AbstractBeanDefinitionReader<br>的 reader.loadBeanDefinitions 方法读取 Bean 定义资源。</p><p>由于我们使用 FileSystemXmlApplicationContext 作为例子分析，因此 getConfigResources 的返回值<br>为 null，因此程序执行 reader.loadBeanDefinitions(configLocations)分支。</p><p>AbstractBeanDefinitionReader 读取 Bean 定义资源：<br>AbstractBeanDefinitionReader 的 loadBeanDefinitions 方法源码如下<br>可以到 org.springframework.beans.factory.support 看一下 BeanDefinitionReader 的结构<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191106202131.png" alt></p><p>在其抽象父类 AbstractBeanDefinitionReader 中定义了载入过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">//重载方法，调用下面的 loadBeanDefinitions(String, Set&lt;Resource&gt;);方法</span><br><span class="line">public int loadBeanDefinitions(String location) throws BeanDefinitionStoreException &#123;</span><br><span class="line">    return loadBeanDefinitions(location, null);</span><br><span class="line">&#125;</span><br><span class="line">public int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException &#123;</span><br><span class="line">    //获取在 IoC 容器初始化过程中设置的资源加载器</span><br><span class="line">    ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">    if (resourceLoader == null) &#123;</span><br><span class="line">        throw new BeanDefinitionStoreException(</span><br><span class="line">                &quot;Cannot import bean definitions from location [&quot; + location + &quot;]: no ResourceLoader</span><br><span class="line">                available&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (resourceLoader instanceof ResourcePatternResolver) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //将指定位置的 Bean 定义资源文件解析为 Spring IOC 容器封装的资源</span><br><span class="line">            //加载多个指定位置的 Bean 定义资源文件</span><br><span class="line">            // ResourcePatternResolver就是多个文件解析器，就是下面说到的多个文件可以使用，；等符号进行分割</span><br><span class="line">            Resource[] resources = ((ResourcePatternResolver)resourceLoader).getResources(location);</span><br><span class="line">            //委派调用其子类 XmlBeanDefinitionReader 的方法，实现加载功能</span><br><span class="line">            int loadCount = loadBeanDefinitions(resources);</span><br><span class="line">            if (actualResources != null) &#123;</span><br><span class="line">                for (Resource resource : resources) &#123;</span><br><span class="line">                    actualResources.add(resource);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location pattern [&quot; +</span><br><span class="line">                        location + &quot;]&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            return loadCount;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (IOException ex) &#123;</span><br><span class="line">            throw new BeanDefinitionStoreException(&quot;Could not resolve bean definition resource pattern [&quot; + location + &quot;]&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //将指定位置的 Bean 定义资源文件解析为 Spring IOC 容器封装的资源</span><br><span class="line">        //加载单个指定位置的 Bean 定义资源文件</span><br><span class="line">        // AbstractXmlApplicationContext line 89 设置了默认的资源加载器</span><br><span class="line">        Resource resource = resourceLoader.getResource(location);</span><br><span class="line">        //委派调用其子类 XmlBeanDefinitionReader 的方法，实现加载功能</span><br><span class="line">        int loadCount = loadBeanDefinitions(resource);</span><br><span class="line">        if (actualResources != null) &#123;</span><br><span class="line">            actualResources.add(resource);</span><br><span class="line">        &#125;</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions from location [&quot; + location +</span><br><span class="line">                    &quot;]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return loadCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//重载方法，调用 loadBeanDefinitions(String);</span><br><span class="line">public int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException &#123;</span><br><span class="line">    Assert.notNull(locations, &quot;Location array must not be null&quot;);</span><br><span class="line">    int counter = 0;</span><br><span class="line">    for (String location : locations) &#123;</span><br><span class="line">        counter += loadBeanDefinitions(location);</span><br><span class="line">    &#125;</span><br><span class="line">    return counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadBeanDefinitions(Resource…resources)方法和上面分析的 3 个方法类似，同样也是调用<br>XmlBeanDefinitionReader 的 loadBeanDefinitions 方法。</p><p>从对 AbstractBeanDefinitionReader 的 loadBeanDefinitions 方法源码分析可以看出该方法做了以下<br>两件事：</p><ul><li>调用资源加载器的获取资源方法 resourceLoader.getResource(location)，获取到要加载的资源。</li><li>真正执行加载功能是其子类 XmlBeanDefinitionReader 的 loadBeanDefinitions 方法。<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191106202401.png" alt><br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191106202419.png" alt></li></ul><p>看到第 8、16 行，结合上面的 ResourceLoader 与 ApplicationContext 的继承系图，可以知道此时调用<br>的是 DefaultResourceLoader 中的 getSource()方法定位 Resource，因为<br>FileSystemXmlApplicationContext 本身就是 DefaultResourceLoader 的实现类，所以此时又回到了<br>FileSystemXmlApplicationContext 中来。</p><p>资源加载器获取要读入的资源：<br>XmlBeanDefinitionReader 通过调用其父类 DefaultResourceLoader 的 getResource 方法获取要加载的<br>资源，其源码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//获取 Resource 的具体实现方法</span><br><span class="line">public Resource getResource(String location) &#123;</span><br><span class="line">    Assert.notNull(location, &quot;Location must not be null&quot;);</span><br><span class="line">    //如果是类路径的方式，那需要使用 ClassPathResource 来得到 bean 文件的资源对象</span><br><span class="line">    if (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line">        return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()),getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 如果是 URL 方式，使用 UrlResource 作为 bean 文件的资源对象</span><br><span class="line">        URL url = new URL(location);</span><br><span class="line">        return new UrlResource(url);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (MalformedURLException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果既不是 classpath 标识，又不是 URL 标识的 Resource 定位，则调用</span><br><span class="line">    //容器本身的 getResourceByPath 方法获取 Resource</span><br><span class="line">    return getResourceByPath(location);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FileSystemXmlApplicationContext 容器提供了 getResourceByPath 方法的实现，就是为了处理既不是<br>classpath 标识，又不是 URL 标识的 Resource 定位这种情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected Resource getResourceByPath(String path) &#123;</span><br><span class="line">    if (path != null &amp;&amp; path.startsWith(&quot;/&quot;)) &#123;</span><br><span class="line">        path = path.substring(1);</span><br><span class="line">    &#125;</span><br><span class="line">    //这里使用文件系统资源对象来定义 bean 文件</span><br><span class="line">    return new FileSystemResource(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样代码就回到了 FileSystemXmlApplicationContext 中来，他提供了 FileSystemResource 来完<br>成从文件系统得到配置文件的资源定义。</p><p>这样，就可以从文件系统路径上对 IOC 配置文件进行加载 - 当然我们可以按照这个逻辑从任何地方<br>加载，在 Spring 中我们看到它提供 的各种资源抽象，比如<br>ClassPathResource, URLResource,FileSystemResource 等来供我们使用。上面我们看到的是定位<br>Resource 的一个过程，而这只是加载过程的一部分.</p><h3><a id="XmlBeanDefinitionReader__Bean__177"></a><a class="header-anchor" href="#xmlbeandefinitionreader-加载-bean-定义资源">¶</a>XmlBeanDefinitionReader 加载 Bean 定义资源</h3><p>Bean 定义的 Resource 得到了</p><p>继续回到 XmlBeanDefinitionReader 的 loadBeanDefinitions(Resource …)方法看到代表 bean 文<br>件的资源定义以后的载入过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//XmlBeanDefinitionReader 加载资源的入口方法</span><br><span class="line">    public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">        //将读入的 XML 资源进行特殊编码处理</span><br><span class="line">        return loadBeanDefinitions(new EncodedResource(resource));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //这里是载入 XML 形式 Bean 定义资源文件方法</span><br><span class="line">    public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">        .......</span><br><span class="line">        // 主要去除配置文件的循环依赖</span><br><span class="line">		Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">		if (currentResources == null) &#123;</span><br><span class="line">			currentResources = new HashSet&lt;EncodedResource&gt;(4);</span><br><span class="line">			this.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">		&#125;</span><br><span class="line">		if (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">			throw new BeanDefinitionStoreException(</span><br><span class="line">					&quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            //将资源文件转为 InputStream 的 IO 流</span><br><span class="line">            InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">            try &#123;</span><br><span class="line">                //从 InputStream 中得到 XML 的解析源</span><br><span class="line">                InputSource inputSource = new InputSource(inputStream);</span><br><span class="line">                if (encodedResource.getEncoding() != null) &#123;</span><br><span class="line">                    inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">                &#125;</span><br><span class="line">                //这里是具体的读取过程</span><br><span class="line">                return doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                //关闭从 Resource 中得到的 IO 流</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .........</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //从特定 XML 文件中实际载入 Bean 定义资源的方法</span><br><span class="line">    protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int validationMode = getValidationModeForResource(resource);</span><br><span class="line">            //将 XML 文件转换为 DOM 对象，解析过程由 documentLoader 实现</span><br><span class="line">            Document doc = this.documentLoader.loadDocument(</span><br><span class="line">                    inputSource, this.entityResolver, this.errorHandler, validationMode,</span><br><span class="line">                    this.namespaceAware);</span><br><span class="line">            //这里是启动对 Bean 定义解析的详细过程，该解析过程会用到 Spring 的 Bean 配置规则</span><br><span class="line">            return registerBeanDefinitions(doc, resource);</span><br><span class="line">        &#125;</span><br><span class="line">.......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过源码分析，载入 Bean 定义资源文件的最后一步是将 Bean 定义资源转换为 Document 对象，该过程<br>由 documentLoader 实现</p><p>DocumentLoader 将 Bean 定义资源转换为 Document 对象：<br>DocumentLoader 将 Bean 定义资源转换成 Document 对象的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//使用标准的 JAXP 将载入的 Bean 定义资源转换成 document 对象</span><br><span class="line">    public Document loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception &#123;</span><br><span class="line">        //创建文件解析器工厂</span><br><span class="line">        DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode,</span><br><span class="line">                namespaceAware);</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(&quot;Using JAXP provider [&quot; + factory.getClass().getName() + &quot;]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //创建文档解析器</span><br><span class="line">        DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line">        //解析 Spring 的 Bean 定义资源</span><br><span class="line">        return builder.parse(inputSource);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected DocumentBuilderFactory createDocumentBuilderFactory(int validationMode, boolean namespaceAware) throws ParserConfigurationException &#123;</span><br><span class="line">        //创建文档解析工厂</span><br><span class="line">        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">        factory.setNamespaceAware(namespaceAware);</span><br><span class="line">        //设置解析 XML 的校验</span><br><span class="line">        if (validationMode != XmlValidationModeDetector.VALIDATION_NONE) &#123;</span><br><span class="line">            factory.setValidating(true);</span><br><span class="line">            if (validationMode == XmlValidationModeDetector.VALIDATION_XSD) &#123;</span><br><span class="line">                factory.setNamespaceAware(true);</span><br><span class="line">                try &#123;</span><br><span class="line">                    factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);</span><br><span class="line">                &#125; catch (IllegalArgumentException ex) &#123;</span><br><span class="line">                    ParserConfigurationException pcex = new ParserConfigurationException(</span><br><span class="line">                            &quot;Unable to validate using XSD: Your JAXP provider [&quot; + factory +</span><br><span class="line">                                    &quot;] does not support XML Schema. Are you running on Java 1.with Apache Crimson?</span><br><span class="line">                            &quot; +</span><br><span class="line">                            &quot;Upgrade to Apache Xerces (or Java 1.5) for full XSD support.&quot;);</span><br><span class="line">                    pcex.initCause(ex);</span><br><span class="line">                    throw pcex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该解析过程调用 JavaEE 标准的 JAXP 标准进行处理。<br>至此 Spring IOC 容器根据定位的 Bean 定义资源文件，将其加载读入并转换成为 Document 对象过程完成。<br>接下来我们要继续分析 Spring IOC 容器将载入的 Bean 定义资源文件转换为 Document 对象之后，是如<br>何将其解析为 Spring IOC 管理的 Bean 对象并将其注册到容器中的。</p><h3><a id="XmlBeanDefinitionReader__Bean__195"></a><a class="header-anchor" href="#xmlbeandefinitionreader-解析载入的-bean-定义资源文件">¶</a>XmlBeanDefinitionReader 解析载入的 Bean 定义资源文件</h3><p>XmlBeanDefinitionReader类中的doLoadBeanDefinitions方法是从特定XML 文件中实际载入Bean 定<br>义资源的方法，该方法在载入 Bean 定义资源之后将其转换为 Document 对象，接下来调用<br>registerBeanDefinitions 启动 Spring IOC 容器对 Bean 定义的解析过程，registerBeanDefinitions<br>方法源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//按照 Spring 的 Bean 语义要求将 Bean 定义资源解析并转换为容器内部数据结构</span><br><span class="line">public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">    //得到 BeanDefinitionDocumentReader 来对 xml 格式的 BeanDefinition 解析</span><br><span class="line">    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">    //获得容器中注册的 Bean 数量</span><br><span class="line">    int countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">    //解析过程入口，这里使用了委派模式，BeanDefinitionDocumentReader 只是个接口，</span><br><span class="line">    //具体的解析实现过程有实现类 DefaultBeanDefinitionDocumentReader 完成</span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">    //统计解析的 Bean 数量</span><br><span class="line">    return getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line">//创建 BeanDefinitionDocumentReader 对象，解析 Document 对象</span><br><span class="line">protected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() &#123;</span><br><span class="line">    return BeanDefinitionDocumentReader.class.cast(BeanUtils.instantiateClass(this.documentReaderClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bean 定义资源的载入解析分为以下两个过程：</p><ul><li>首先，通过调用 XML 解析器将 Bean 定义资源文件转换得到 Document 对象，但是这些 Document 对象并没有按照 Spring 的 Bean 规则进行解析。这一步是载入的过程</li><li>在完成通用的 XML 解析之后，按照 Spring 的 Bean 规则对 Document 对象进行解析。</li></ul><p>按照 Spring 的 Bean 规则对 Document 对象解析的过程是在接口 BeanDefinitionDocumentReader 的实现<br>类 DefaultBeanDefinitionDocumentReader 中实现的。</p><h3><a id="DefaultBeanDefinitionDocumentReader__Bean__Document__208"></a><a class="header-anchor" href="#defaultbeandefinitiondocumentreader-对-bean-定义的-document-对象解析">¶</a>DefaultBeanDefinitionDocumentReader 对 Bean 定义的 Document 对象解析</h3><p>BeanDefinitionDocumentReader 接口通过 registerBeanDefinitions 方法调用其实现类<br>DefaultBeanDefinitionDocumentReader 对 Document 对象进行解析，解析的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">//根据 Spring DTD 对 Bean 的定义规则解析 Bean 定义 Document 对象</span><br><span class="line">    public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123;</span><br><span class="line">        //获得 XML 描述符</span><br><span class="line">        this.readerContext = readerContext;</span><br><span class="line">        logger.debug(&quot;Loading bean definitions&quot;);</span><br><span class="line">        //获得 Document 的根元素</span><br><span class="line">        Element root = doc.getDocumentElement();</span><br><span class="line">        //具体的解析过程由 BeanDefinitionParserDelegate 实现，</span><br><span class="line">        //BeanDefinitionParserDelegate 中定义了 Spring Bean 定义 XML 文件的各种元素</span><br><span class="line">        BeanDefinitionParserDelegate delegate = createHelper(readerContext, root);</span><br><span class="line">        //在解析 Bean 定义之前，进行自定义的解析，增强解析过程的可扩展性</span><br><span class="line">        preProcessXml(root);</span><br><span class="line">        //从 Document 的根元素开始进行 Bean 定义的 Document 对象</span><br><span class="line">        parseBeanDefinitions(root, delegate);</span><br><span class="line">        //在解析 Bean 定义之后，进行自定义的解析，增加解析过程的可扩展性</span><br><span class="line">        postProcessXml(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //创建 BeanDefinitionParserDelegate，用于完成真正的解析过程</span><br><span class="line">    protected BeanDefinitionParserDelegate createHelper(XmlReaderContext readerContext, Element root) &#123;</span><br><span class="line">        BeanDefinitionParserDelegate delegate = new BeanDefinitionParserDelegate(readerContext);</span><br><span class="line">        //BeanDefinitionParserDelegate 初始化 Document 根元素</span><br><span class="line">        delegate.initDefaults(root);</span><br><span class="line">        return delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用 Spring 的 Bean 规则从 Document 的根元素开始进行 Bean 定义的 Document 对象</span><br><span class="line">    protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">        //Bean 定义的 Document 对象使用了 Spring 默认的 XML 命名空间</span><br><span class="line">        if (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">            //获取 Bean 定义的 Document 对象根元素的所有子节点</span><br><span class="line">            NodeList nl = root.getChildNodes();</span><br><span class="line">            for (int i = 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">                Node node = nl.item(i);</span><br><span class="line">                //获得 Document 节点是 XML 元素节点</span><br><span class="line">                if (node instanceof Element) &#123;</span><br><span class="line">                    Element ele = (Element) node;</span><br><span class="line">                    //Bean 定义的 Document 的元素节点使用的是 Spring 默认的 XML 命名空间</span><br><span class="line">                    if (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                        //使用 Spring 的 Bean 规则解析元素节点</span><br><span class="line">                        parseDefaultElement(ele, delegate);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        //没有使用 Spring 默认的 XML 命名空间，则使用用户自定义的解析规则解析元素节点</span><br><span class="line">                        delegate.parseCustomElement(ele);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //Document 的根节点没有使用 Spring 默认的命名空间，则使用用户自定义的解析规则解析 Document 根节点</span><br><span class="line">            delegate.parseCustomElement(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用 Spring 的 Bean 规则解析 Document 元素节点</span><br><span class="line">    private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">        //如果元素节点是&lt;Import&gt;导入元素，进行导入解析</span><br><span class="line">        if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">            importBeanDefinitionResource(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果元素节点是&lt;Alias&gt;别名元素，进行别名解析</span><br><span class="line">        else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">            processAliasRegistration(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        //元素节点既不是导入元素，也不是别名元素，即普通的&lt;Bean&gt;元素，</span><br><span class="line">        //按照 Spring 的 Bean 规则解析元素</span><br><span class="line">        else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">            processBeanDefinition(ele, delegate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //解析&lt;Import&gt;导入元素，从给定的导入路径加载 Bean 定义资源到 Spring IoC 容器中</span><br><span class="line">    protected void importBeanDefinitionResource(Element ele) &#123;</span><br><span class="line">        //获取给定的导入元素的 location 属性</span><br><span class="line">        String location = ele.getAttribute(RESOURCE_ATTRIBUTE);</span><br><span class="line">        //如果导入元素的 location 属性值为空，则没有导入任何资源，直接返回</span><br><span class="line">        if (!StringUtils.hasText(location)) &#123;</span><br><span class="line">            getReaderContext().error(&quot;Resource location must not be empty&quot;, ele);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //使用系统变量值解析 location 属性值</span><br><span class="line">        location = SystemPropertyUtils.resolvePlaceholders(location);</span><br><span class="line">        Set&lt;Resource&gt; actualResources = new LinkedHashSet&lt;Resource&gt;(4);</span><br><span class="line">        //标识给定的导入元素的 location 是否是绝对路径</span><br><span class="line">        boolean absoluteLocation = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            absoluteLocation = ResourcePatternUtils.isUrl(location) ||</span><br><span class="line">                    ResourceUtils.toURI(location).isAbsolute();</span><br><span class="line">        &#125; catch (URISyntaxException ex) &#123;</span><br><span class="line">            //给定的导入元素的 location 不是绝对路径</span><br><span class="line">        &#125;</span><br><span class="line">        //给定的导入元素的 location 是绝对路径</span><br><span class="line">        if (absoluteLocation) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //使用资源读入器加载给定路径的 Bean 定义资源</span><br><span class="line">                int importCount = getReaderContext().getReader().loadBeanDefinitions(location,</span><br><span class="line">                        actualResources);</span><br><span class="line">                if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(&quot;Imported &quot; + importCount + &quot; bean definitions from URL location [&quot; +</span><br><span class="line">                            location + &quot;]&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">                getReaderContext().error(</span><br><span class="line">                        &quot;Failed to import bean definitions from URL location [&quot; + location + &quot;]&quot;, ele, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //给定的导入元素的 location 是相对路径</span><br><span class="line">            try &#123;</span><br><span class="line">                int importCount;</span><br><span class="line">                //将给定导入元素的 location 封装为相对路径资源</span><br><span class="line">                Resource relativeResource = getReaderContext().getResource().createRelative(location);</span><br><span class="line">                //封装的相对路径资源存在</span><br><span class="line">                if (relativeResource.exists()) &#123;</span><br><span class="line">                    //使用资源读入器加载 Bean 定义资源</span><br><span class="line">                    importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);</span><br><span class="line">                    actualResources.add(relativeResource);</span><br><span class="line">                &#125;</span><br><span class="line">                //封装的相对路径资源不存在</span><br><span class="line">                else &#123;</span><br><span class="line">                    //获取 Spring IOC 容器资源读入器的基本路径</span><br><span class="line">                    String baseLocation = getReaderContext().getResource().getURL().toString();</span><br><span class="line">                    //根据 Spring IoC 容器资源读入器的基本路径加载给定导入路径的资源</span><br><span class="line">                    importCount = getReaderContext().getReader().loadBeanDefinitions(</span><br><span class="line">                            StringUtils.applyRelativePath(baseLocation, location), actualResources);</span><br><span class="line">                &#125;</span><br><span class="line">                if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(&quot;Imported &quot; + importCount + &quot; bean definitions from relative location [&quot;</span><br><span class="line">                            + location + &quot;]&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException ex) &#123;</span><br><span class="line">                getReaderContext().error(&quot;Failed to resolve current resource location&quot;, ele, ex);</span><br><span class="line">            &#125; catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">                getReaderContext().error(&quot;Failed to import bean definitions from relative location [&quot; +</span><br><span class="line">                                location + &quot;]&quot;,</span><br><span class="line">                        ele, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Resource[] actResArray = actualResources.toArray(new Resource[actualResources.size()]);</span><br><span class="line">        //在解析完&lt;Import&gt;元素之后，发送容器导入其他资源处理完成事件</span><br><span class="line">        getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //解析&lt;Alias&gt;别名元素，为 Bean 向 Spring IoC 容器注册别名</span><br><span class="line">    protected void processAliasRegistration(Element ele) &#123;</span><br><span class="line">        //获取&lt;Alias&gt;别名元素中 name 的属性值</span><br><span class="line">        String name = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">        //获取&lt;Alias&gt;别名元素中 alias 的属性值</span><br><span class="line">        String alias = ele.getAttribute(ALIAS_ATTRIBUTE);</span><br><span class="line">        boolean valid = true;</span><br><span class="line">        //&lt;alias&gt;别名元素的 name 属性值为空</span><br><span class="line">        if (!StringUtils.hasText(name)) &#123;</span><br><span class="line">            getReaderContext().error(&quot;Name must not be empty&quot;, ele);</span><br><span class="line">            valid = false;</span><br><span class="line">        &#125;</span><br><span class="line">        //&lt;alias&gt;别名元素的 alias 属性值为空</span><br><span class="line">        if (!StringUtils.hasText(alias)) &#123;</span><br><span class="line">            getReaderContext().error(&quot;Alias must not be empty&quot;, ele);</span><br><span class="line">            valid = false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (valid) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //向容器的资源读入器注册别名</span><br><span class="line">                getReaderContext().getRegistry().registerAlias(name, alias);</span><br><span class="line">            &#125; catch (Exception ex) &#123;</span><br><span class="line">                getReaderContext().error(&quot;Failed to register alias &apos;&quot; + alias +</span><br><span class="line">                        &quot;&apos; for bean with name &apos;&quot; + name + &quot;&apos;&quot;, ele, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            //在解析完&lt;Alias&gt;元素之后，发送容器别名处理完成事件</span><br><span class="line">            getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //解析 Bean 定义资源 Document 对象的普通元素</span><br><span class="line">    protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">        // BeanDefinitionHolder 是对 BeanDefinition 的封装，即 Bean 定义的封装类</span><br><span class="line">        //对 Document 对象中&lt;Bean&gt;元素的解析由 BeanDefinitionParserDelegate 实现 BeanDefinitionHolder</span><br><span class="line">        bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">        if (bdHolder != null) &#123;</span><br><span class="line">            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">            try &#123;</span><br><span class="line">                //向 Spring IoC 容器注册解析得到的 Bean 定义，这是 Bean 定义向 IOC 容器注册的入口</span><br><span class="line">                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder,</span><br><span class="line">                        getReaderContext().getRegistry());</span><br><span class="line">            &#125; catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">                getReaderContext().error(&quot;Failed to register bean definition with name &apos;&quot; +</span><br><span class="line">                        bdHolder.getBeanName() + &quot;&apos;&quot;, ele, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            //在完成向 Spring IoC 容器注册解析得到的 Bean 定义之后，发送注册事件</span><br><span class="line">            getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过上述 Spring IOC 容器对载入的 Bean 定义 Document 解析可以看出，我们使用 Spring 时，在 Spring<br>配置文件中可以使用<code>&lt;Import&gt;</code>元素来导入 IOC 容器所需要的其他资源，Spring IoC 容器在解析时会首<br>先将指定导入的资源加载进容器中。使用<code>&lt;Ailas&gt;</code>别名时，Spring IOC 容器首先将别名元素所定义的别<br>名注册到容器中。</p><p>对于既不是<code>&lt;Import&gt;</code>元素，又不是<code>&lt;Alias&gt;</code>元素的元素，即 Spring 配置文件中普通的<code>&lt;Bean&gt;</code>元素的解析<br>由 BeanDefinitionParserDelegate 类的 parseBeanDefinitionElement 方法来实现。</p><h3><a id="BeanDefinitionParserDelegate__Bean_Bean_220"></a><a class="header-anchor" href="#beandefinitionparserdelegate-解析-bean-定义资源文件中的-bean-元素">¶</a>BeanDefinitionParserDelegate 解析 Bean 定义资源文件中的<code>&lt;Bean&gt;</code>元素</h3><p>Bean 定义资源文件中的<code>&lt;Import&gt;</code>和<code>&lt;Alias&gt;</code>元素解析在 DefaultBeanDefinitionDocumentReader 中已经<br>完成，对 Bean 定义资源文件中使用最多的<code>&lt;Bean&gt;</code>元素交由 BeanDefinitionParserDelegate 来解析，其解析实现的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">//解析&lt;Bean&gt;元素的入口</span><br><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) &#123;</span><br><span class="line">    return parseBeanDefinitionElement(ele, null);</span><br><span class="line">&#125;</span><br><span class="line">//解析 Bean 定义资源文件中的&lt;Bean&gt;元素，这个方法中主要处理&lt;Bean&gt;元素的 id，name和别名属性</span><br><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition</span><br><span class="line">        containingBean) &#123;</span><br><span class="line">    //获取&lt;Bean&gt;元素中的 id 属性值</span><br><span class="line">    String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">    //获取&lt;Bean&gt;元素中的 name 属性值</span><br><span class="line">    String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">    //获取&lt;Bean&gt;元素中的 alias 属性值</span><br><span class="line">    List&lt;String&gt; aliases = new ArrayList&lt;String&gt;();</span><br><span class="line">    //将&lt;Bean&gt;元素中的所有 name 属性值存放到别名中</span><br><span class="line">    if (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, BEAN_NAME_DELIMITERS);</span><br><span class="line">        aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">    &#125;</span><br><span class="line">    String beanName = id;</span><br><span class="line">    //如果&lt;Bean&gt;元素中没有配置 id 属性时，将别名中的第一个值赋值给 beanName</span><br><span class="line">    if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">        beanName = aliases.remove(0);</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(&quot;No XML &apos;id&apos; specified - using &apos;&quot; + beanName +</span><br><span class="line">                    &quot;&apos; as bean name and &quot; + aliases + &quot; as aliases&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //检查&lt;Bean&gt;元素所配置的 id 或者 name 的唯一性，containingBean 标识&lt;Bean&gt;</span><br><span class="line">    //元素中是否包含子&lt;Bean&gt;元素</span><br><span class="line">    if (containingBean == null) &#123;</span><br><span class="line">    //检查&lt;Bean&gt;元素所配置的 id、name 或者别名是否重复</span><br><span class="line">        checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">    &#125;</span><br><span class="line">    //详细对&lt;Bean&gt;元素中配置的 Bean 定义进行解析的地方</span><br><span class="line">    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName,</span><br><span class="line">            containingBean);</span><br><span class="line">    if (beanDefinition != null) &#123;</span><br><span class="line">        if (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (containingBean != null) &#123;</span><br><span class="line">                    //如果&lt;Bean&gt;元素中没有配置 id、别名或者 name，且没有包含子元素</span><br><span class="line">                    //&lt;Bean&gt;元素，为解析的 Bean 生成一个唯一 beanName 并注册</span><br><span class="line">                    beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                            beanDefinition, this.readerContext.getRegistry(), true);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    //如果&lt;Bean&gt;元素中没有配置 id、别名或者 name，且包含了子元素</span><br><span class="line">                    //&lt;Bean&gt;元素，为解析的 Bean 使用别名向 IOC 容器注册</span><br><span class="line">                    beanName = this.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">                    //为解析的 Bean 使用别名注册时，为了向后兼容</span><br><span class="line">                    //Spring1.2/2.0，给别名添加类名后缀</span><br><span class="line">                    String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">                    if (beanClassName != null &amp;&amp;</span><br><span class="line">                            beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt;</span><br><span class="line">                            beanClassName.length() &amp;&amp;</span><br><span class="line">                            !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                        aliases.add(beanClassName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(&quot;Neither XML &apos;id&apos; nor &apos;name&apos; specified - &quot; +</span><br><span class="line">                            &quot;using generated bean name [&quot; + beanName + &quot;]&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception ex) &#123;</span><br><span class="line">                error(ex.getMessage(), ele);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">        return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">    &#125;</span><br><span class="line">    //当解析出错时，返回 null</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line">//详细对&lt;Bean&gt;元素中配置的 Bean 定义其他属性进行解析，由于上面的方法中已经对</span><br><span class="line">//Bean 的 id、name 和别名等属性进行了处理，该方法中主要处理除这三个以外的其他属性数据</span><br><span class="line">public AbstractBeanDefinition parseBeanDefinitionElement(</span><br><span class="line">        Element ele, String beanName, BeanDefinition containingBean) &#123;</span><br><span class="line">    //记录解析的&lt;Bean&gt;</span><br><span class="line">    this.parseState.push(new BeanEntry(beanName));</span><br><span class="line">    //这里只读取&lt;Bean&gt;元素中配置的 class 名字，然后载入到 BeanDefinition 中去</span><br><span class="line">    //只是记录配置的 class 名字，不做实例化，对象的实例化在依赖注入时完成</span><br><span class="line">    String className = null;</span><br><span class="line">    if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        String parent = null;</span><br><span class="line">        //如果&lt;Bean&gt;元素中配置了 parent 属性，则获取 parent 属性的值</span><br><span class="line">        if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">            parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">        &#125;</span><br><span class="line">        //根据&lt;Bean&gt;元素配置的 class 名称和 parent 属性值创建 BeanDefinition</span><br><span class="line">        //为载入 Bean 定义信息做准备</span><br><span class="line">        AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line">        //对当前的&lt;Bean&gt;元素中配置的一些属性进行解析和设置，如配置的单态(singleton)属性等</span><br><span class="line">        parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">        //为&lt;Bean&gt;元素解析的 Bean 设置 description 信息</span><br><span class="line">        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line">        //对&lt;Bean&gt;元素的 meta(元信息)属性解析</span><br><span class="line">        parseMetaElements(ele, bd);</span><br><span class="line">        //对&lt;Bean&gt;元素的 lookup-method 属性解析</span><br><span class="line">        parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        //对&lt;Bean&gt;元素的 replaced-method 属性解析</span><br><span class="line">        parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        //解析&lt;Bean&gt;元素的构造方法设置</span><br><span class="line">        parseConstructorArgElements(ele, bd);</span><br><span class="line">        //解析&lt;Bean&gt;元素的&lt;property&gt;设置</span><br><span class="line">        parsePropertyElements(ele, bd);</span><br><span class="line">        //解析&lt;Bean&gt;元素的 qualifier 属性</span><br><span class="line">        parseQualifierElements(ele, bd);</span><br><span class="line">        //为当前解析的 Bean 设置所需的资源和依赖对象</span><br><span class="line">        bd.setResource(this.readerContext.getResource());</span><br><span class="line">        bd.setSource(extractSource(ele));</span><br><span class="line">        return bd;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ClassNotFoundException ex) &#123;</span><br><span class="line">        error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (NoClassDefFoundError err) &#123;</span><br><span class="line">        error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable ex) &#123;</span><br><span class="line">        error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        this.parseState.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    //解析&lt;Bean&gt;元素出错时，返回 null</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要使用过 Spring，对 Spring 配置文件比较熟悉的人，通过对上述源码的分析，就会明白我们在 Spring<br>配置文件中<code>&lt;Bean&gt;</code>元素的中配置的属性就是通过该方法解析和设置到 Bean 中去的。</p><p>注意：在解析<code>&lt;Bean&gt;</code>元素过程中没有创建和实例化 Bean 对象，只是创建了 Bean 对象的定义类BeanDefinition，将<code>&lt;Bean&gt;</code>元素中的配置信息设置到 BeanDefinition 中作为记录，当依赖注入时才使用这些记录信息创建和实例化具体的 Bean 对象。</p><p>上面方法中一些对一些配置如元信息(meta)、qualifier 等的解析，我们在 Spring 中配置时使用的也不多，我们在使用 Spring 的<code>&lt;Bean&gt;</code>元素时，配置最多的是<code>&lt;property&gt;</code>属性，因此我们下面继续分析源码，了解 Bean 的属性在解析时是如何设置的。</p><h3><a id="BeanDefinitionParserDelegate_property_231"></a><a class="header-anchor" href="#beandefinitionparserdelegate-解析-property-元素">¶</a>BeanDefinitionParserDelegate 解析<code>&lt;property&gt;</code>元素</h3><p>BeanDefinitionParserDelegate 在解析<code>&lt;Bean&gt;</code>调用 parsePropertyElements 方法解析<code>&lt;Bean&gt;</code>元素中的<br><code>&lt;property&gt;</code>属性子元素，解析源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">//解析&lt;Bean&gt;元素中的&lt;property&gt;子元素</span><br><span class="line">public void parsePropertyElements(Element beanEle, BeanDefinition bd) &#123;</span><br><span class="line">    //获取&lt;Bean&gt;元素中所有的子元素</span><br><span class="line">    NodeList nl = beanEle.getChildNodes();</span><br><span class="line">    for (int i = 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">        Node node = nl.item(i);</span><br><span class="line">        //如果子元素是&lt;property&gt;子元素，则调用解析&lt;property&gt;子元素方法解析</span><br><span class="line">        if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) &#123;</span><br><span class="line">            parsePropertyElement((Element) node, bd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//解析&lt;property&gt;元素</span><br><span class="line">public void parsePropertyElement(Element ele, BeanDefinition bd) &#123;</span><br><span class="line">    //获取&lt;property&gt;元素的名字</span><br><span class="line">    String propertyName = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">    if (!StringUtils.hasLength(propertyName)) &#123;</span><br><span class="line">        error(&quot;Tag &apos;property&apos; must have a &apos;name&apos; attribute&quot;, ele);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    this.parseState.push(new PropertyEntry(propertyName));</span><br><span class="line">    try &#123;</span><br><span class="line">        //如果一个 Bean 中已经有同名的 property 存在，则不进行解析，直接返回。</span><br><span class="line">        //即如果在同一个 Bean 中配置同名的 property，则只有第一个起作用</span><br><span class="line">        if (bd.getPropertyValues().contains(propertyName)) &#123;</span><br><span class="line">            error(&quot;Multiple &apos;property&apos; definitions for property &apos;&quot; + propertyName + &quot;&apos;&quot;, ele);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //解析获取 property 的值</span><br><span class="line">        Object val = parsePropertyValue(ele, bd, propertyName);</span><br><span class="line">        //根据 property 的名字和值创建 property 实例</span><br><span class="line">        PropertyValue pv = new PropertyValue(propertyName, val);</span><br><span class="line">        //解析&lt;property&gt;元素中的属性</span><br><span class="line">        parseMetaElements(ele, pv);</span><br><span class="line">        pv.setSource(extractSource(ele));</span><br><span class="line">        bd.getPropertyValues().addPropertyValue(pv);</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        this.parseState.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//解析获取 property 值</span><br><span class="line">public Object parsePropertyValue(Element ele, BeanDefinition bd, String propertyName) &#123;</span><br><span class="line">    String elementName = (propertyName != null) ?</span><br><span class="line">            &quot;&lt;property&gt; element for property &apos;&quot; + propertyName + &quot;&apos;&quot; :</span><br><span class="line">            &quot;&lt;constructor-arg&gt; element&quot;;</span><br><span class="line">    //获取&lt;property&gt;的所有子元素，只能是其中一种类型:ref,value,list 等</span><br><span class="line">    NodeList nl = ele.getChildNodes();</span><br><span class="line">    Element subElement = null;</span><br><span class="line">    for (int i = 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">        Node node = nl.item(i);</span><br><span class="line">        //子元素不是 description 和 meta 属性</span><br><span class="line">        if (node instanceof Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp;</span><br><span class="line">                !nodeNameEquals(node, META_ELEMENT)) &#123;</span><br><span class="line">            if (subElement != null) &#123;</span><br><span class="line">                error(elementName + &quot; must not contain more than one sub-element&quot;, ele);</span><br><span class="line">            &#125;</span><br><span class="line">            //当前&lt;property&gt;元素包含有子元素</span><br><span class="line">            else &#123;</span><br><span class="line">                subElement = (Element) node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //判断 property 的属性值是 ref 还是 value，不允许既是 ref 又是 value</span><br><span class="line">    boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);</span><br><span class="line">    boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);</span><br><span class="line">    if ((hasRefAttribute &amp;&amp; hasValueAttribute) ||</span><br><span class="line">            ((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement != null)) &#123;</span><br><span class="line">        error(elementName +</span><br><span class="line">                        &quot; is only allowed to contain either &apos;ref&apos; attribute OR &apos;value&apos; attribute OR</span><br><span class="line">                sub-element&quot;, ele);</span><br><span class="line">    &#125;</span><br><span class="line">    //如果属性是 ref，创建一个 ref 的数据对象 RuntimeBeanReference</span><br><span class="line">    //这个对象封装了 ref 信息</span><br><span class="line">    if (hasRefAttribute) &#123;</span><br><span class="line">        String refName = ele.getAttribute(REF_ATTRIBUTE);</span><br><span class="line">        if (!StringUtils.hasText(refName)) &#123;</span><br><span class="line">            error(elementName + &quot; contains empty &apos;ref&apos; attribute&quot;, ele);</span><br><span class="line">        &#125;</span><br><span class="line">    //一个指向运行时所依赖对象的引用</span><br><span class="line">        RuntimeBeanReference ref = new RuntimeBeanReference(refName);</span><br><span class="line">    //设置这个 ref 的数据对象是被当前的 property 对象所引用</span><br><span class="line">        ref.setSource(extractSource(ele));</span><br><span class="line">        return ref;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果属性是 value，创建一个 value 的数据对象 TypedStringValue</span><br><span class="line">    //这个对象封装了 value 信息</span><br><span class="line">    else if (hasValueAttribute) &#123;</span><br><span class="line">        //一个持有 String 类型值的对象</span><br><span class="line">        TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));</span><br><span class="line">        //设置这个 value 数据对象是被当前的 property 对象所引用</span><br><span class="line">        valueHolder.setSource(extractSource(ele));</span><br><span class="line">        return valueHolder;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果当前&lt;property&gt;元素还有子元素</span><br><span class="line">    else if (subElement != null) &#123;</span><br><span class="line">        //解析&lt;property&gt;的子元素</span><br><span class="line">        return parsePropertySubElement(subElement, bd);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        //propery 属性中既不是 ref，也不是 value 属性，解析出错返回 null</span><br><span class="line">        error(elementName + &quot; must specify a ref or value&quot;, ele);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对上述源码的分析，我们可以了解在 Spring 配置文件中，<code>&lt;Bean&gt;</code>元素中<code>&lt;property&gt;</code>元素的相关配<br>置是如何处理的：</p><ul><li>ref 被封装为指向依赖对象一个引用</li><li>value 配置都会封装成一个字符串类型的对象</li><li>ref 和 value 都通过“解析的数据类型属性值.setSource(extractSource(ele));”方法将属性值/引用与所引用的属性关联起来<br>在方法的最后对于<code>&lt;property&gt;</code>元素的子元素通过 parsePropertySubElement 方法解析，我们继续分析<br>该方法的源码，了解其解析过程。</li></ul><h3><a id="property_244"></a><a class="header-anchor" href="#解析-property-元素的子元素">¶</a>解析<code>&lt;property&gt;</code>元素的子元素</h3><p>在 BeanDefinitionParserDelegate 类中的 parsePropertySubElement 方法对<code>&lt;property&gt;</code>中的子元素解析，源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">//解析&lt;property&gt;元素中 ref,value 或者集合等子元素</span><br><span class="line">    public Object parsePropertySubElement(Element ele, BeanDefinition bd, String defaultValueType) &#123;</span><br><span class="line">        //如果&lt;property&gt;没有使用 Spring 默认的命名空间，则使用用户自定义的规则解析</span><br><span class="line">        //内嵌元素</span><br><span class="line">        if (!isDefaultNamespace(ele)) &#123;</span><br><span class="line">            return parseNestedCustomElement(ele, bd);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子元素是 bean，则使用解析&lt;Bean&gt;元素的方法解析</span><br><span class="line">        else if (nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">            BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);</span><br><span class="line">            if (nestedBd != null) &#123;</span><br><span class="line">                nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);</span><br><span class="line">            &#125;</span><br><span class="line">            return nestedBd;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子元素是 ref，ref 中只能有以下 3 个属性：bean、local、parent</span><br><span class="line">        else if (nodeNameEquals(ele, REF_ELEMENT)) &#123;</span><br><span class="line">            //获取&lt;property&gt;元素中的 bean 属性值，引用其他解析的 Bean 的名称</span><br><span class="line">            //可以不再同一个 Spring 配置文件中，具体请参考 Spring 对 ref 的配置规则</span><br><span class="line">            String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);</span><br><span class="line">            boolean toParent = false;</span><br><span class="line">            if (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line">                //获取&lt;property&gt;元素中的 local 属性值，引用同一个 Xml 文件中配置</span><br><span class="line">                //的 Bean 的 id，local 和 ref 不同，local 只能引用同一个配置文件中的 Bean</span><br><span class="line">                refName = ele.getAttribute(LOCAL_REF_ATTRIBUTE);</span><br><span class="line">                if (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line">                    //获取&lt;property&gt;元素中 parent 属性值，引用父级容器中的 Bean</span><br><span class="line">                    refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);</span><br><span class="line">                    toParent = true;</span><br><span class="line">                    if (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line">                        error(&quot;&apos;bean&apos;, &apos;local&apos; or &apos;parent&apos; is required for &lt;ref&gt; element&quot;, ele);</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //没有配置 ref 的目标属性值</span><br><span class="line">            if (!StringUtils.hasText(refName)) &#123;</span><br><span class="line">                error(&quot;&lt;ref&gt; element contains empty target attribute&quot;, ele);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            //创建 ref 类型数据，指向被引用的对象</span><br><span class="line">            RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent);</span><br><span class="line">            //设置引用类型值是被当前子元素所引用</span><br><span class="line">            ref.setSource(extractSource(ele));</span><br><span class="line">            return ref;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子元素是&lt;idref&gt;，使用解析 ref 元素的方法解析</span><br><span class="line">        else if (nodeNameEquals(ele, IDREF_ELEMENT)) &#123;</span><br><span class="line">            return parseIdRefElement(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子元素是&lt;value&gt;，使用解析 value 元素的方法解析</span><br><span class="line">        else if (nodeNameEquals(ele, VALUE_ELEMENT)) &#123;</span><br><span class="line">            return parseValueElement(ele, defaultValueType);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子元素是 null，为&lt;property&gt;设置一个封装 null 值的字符串数据</span><br><span class="line">        else if (nodeNameEquals(ele, NULL_ELEMENT)) &#123;</span><br><span class="line">            TypedStringValue nullHolder = new TypedStringValue(null);</span><br><span class="line">            nullHolder.setSource(extractSource(ele));</span><br><span class="line">            return nullHolder;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子元素是&lt;array&gt;，使用解析 array 集合子元素的方法解析</span><br><span class="line">        else if (nodeNameEquals(ele, ARRAY_ELEMENT)) &#123;</span><br><span class="line">            return parseArrayElement(ele, bd);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子元素是&lt;list&gt;，使用解析 list 集合子元素的方法解析</span><br><span class="line">        else if (nodeNameEquals(ele, LIST_ELEMENT)) &#123;</span><br><span class="line">            return parseListElement(ele, bd);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子元素是&lt;set&gt;，使用解析 set 集合子元素的方法解析</span><br><span class="line">        else if (nodeNameEquals(ele, SET_ELEMENT)) &#123;</span><br><span class="line">            return parseSetElement(ele, bd);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子元素是&lt;map&gt;，使用解析 map 集合子元素的方法解析</span><br><span class="line">        else if (nodeNameEquals(ele, MAP_ELEMENT)) &#123;</span><br><span class="line">            return parseMapElement(ele, bd);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果子元素是&lt;props&gt;，使用解析 props 集合子元素的方法解析</span><br><span class="line">        else if (nodeNameEquals(ele, PROPS_ELEMENT)) &#123;</span><br><span class="line">            return parsePropsElement(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        //既不是 ref，又不是 value，也不是集合，则子元素配置错误，返回 null</span><br><span class="line">        else &#123;</span><br><span class="line">            error(&quot;Unknown property sub-element: [&quot; + ele.getNodeName() + &quot;]&quot;, ele);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过上述源码分析，我们明白了在 Spring 配置文件中，对<code>&lt;property&gt;</code>元素中配置的 Array、List、Set、<br>Map、Prop 等各种集合子元素的都通过上述方法解析，生成对应的数据对象，比如 ManagedList、<br>ManagedArray、ManagedSet 等，这些 Managed 类是 Spring 对象 BeanDefiniton 的数据封装，对集合数据类型的具体解析有各自的解析方法实现，解析方法的命名非常规范，一目了然，我们对<list>集合元素的解析方法进行源码分析，了解其实现过程。</list></p><h3><a id="list_251"></a><a class="header-anchor" href="#解析-list-子元素">¶</a>解析<code>&lt;list&gt;</code>子元素</h3><p>在 BeanDefinitionParserDelegate 类中的 parseListElement 方法就是具体实现解析<code>&lt;property&gt;</code>元素中的<code>&lt;list&gt;</code>集合子元素，源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//解析&lt;list&gt;集合子元素</span><br><span class="line">public List parseListElement(Element collectionEle, BeanDefinition bd) &#123;</span><br><span class="line">    //获取&lt;list&gt;元素中的 value-type 属性，即获取集合元素的数据类型</span><br><span class="line">    String defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);</span><br><span class="line">    //获取&lt;list&gt;集合元素中的所有子节点</span><br><span class="line">    NodeList nl = collectionEle.getChildNodes();</span><br><span class="line">    //Spring 中将 List 封装为 ManagedList</span><br><span class="line">    ManagedList&lt;Object&gt; target = new ManagedList&lt;Object&gt;(nl.getLength());</span><br><span class="line">    target.setSource(extractSource(collectionEle));</span><br><span class="line">    //设置集合目标数据类型</span><br><span class="line">    target.setElementTypeName(defaultElementType);</span><br><span class="line">    target.setMergeEnabled(parseMergeAttribute(collectionEle));</span><br><span class="line">    //具体的&lt;list&gt;元素解析</span><br><span class="line">    parseCollectionElements(nl, target, bd, defaultElementType);</span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br><span class="line">//具体解析&lt;list&gt;集合元素，&lt;array&gt;、&lt;list&gt;和&lt;set&gt;都使用该方法解析</span><br><span class="line">protected void parseCollectionElements(</span><br><span class="line">        NodeList elementNodes, Collection&lt;Object&gt; target, BeanDefinition bd, String</span><br><span class="line">        defaultElementType) &#123;</span><br><span class="line">    //遍历集合所有节点</span><br><span class="line">    for (int i = 0; i &lt; elementNodes.getLength(); i++) &#123;</span><br><span class="line">        Node node = elementNodes.item(i);</span><br><span class="line">        //节点不是 description 节点</span><br><span class="line">        if (node instanceof Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT)) &#123;</span><br><span class="line">            //将解析的元素加入集合中，递归调用下一个子元素</span><br><span class="line">            target.add(parsePropertySubElement((Element) node, bd, defaultElementType));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过对 Spring Bean 定义资源文件转换的 Document 对象中的元素层层解析，Spring IOC 现在已经将<br>XML 形式定义的 Bean 定义资源文件转换为 Spring IOC 所识别的数据结构——BeanDefinition，它是<br>Bean 定义资源文件中配置的 POJO 对象在 Spring IOC 容器中的映射，我们可以通过<br>AbstractBeanDefinition 为入口，看到了 IOC 容器进行索引、查询和操作。</p><p>通过 Spring IOC 容器对 Bean 定义资源的解析后，IOC 容器大致完成了管理 Bean 对象的准备工作，即<br>初始化过程，但是最为重要的依赖注入还没有发生，现在在 IOC 容器中 BeanDefinition 存储的只是一<br>些静态信息，接下来需要向容器注册 Bean 定义信息才能全部完成 IoC 容器的初始化过程</p><h3><a id="_BeanDefinition__IOC__264"></a><a class="header-anchor" href="#解析过后的-beandefinition-在-ioc-容器中的注册">¶</a>解析过后的 BeanDefinition 在 IOC 容器中的注册</h3><p>让我们继续跟踪程序的执行顺序，接下来会到我们第3步中分析DefaultBeanDefinitionDocumentReader<br>对 Bean 定义转换的 Document 对象解析的流程中，在其 parseDefaultElement 方法中完成对 Document<br>对象的解析后得到封装 BeanDefinition 的 BeanDefinitionHold 对象，然后调用<br>BeanDefinitionReaderUtils 的 registerBeanDefinition 方法向 IOC 容器注册解析的 Bean，BeanDefinitionReaderUtils 的注册的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//将解析的 BeanDefinitionHold 注册到容器中</span><br><span class="line">public static void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span><br><span class="line">        throws BeanDefinitionStoreException &#123;</span><br><span class="line">    //获取解析的 BeanDefinition 的名称</span><br><span class="line">    String beanName = definitionHolder.getBeanName();</span><br><span class="line">    //向 IOC 容器注册 BeanDefinition</span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line">    //如果解析的 BeanDefinition 有别名，向容器为其注册别名</span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    if (aliases != null) &#123;</span><br><span class="line">        for (String aliase : aliases) &#123;</span><br><span class="line">            registry.registerAlias(beanName, aliase);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 BeanDefinitionReaderUtils 向 IOC 容器注册解析的 BeanDefinition 时，真正完成注册功能的<br>是 DefaultListableBeanFactory。</p><h3><a id="DefaultListableBeanFactory__IOC__BeanDefinition_273"></a><a class="header-anchor" href="#defaultlistablebeanfactory-向-ioc-容器注册解析后的-beandefinition">¶</a>DefaultListableBeanFactory 向 IOC 容器注册解析后的 BeanDefinition</h3><p>DefaultListableBeanFactory 向 IOC 容器注册解析后的 BeanDefinition：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191107114157.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//存储注册信息的 BeanDefinition</span><br><span class="line">    private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;String, BeanDefinition&gt;();</span><br><span class="line">    //向 IoC 容器注册解析的 BeanDefiniton</span><br><span class="line">    public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException &#123;</span><br><span class="line">        Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);</span><br><span class="line">        Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);</span><br><span class="line">        //校验解析的 BeanDefiniton</span><br><span class="line">        if (beanDefinition instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">            &#125;</span><br><span class="line">            catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">                throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(),</span><br><span class="line">                        beanName,</span><br><span class="line">                        &quot;Validation of bean definition failed&quot;, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //注册的过程中需要线程同步，以保证数据的一致性</span><br><span class="line">        synchronized (this.beanDefinitionMap) &#123;</span><br><span class="line">            Object oldBeanDefinition = this.beanDefinitionMap.get(beanName);</span><br><span class="line">            //检查是否有同名的 BeanDefinition 已经在 IOC 容器中注册，如果已经注册，</span><br><span class="line">            //并且不允许覆盖已注册的 Bean，则抛出注册失败异常</span><br><span class="line">            if (oldBeanDefinition != null) &#123;</span><br><span class="line">                if (!this.allowBeanDefinitionOverriding) &#123;</span><br><span class="line">                    throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(),</span><br><span class="line">                            beanName,</span><br><span class="line">                            &quot;Cannot register bean definition [&quot; + beanDefinition + &quot;] for bean &apos;&quot; +</span><br><span class="line">                                    beanName +</span><br><span class="line">                                    &quot;&apos;: There is already [&quot; + oldBeanDefinition + &quot;] bound.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    //如果允许覆盖，则同名的 Bean，后注册的覆盖先注册的</span><br><span class="line">                    if (this.logger.isInfoEnabled()) &#123;</span><br><span class="line">                        this.logger.info(&quot;Overriding bean definition for bean &apos;&quot; + beanName +</span><br><span class="line">                                &quot;&apos;: replacing [&quot; + oldBeanDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //IOC 容器中没有已经注册同名的 Bean，按正常注册流程注册</span><br><span class="line">            else &#123;</span><br><span class="line">                this.beanDefinitionNames.add(beanName);</span><br><span class="line">                this.frozenBeanDefinitionNames = null;</span><br><span class="line">            &#125;</span><br><span class="line">            this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            //重置所有已经注册过的 BeanDefinition 的缓存</span><br><span class="line">            resetBeanDefinition(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>至此，Bean 定义资源文件中配置的 Bean 被解析过后，已经注册到 IOC 容器中，被容器管理起来，真正<br>完成了 IOC 容器初始化所做的全部工作。现在 IOC 容器中已经建立了整个 Bean 的配置信息，这些<br>BeanDefinition 信息已经可以使用，并且可以被检索，IOC 容器的作用就是对这些注册的 Bean 定义信<br>息进行处理和维护。这些的注册的 Bean 定义信息是 IoC 容器控制反转的基础，正是有了这些注册的数<br>据，容器才可以进行依赖注入。</p><h1><a id="_283"></a>总结</h1><p>现在通过上面的代码，总结一下 IOC 容器初始化的基本步骤：</p><ul><li>初始化的入口在容器实现中的 refresh()调用来完成</li><li>对 bean 定义载入 IOC 容器使用的方法是 loadBeanDefinition,</li></ul><p>其中的大致过程如下：<br>通过 ResourceLoader 来完成资源文件位置的定位，DefaultResourceLoader 是默<br>认的实现，同时上下文本身就给出了 ResourceLoader 的实现，可以从类路径，文件系统,URL 等方式来<br>定为资源位置。如果是 XmlBeanFactory 作为 IOC 容器，那么需要为它指定 bean 定义的资源，也就是说<br>bean 定义文件时通过抽象成 Resource 来被 IOC 容器处理的，容器通过 BeanDefinitionReader 来完成<br>定义信息的解析和 Bean 信息的注册,往往使用的是 XmlBeanDefinitionReader 来解析 bean 的 xml 定义<br>文件-实际的处理过程是委托给 BeanDefinitionParserDelegate来完成的，从而得到bean的定义信息，<br>这些信息在 Spring 中使用 BeanDefinition 对象来表示-这个名字可以让我们想到<br>loadBeanDefinition,RegisterBeanDefinition 这些相关方法-他们都是为处理BeanDefinitin 服务的，<br>容器解析得到 BeanDefinitionIoC 以后，需要把它在 IOC 容器中注册，这由 IOC 实<br>现 BeanDefinitionRegistry 接口来实现。注册过程就是在 IOC 容器内部维护的一个 HashMap 来保存得<br>到的 BeanDefinition 的过程。这个 HashMap 是 IOC 容器持有 bean 信息的场所，以后对 bean 的操作都<br>是围绕这个 HashMap 来实现的.</p><p>然后我们就可以通过 BeanFactory 和 ApplicationContext 来享受到 SpringIOC 的服务了,在使用 IOC<br>容器的时候，我们注意到除了少量粘合代码，绝大多数以正确 IOC 风格编写的应用程序代码完全不用关<br>心如何到达工厂，因为容器将把这些对象与容器管理的其他对象钩在一起。基本的策略是把工厂放到已<br>知的地方，最好是放在对预期使用的上下文有意义的地方，以及代码将实际需要访问工厂的地方。Spring<br>本身提供了对声明式载入 web 应用程序用法的应用程序上下文,并将其存储在 ServletContext 中的框架<br>实现。</p><h1><a id="_SpringIOC__309"></a>在使用 SpringIOC 容器的时候我们还需要区别两个概念</h1><h2><a id="BeanFactory__FactoryBean_310"></a><a class="header-anchor" href="#beanfactory-和-factorybean">¶</a>BeanFactory 和 FactoryBean</h2><ul><li>BeanFactory 功能性工厂，专门用来生产bean的，如果是生产车的就叫做CarFactory,是 IOC 容器的编程抽象，比如ApplicationContext，XmlBeanFactory 等，这些都是 IOC 容器的具体表现，需要使用什么样的容器由客户决定,但 Spring 为我们提供了丰富的选择。</li><li>FactoryBean 是由spring工厂生产出来的bean, 只是一个可以在 IOC 而容器中被管理的一个bean,是对各种处理过程和资源使用的抽象,FactoryBean 在需要时产生另一个对象，而不返回FactoryBean 本身,我们可以把它看成是一个抽象工厂，对它的调用返回的是工厂生产的产品。所有的FactoryBean 都实现特殊的 org.springframework.beans.factory.FactoryBean 接口，当使用容器中FactoryBean 的时候，该容器不会返回 FactoryBean 本身,而是返回其生成的对象。Spring 包括了大部分的通用资源和服务访问抽象的 FactoryBean 的实现，其中包括:对 JNDI 查询的处理，对代理对象的处理，对事务性代理的处理，对 RMI 代理的处理等，这些我们都可以看成是具体的工厂,看成是 Spring 为我们建立好的工厂。也就是说 Spring 通过使用抽象工厂模式为我们准备了一系列工厂来生产一些特定的对象,免除我们手工重复的工作，我们要使用时只需要在 IOC 容器里配置好就能很方便的使用了</li></ul><p><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/ioc%20%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt></p><h5><a id="springboot_316"></a><a class="header-anchor" href="#springboot">¶</a>springboot</h5><p>SpringApplication<br>AnnotationConfigServletWebServerApplicationContext<br>ServletWebServerApplicationContext<br>AbstractApplicationContext 在这个类中定义了扫描注解的执行器<br>ClassPathBeanDefinitionScanner<br>ClassPathScanningCandidateComponentProvider<br>AbstractTypeHierarchyTraversingFilter<br>AnnotationTypeFilter</p><p><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191114174000.png" alt></p></div><div id="wechat_subscriber" style="display:block;padding:10px 0;margin:20px auto;width:100%;text-align:center"><img id="wechat_subscriber_qcode" src="/blog/uploads/wechat-qcode.png" alt="Jeff-Eric wechat" style="width:200px;max-width:100%"><div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Jeff-Eric</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://jeff-eric.github.com/blog/2019/10/22/spring%20-%20IOC/" title="spring - IOC">https:&#x2F;&#x2F;jeff-eric.github.com&#x2F;blog&#x2F;2019&#x2F;10&#x2F;22&#x2F;spring%20-%20IOC&#x2F;</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank">&lt;i class=&quot;fa fa-fw fa-creative-commons&quot;&gt;&lt;&#x2F;i&gt;BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/blog/tags/%E6%9E%B6%E6%9E%84%E5%B8%88/" rel="tag"># 架构师</a></div><div class="post-widgets"><div class="social_share"><div id="needsharebutton-postbottom"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/blog/2019/10/22/fq%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" rel="next" title="fq软件安装"><i class="fa fa-chevron-left"></i> fq软件安装</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/blog/2019/10/24/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90---%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F/" rel="prev" title="AbstractQueuedSynchronizer 原理分析 - 独占模式">AbstractQueuedSynchronizer 原理分析 - 独占模式 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/blog/uploads/avatar.jpg" alt="Jeff-Eric"><p class="site-author-name" itemprop="name">Jeff-Eric</p><div class="site-description motion-element" itemprop="description"></div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/blog/archives/%20%7C%7C%20archive"><span class="site-state-item-count">42</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/blog/categories/%20%7C%7C%20th"><span class="site-state-item-count">12</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/blog/tags/%20%7C%7C%20tags"><span class="site-state-item-count">28</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/jeff-eric" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;jeff-eric" rel="noopener" target="_blank">&lt;i class=&quot;fa fa-fw fa-github&quot;&gt;&lt;&#x2F;i&gt;GitHub</a> </span><span class="links-of-author-item"><a href="/blog/jphoebe4086824@gmail.com" title="E-Mail &amp;rarr; jphoebe4086824@gmail.com">&lt;i class=&quot;fa fa-fw fa-envelope&quot;&gt;&lt;&#x2F;i&gt;E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank">&lt;img src=&quot;&#x2F;blog&#x2F;images&#x2F;cc-by-nc-sa.svg&quot; alt=&quot;Creative Commons&quot;&#x2F;&gt;</a></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">1.</span> <span class="nav-text">IOC体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">1.1.</span> <span class="nav-text">¶BeanFactory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">1.2.</span> <span class="nav-text">¶BeanDefinition</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">2.</span> <span class="nav-text">IOC容器的初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">2.1.</span> <span class="nav-text">¶XmlBeanFactory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">2.2.</span> <span class="nav-text">¶FileSystemXmlApplicationContext</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">2.2.1.</span> <span class="nav-text">¶refresh()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">2.2.2.</span> <span class="nav-text">¶XmlBeanDefinitionReader 加载 Bean 定义资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">2.2.3.</span> <span class="nav-text">¶XmlBeanDefinitionReader 解析载入的 Bean 定义资源文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">2.2.4.</span> <span class="nav-text">¶DefaultBeanDefinitionDocumentReader 对 Bean 定义的 Document 对象解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">2.2.5.</span> <span class="nav-text">¶BeanDefinitionParserDelegate 解析 Bean 定义资源文件中的&lt;Bean&gt;元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">2.2.6.</span> <span class="nav-text">¶BeanDefinitionParserDelegate 解析&lt;property&gt;元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">2.2.7.</span> <span class="nav-text">¶解析&lt;property&gt;元素的子元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">2.2.8.</span> <span class="nav-text">¶解析&lt;list&gt;子元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">2.2.9.</span> <span class="nav-text">¶解析过后的 BeanDefinition 在 IOC 容器中的注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">2.2.10.</span> <span class="nav-text">¶DefaultListableBeanFactory 向 IOC 容器注册解析后的 BeanDefinition</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">4.</span> <span class="nav-text">在使用 SpringIOC 容器的时候我们还需要区别两个概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">4.1.</span> <span class="nav-text">¶BeanFactory 和 FactoryBean</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#null"><span class="nav-number">4.1.0.0.1.</span> <span class="nav-text">¶springboot</span></a></li></ol></li></ol></li></ol></div></div></div><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Jeff-Eric</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0</div><span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.0.1</div></div></footer><div id="needsharebutton-float"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script><script id="ribbon" size="300" alpha="0.6" zindex="-1" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@2/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/npm/fastclick@1/lib/fastclick.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery-lazyload@1/jquery.lazyload.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three-waves.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_lines.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_sphere.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-reading-progress@1/reading_progress.min.js"></script><script src="/blog/js/src/utils.js?v=7.0.1"></script><script src="/blog/js/src/motion.js?v=7.0.1"></script><script src="/blog/js/src/affix.js?v=7.0.1"></script><script src="/blog/js/src/schemes/pisces.js?v=7.0.1"></script><script src="/blog/js/src/scrollspy.js?v=7.0.1"></script><script src="/blog/js/src/post-details.js?v=7.0.1"></script><script src="/blog/js/src/next-boot.js?v=7.0.1"></script><script src="/blog/js/src/js.cookie.js?v=7.0.1"></script><script src="/blog/js/src/scroll-cookie.js?v=7.0.1"></script><script src="//cdn.jsdelivr.net/npm/leancloud-storage@3/dist/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js"></script><script>var GUEST=["nick","mail","link"],guest="nick,mail,link";guest=guest.split(",").filter(function(e){return GUEST.indexOf(e)>-1}),new Valine({el:"#comments",verify:!0,notify:!1,appId:"MKGyMx7EafphCr9hAbMPAwAc-gzGzoHsz",appKey:"4SB8MPoE51bFPHDoKtPM8vLG",placeholder:"Just go go",avatar:"mm",meta:guest,pageSize:"10",visitor:!0})</script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var e=$("#local-search-input");e.attr("autocapitalize","none"),e.attr("autocorrect","off"),e.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/blog/"+search_path,onPopupClose=function(e){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(e,t,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:e,dataType:isXml?"xml":"json",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,r=document.getElementById(t),s=document.getElementById(o),a=function(){var e=r.value.trim().toLowerCase(),t=e.split(/[\s\-]+/);t.length>1&&t.push(e);var o=[];if(e.length>0&&n.forEach(function(n){function r(t,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===e&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(e,t){var o="",n=t.start;return t.hits.forEach(function(t){o+=e.substring(n,t.position);var r=t.position+t.length;o+='<b class="search-keyword">'+e.substring(t.position,r)+"</b>",n=r}),o+=e.substring(n,t.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url).replace(/\/{2,}/g,"/"),d=[],g=[];if(""!=l&&(t.forEach(function(e){function t(e,t,o){var n=e.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(t=t.toLowerCase(),e=e.toLowerCase());(s=t.indexOf(e,r))>-1;)a.push({position:s,word:e}),r=s+n;return a}d=d.concat(t(e,h,!1)),g=g.concat(t(e,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(e){e.sort(function(e,t){return t.position!==e.position?t.position-e.position:e.word.length-t.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hits.length!==t.hits.length?t.hits.length-e.hits.length:e.start-t.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(e){b+="<a href='"+f+'\'><p class="search-result">'+s(p,e)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===t.length&&""===t[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x"></i></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>';else{o.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hitCount!==t.hitCount?t.hitCount-e.hitCount:t.id-e.id});var a='<ul class="search-result-list">';o.forEach(function(e){a+=e.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(e){e.stopPropagation()}),$(document).on("keyup",function(e){var t=27===e.which&&$(".search-popup").is(":visible");t&&onPopupClose()})</script><script src="https://www.gstatic.com/firebasejs/4.6.0/firebase.js"></script><script src="https://www.gstatic.com/firebasejs/4.6.0/firebase-firestore.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/bluebird/3.5.1/bluebird.core.min.js"></script><script>!function(){function getCount(t,e){return t.get().then(function(a){var n;return a.exists?(n=a.data().count,e&&(window.localStorage&&window.localStorage.getItem(title)||(t.set({count:n+1}),n++))):e?(t.set({count:1}),n=1):n=0,window.localStorage&&e&&localStorage.setItem(title,!0),n})}function appendCountTo(t){return function(e){$(t).append($("<span>").addClass("post-visitors-count").append($("<span>").addClass("post-meta-divider").text("|")).append($("<span>").addClass("post-meta-item-icon").append($("<i>").addClass("fa fa-users"))).append($("<span>").text("阅读次数 "+e)))}}firebase.initializeApp({apiKey:"AIzaSyD-BIMnFQcvrv1utthoP5z5shcYP8JMKmY",projectId:"blog-6cbe0"});var db=firebase.firestore(),articles=db.collection("articles"),isPost="spring - IOC".length>0,isArchive=!1,isCategory="".length>0,isTag="".length>0;if(isPost){var title="spring - IOC",doc=articles.doc(title);getCount(doc,!0).then(appendCountTo($(".post-meta")))}else if(!isArchive&&!isCategory&&!isTag){var titles=[],postsstr="";eval(postsstr);var promises=titles.map(function(t){return articles.doc(t)}).map(function(t){return getCount(t)});Promise.all(promises).then(function(t){var e=$(".post-meta");t.forEach(function(t,a){appendCountTo(e[a])(t)})})}}()</script><style>.pdfobject-container{position:relative;overflow:auto;width:100%}</style><script>$("body").find("div.pdf").length&&$.ajax({type:"GET",url:"//cdn.jsdelivr.net/npm/pdfobject@2.1.1/pdfobject.min.js",dataType:"script",cache:!0,success:function(){$("body").find("div.pdf").each(function(e,t){PDFObject.embed($(t).attr("target"),$(t),{pdfOpenParams:{navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"},PDFJS_URL:"/lib/pdf/web/viewer.html",height:$(t).attr("height")||"500px"})})}})</script><script>$("body").find("pre.mermaid").length&&$.ajax({type:"GET",url:"//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js",dataType:"script",cache:!0,success:function(){mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})}})</script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script><script>pbOptions={},pbOptions.iconStyle="box",pbOptions.boxForm="horizontal",pbOptions.position="bottomCenter",pbOptions.networks="Weibo,Wechat,Douban,QQZone,Twitter,Facebook",new needShareButton("#needsharebutton-postbottom",pbOptions),flOptions={},flOptions.iconStyle="box",flOptions.boxForm="horizontal",flOptions.position="middleRight",flOptions.networks="Weibo,Wechat,Douban,QQZone,Twitter,Facebook",new needShareButton("#needsharebutton-float",flOptions)</script><script src="//cdn.jsdelivr.net/npm/pangu@3/dist/browser/pangu.min.js"></script><script>pangu.spacingPage()</script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@1/bookmark.min.js"></script><script>bookmark.scrollToMark("auto","#更多")</script><style>.copy-btn{display:inline-block;padding:6px 12px;font-size:13px;font-weight:700;line-height:20px;color:#333;white-space:nowrap;vertical-align:middle;cursor:pointer;background-color:#eee;background-image:linear-gradient(#fcfcfc,#eee);border:1px solid #d5d5d5;border-radius:3px;user-select:none;outline:0}.highlight-wrap .copy-btn{transition:opacity .3s ease-in-out;opacity:0;padding:2px 6px;position:absolute;right:4px;top:8px}.highlight-wrap .copy-btn:focus,.highlight-wrap:hover .copy-btn{opacity:1}.highlight-wrap{position:relative}</style><script>$(".highlight").each(function(t,e){var n=$("<div>").addClass("highlight-wrap");$(e).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(t){var e=$(this).parent().find(".code").find(".line").map(function(t,e){return $(e).text()}).toArray().join("\n"),n=document.createElement("textarea"),o=window.pageYOffset||document.documentElement.scrollTop;n.style.top=o+"px",n.style.position="absolute",n.style.opacity="0",n.readOnly=!0,n.value=e,document.body.appendChild(n),n.select(),n.setSelectionRange(0,e.length),n.readOnly=!1;var a=document.execCommand("copy");a?$(this).text("复制成功"):$(this).text("复制失败"),n.blur(),$(this).blur()})).on("mouseleave",function(t){var e=$(this).find(".copy-btn");setTimeout(function(){e.text("复制")},300)}).append(e)})</script></body></html><!-- rebuild by neat -->