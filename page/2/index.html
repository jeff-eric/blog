<!-- build time:Tue Nov 26 2019 14:32:24 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-CN,zh-HK,zh-TW,en,default"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/han-css@3/dist/han.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css"><link rel="stylesheet" href="/blog/css/main.css?v=7.0.1"><link rel="apple-touch-icon" sizes="180x180" href="/blog/uploads/avatar.jpg?v=7.0.1"><link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/avatar.jpg?v=7.0.1"><link rel="icon" type="image/png" sizes="16x16" href="/blog/blog/uploads/avatar.jpg?v=7.0.1"><link rel="mask-icon" href="/blog/uploads/avatar.jpg?v=7.0.1" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/blog/",scheme:"Gemini",version:"7.0.1",sidebar:{position:"left",display:"always",offset:12,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!0,fancybox:!0,fastclick:!0,lazyload:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta property="og:type" content="website"><meta property="og:title" content="纯天然绿色学渣"><meta property="og:url" content="https:&#x2F;&#x2F;jeff-eric.github.com&#x2F;blog&#x2F;page&#x2F;2&#x2F;index.html"><meta property="og:site_name" content="纯天然绿色学渣"><meta property="og:locale" content="zh-CN"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://jeff-eric.github.com/blog/page/2/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>纯天然绿色学渣</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?bb5d4f8207d7c2bd1aa936180430bbaa";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/blog/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">纯天然绿色学渣</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-home&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;首页</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-tags&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;标签&lt;span class=&quot;badge&quot;&gt;28&lt;&#x2F;span&gt;</a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-th&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;分类&lt;span class=&quot;badge&quot;&gt;12&lt;&#x2F;span&gt;</a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-archive&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;归档&lt;span class=&quot;badge&quot;&gt;42&lt;&#x2F;span&gt;</a></li><li class="menu-item menu-item-tools"><a href="/blog/tools/" rel="section">&lt;i class=&quot;menu-item-icon fa fa-fw fa-tree&quot;&gt;&lt;&#x2F;i&gt; &lt;br&#x2F;&gt;工具</a></li><li class="menu-item menu-item-search"><a href="javascript:;" target="_blank" rel="noopener" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jeff-eric.github.com/blog/blog/2019/10/22/spring%20-%20DI/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jeff-Eric"><meta itemprop="description" content=""><meta itemprop="image" content="/blog/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="纯天然绿色学渣"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/blog/2019/10/22/spring%20-%20DI/" class="post-title-link" itemprop="url">spring - DI</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-22 18:51:56" itemprop="dateCreated datePublished" datetime="2019-10-22T18:51:56+08:00">2019-10-22</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-11-14 14:46:22" itemprop="dateModified" datetime="2019-11-14T14:46:22+08:00">2019-11-14</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/blog/2019/10/22/spring%20-%20DI/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/2019/10/22/spring%20-%20DI/" itemprop="commentCount"></span> </a></span><span id="/blog/2019/10/22/spring%20-%20DI/" class="leancloud_visitors" data-flag-title="spring - DI"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body han-init-context" itemprop="articleBody"><h1><a id="_1"></a>依赖注入发生的时间</h1><p>当 Spring IOC 容器完成了 Bean 定义资源的定位、载入和解析注册以后，IOC 容器中已经管理类 Bean<br>定义的相关数据，但是此时 IOC 容器还没有对所管理的 Bean 进行依赖注入，依赖注入在以下两种情况<br>发生：</p><ul><li>用户第一次通过 getBean 方法向 IOC 容索要 Bean 时，IOC 容器触发依赖注入。</li><li>当用户在 Bean 定义资源中为<code>&lt;Bean&gt;</code>元素配置了 lazy-init 属性, 默认是false，即让容器在解析注册 Bean 定义时进行预实例化，触发依赖注入。<br>BeanFactory 接口定义了 Spring IOC 容器的基本功能规范，是 Spring IOC 容器所应遵守的最底层和<br>最基本的编程规范。BeanFactory 接口中定义了几个 getBean 方法，就是用户向 IOC 容器索取管理的 Bean<br>的方法，我们通过分析其子类的具体实现，理解 Spring IOC 容器在用户索取 Bean 时如何完成依赖注<br>入。<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191108193417.png" alt><br>在 BeanFactory 中我们看到 getBean（String…）函数，它的具体实现在 AbstractBeanFactory 中</li></ul><h1><a id="AbstractBeanFactory__getBean__IOC__Bean_14"></a>AbstractBeanFactory 通过 getBean 向 IOC 容器获取被管理的 Bean</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"> //获取 IOC 容器中指定名称的 Bean</span><br><span class="line"> public Object getBean(String name) throws BeansException &#123;</span><br><span class="line">     //doGetBean 才是真正向 IoC 容器获取被管理 Bean 的过程</span><br><span class="line">     return doGetBean(name, null, null, false);</span><br><span class="line"> &#125;</span><br><span class="line"> //获取 IOC 容器中指定名称和类型的 Bean</span><br><span class="line"> public &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException &#123;</span><br><span class="line">     //doGetBean 才是真正向 IoC 容器获取被管理 Bean 的过程</span><br><span class="line">     return doGetBean(name, requiredType, null, false);</span><br><span class="line"> &#125;</span><br><span class="line"> //获取 IOC 容器中指定名称和参数的 Bean</span><br><span class="line"> public Object getBean(String name, Object... args) throws BeansException &#123;</span><br><span class="line">     //doGetBean 才是真正向 IoC 容器获取被管理 Bean 的过程</span><br><span class="line">     return doGetBean(name, null, args, false);</span><br><span class="line"> &#125;</span><br><span class="line"> //获取 IOC 容器中指定名称、类型和参数的 Bean</span><br><span class="line"> public &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType, Object... args) throws BeansException &#123;</span><br><span class="line">     //doGetBean 才是真正向 IoC 容器获取被管理 Bean 的过程</span><br><span class="line">     return doGetBean(name, requiredType, args, false);</span><br><span class="line"> &#125;</span><br><span class="line"> //真正实现向 IOC 容器获取 Bean 的功能，也是触发依赖注入功能的地方</span><br><span class="line"> @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line"> protected &lt;T&gt; T doGetBean(</span><br><span class="line">         final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)</span><br><span class="line">         throws BeansException &#123;</span><br><span class="line">     //根据指定的名称获取被管理 Bean 的名称，剥离指定名称中对容器的相关依赖</span><br><span class="line">     //如果指定的是别名，将别名转换为规范的 Bean 名称</span><br><span class="line">     final String beanName = transformedBeanName(name);</span><br><span class="line">     Object bean;</span><br><span class="line">     //先从缓存中取是否已经有被创建过的单态类型的 Bean</span><br><span class="line">     //对于单例模式的 Bean 整个 IOC 容器中只创建一次，不需要重复创建</span><br><span class="line">     Object sharedInstance = getSingleton(beanName);</span><br><span class="line">     //IOC 容器创建单例模式 Bean 实例对象</span><br><span class="line">     if (sharedInstance != null &amp;&amp; args == null) &#123;</span><br><span class="line">         if (logger.isDebugEnabled()) &#123;</span><br><span class="line">             //如果指定名称的 Bean 在容器中已有单例模式的 Bean 被创建</span><br><span class="line">             //直接返回已经创建的 Bean</span><br><span class="line">             if (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                 logger.debug(&quot;Returning eagerly cached instance of singleton bean &apos;&quot; + beanName +</span><br><span class="line">                         &quot;&apos; that is not fully initialized yet - a consequence of a circular reference&quot;);</span><br><span class="line">             &#125;</span><br><span class="line">             else &#123;</span><br><span class="line">                 logger.debug(&quot;Returning cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos;&quot;);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         //获取给定 Bean 的实例对象，主要是完成 FactoryBean 的相关处理</span><br><span class="line">         //注意：BeanFactory 是管理容器中 Bean 的工厂，而 FactoryBean 是</span><br><span class="line">         //创建创建对象的工厂 Bean，两者之间有区别</span><br><span class="line">         bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);</span><br><span class="line">     &#125;</span><br><span class="line">     else &#123;</span><br><span class="line">         //缓存没有正在创建的单例模式 Bean</span><br><span class="line">         //缓存中已经有已经创建的原型模式 Bean</span><br><span class="line">         //但是由于循环引用的问题导致实例化对象失败</span><br><span class="line">         if (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">             throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">         //对 IOC 容器中是否存在指定名称的 BeanDefinition 进行检查，首先检查是否</span><br><span class="line">         //能在当前的 BeanFactory 中获取的所需要的 Bean，如果不能则委托当前容器</span><br><span class="line">         //的父级容器去查找，如果还是找不到则沿着容器的继承体系向父级容器查找</span><br><span class="line">         // 为什么要委托父容器去找呢？</span><br><span class="line">// ioc容器是可以被关联的：FileSystemXmlApplicationContext(String[] configLocations, ApplicationContext parent)</span><br><span class="line">         BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">         //当前容器的父级容器存在，且当前容器中不存在指定名称的 Bean</span><br><span class="line">         if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">             //解析指定 Bean 名称的原始名称</span><br><span class="line">             // 因为有可能是通过别名去获取bean</span><br><span class="line">             String nameToLookup = originalBeanName(name);</span><br><span class="line">             if (args != null) &#123;</span><br><span class="line">                 //委派父级容器根据指定名称和显式的参数查找</span><br><span class="line">                 // 为什么不传类型再去校验一次？</span><br><span class="line">		// 因为这一步是强转成T ， 如果类型不一样, 在后续的调用中会报错ClassCastException</span><br><span class="line">                 return (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">             &#125;</span><br><span class="line">             else &#123;</span><br><span class="line">                 //委派父级容器根据指定名称和类型查找</span><br><span class="line">                 return parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         //如果不是只检查类型，那就标记这个Bean被创建了~~添加到缓存里 也就是所谓的  当前创建Bean池</span><br><span class="line">         if (!typeCheckOnly) &#123;</span><br><span class="line">             //向容器标记指定的 Bean 已经被创建</span><br><span class="line">             markBeanAsCreated(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">         //根据指定 Bean 名称获取其父级的 Bean 定义</span><br><span class="line">         //主要解决 Bean 继承时子类合并父类公共属性问题</span><br><span class="line">         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">         checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">         //获取当前 Bean 所有依赖 Bean 的名称</span><br><span class="line">         String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">         //如果当前 Bean 有依赖 Bean</span><br><span class="line">         if (dependsOn != null) &#123;</span><br><span class="line">             for (String dependsOnBean : dependsOn) &#123;</span><br><span class="line">                 //递归调用 getBean 方法，获取当前 Bean 的依赖 Bean</span><br><span class="line">                 getBean(dependsOnBean);</span><br><span class="line">                 //把被依赖 Bean 注册给当前依赖的 Bean</span><br><span class="line">                 registerDependentBean(dependsOnBean, beanName);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         //创建单例模式 Bean 的实例对象</span><br><span class="line">         if (mbd.isSingleton()) &#123;</span><br><span class="line">             //这里使用了一个匿名内部类，创建 Bean 实例对象，并且注册给所依赖的对象</span><br><span class="line">             sharedInstance = getSingleton(beanName, new ObjectFactory() &#123;</span><br><span class="line">                 public Object getObject() throws BeansException &#123;</span><br><span class="line">                     try &#123;</span><br><span class="line">                         //创建一个指定 Bean 实例对象，如果有父级继承，则合并子类和父类的定义</span><br><span class="line">                         return createBean(beanName, mbd, args);</span><br><span class="line">                     &#125;</span><br><span class="line">                     catch (BeansException ex) &#123;</span><br><span class="line">                         //显式地从容器单例模式 Bean 缓存中清除实例对象</span><br><span class="line">                         destroySingleton(beanName);</span><br><span class="line">                         throw ex;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">             //获取给定 Bean 的实例对象</span><br><span class="line">             bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line">         //IOC 容器创建原型模式 Bean 实例对象</span><br><span class="line">         else if (mbd.isPrototype()) &#123;</span><br><span class="line">             //原型模式(Prototype)是每次都会创建一个新的对象</span><br><span class="line">             Object prototypeInstance = null;</span><br><span class="line">             try &#123;</span><br><span class="line">                 //回调 beforePrototypeCreation 方法，默认的功能是注册当前创//建的原型对象</span><br><span class="line">                 beforePrototypeCreation(beanName);</span><br><span class="line">                 //创建指定 Bean 对象实例</span><br><span class="line">                 prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">             &#125;</span><br><span class="line">             finally &#123;</span><br><span class="line">                 //回调 afterPrototypeCreation 方法，默认的功能告诉 IoC 容器指定 Bean 的原型对象不再创建了</span><br><span class="line">                 //就是该bean已经从ing状态变成了ed状态</span><br><span class="line">                 afterPrototypeCreation(beanName);</span><br><span class="line">             &#125;</span><br><span class="line">             //获取给定 Bean 的实例对象</span><br><span class="line">             bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line">         //要创建的 Bean 既不是单例模式，也不是原型模式，则根据 Bean 定义资源中</span><br><span class="line">         //配置的生命周期范围，选择实例化 Bean 的合适方法，这种在 Web 应用程序中</span><br><span class="line">         //比较常用，如：request、session、application 等生命周期</span><br><span class="line">         else &#123;</span><br><span class="line">             String scopeName = mbd.getScope();</span><br><span class="line">             //其实scopt也是用map去管理的, 这样的很多地方就能理解通了</span><br><span class="line">             //private final Map&lt;String, Scope&gt; scopes = new HashMap&lt;String, Scope&gt;(8);</span><br><span class="line">             final Scope scope = this.scopes.get(scopeName);</span><br><span class="line">             //Bean 定义资源中没有配置生命周期范围，则 Bean 定义不合法</span><br><span class="line">             if (scope == null) &#123;</span><br><span class="line">                 throw new IllegalStateException(&quot;No Scope registered for scope &apos;&quot; + scopeName + &quot;&apos;&quot;);</span><br><span class="line">             &#125;</span><br><span class="line">             try &#123;</span><br><span class="line">                 //这里又使用了一个匿名内部类，获取一个指定生命周期范围的实例</span><br><span class="line">                 Object scopedInstance = scope.get(beanName, new ObjectFactory() &#123;</span><br><span class="line">                     public Object getObject() throws BeansException &#123;</span><br><span class="line">                         beforePrototypeCreation(beanName);</span><br><span class="line">                         try &#123;</span><br><span class="line">                             return createBean(beanName, mbd, args);</span><br><span class="line">                         &#125;</span><br><span class="line">                         finally &#123;</span><br><span class="line">                             afterPrototypeCreation(beanName);</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;);</span><br><span class="line">                 //获取给定 Bean 的实例对象</span><br><span class="line">                 bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">             &#125;</span><br><span class="line">             catch (IllegalStateException ex) &#123;</span><br><span class="line">                 throw new BeanCreationException(beanName,</span><br><span class="line">                         &quot;Scope &apos;&quot; + scopeName + &quot;&apos; is not active for the current thread; &quot; +</span><br><span class="line">                                 &quot;consider defining a scoped proxy for this bean if you intend to refer to</span><br><span class="line">                         it from a singleton&quot;,</span><br><span class="line">                         ex);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     //对创建的 Bean 实例对象进行类型检查</span><br><span class="line">     if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass()))</span><br><span class="line">     &#123;</span><br><span class="line">         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">     &#125;</span><br><span class="line">     return (T) bean;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">protected Object getObjectForBeanInstance(</span><br><span class="line">			Object beanInstance, String name, String beanName, RootBeanDefinition mbd) &#123;</span><br><span class="line"></span><br><span class="line">		// Don&apos;t let calling code try to dereference the factory if the bean isn&apos;t a factory.</span><br><span class="line">		// name 是否是工厂bean标记</span><br><span class="line">		// beanInstance 是否继承factoryBean</span><br><span class="line">		if (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance instanceof FactoryBean)) &#123;</span><br><span class="line">			throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Now we have the bean instance, which may be a normal bean or a FactoryBean.</span><br><span class="line">		// If it&apos;s a FactoryBean, we use it to create a bean instance, unless the</span><br><span class="line">		// caller actually wants a reference to the factory.</span><br><span class="line">		// 1、true || false 普通类 纯的普通类</span><br><span class="line">		// 2、false || true  工厂类 纯的工厂</span><br><span class="line">		// 3、false || false 普通类 没有定义为工厂的普通工厂类</span><br><span class="line">		if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">			return beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object object = null;</span><br><span class="line">		if (mbd == null) &#123;</span><br><span class="line">			object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		if (object == null) &#123;</span><br><span class="line">			// Return bean instance from factory.</span><br><span class="line">			FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">			// Caches object obtained from FactoryBean if it is a singleton.</span><br><span class="line">			if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">				mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			// 是否是合成的，意思就是是否当做工具类来使用</span><br><span class="line">			// 这里的synthetic实际上是为了给用户自定义一些BeanDefinition注册到容器中以当作工具类来使用。</span><br><span class="line">			// 什么是synthetic</span><br><span class="line">			// 就是内部类，java在编译的时候内部类也会编译成单独的一个文件，那实际上，原始类及时两个类的合成类</span><br><span class="line">			// 工具类就没有必要做一些封装、代理等工作，实际上是拿来就用，没有其他处理</span><br><span class="line">			// 对于synthetic类型的BeanDefinition，getObjectFromFactoryBean中是不会对FactoryBean生成的bean用post-processor进行后置处理的。</span><br><span class="line">			// 后置处理的实现是在AbstractAutowireCapableBeanFactory.postProcessObjectFromFactoryBean中，</span><br><span class="line">			// 它会调用容器中的BeanPostProcessor.postProcessAfterInitialization,这里提供了一个扩展点对FactoryBean生成的bean进行封装，代理等</span><br><span class="line">			boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic());</span><br><span class="line">			// bean实例化的缓存</span><br><span class="line">            // private final Map&lt;String, Object&gt; factoryBeanObjectCache = new ConcurrentHashMap&lt;String, Object&gt;(16);</span><br><span class="line">			object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">		&#125;</span><br><span class="line">		return object;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//对 FactoryBean 的转义定义，因为如果使用 bean 的名字检索 FactoryBean 得到的对象是工厂生成的对象，</span><br><span class="line">	//如果需要得到工厂本身，需要转义</span><br><span class="line">	String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;</span><br><span class="line">public static boolean isFactoryDereference(String name) &#123;</span><br><span class="line">		return (name != null &amp;&amp; name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private final ThreadLocal&lt;Object&gt; prototypesCurrentlyInCreation =</span><br><span class="line">			new NamedThreadLocal&lt;Object&gt;(&quot;Prototype beans currently in creation&quot;);</span><br><span class="line">protected boolean isPrototypeCurrentlyInCreation(String beanName) &#123;</span><br><span class="line">		Object curVal = this.prototypesCurrentlyInCreation.get();</span><br><span class="line">		return (curVal != null &amp;&amp;</span><br><span class="line">				(curVal.equals(beanName) || (curVal instanceof Set &amp;&amp; ((Set&lt;?&gt;) curVal).contains(beanName))));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protected void beforePrototypeCreation(String beanName) &#123;</span><br><span class="line">		Object curVal = this.prototypesCurrentlyInCreation.get();</span><br><span class="line">		if (curVal == null) &#123;</span><br><span class="line">			this.prototypesCurrentlyInCreation.set(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		else if (curVal instanceof String) &#123;</span><br><span class="line">			Set&lt;String&gt; beanNameSet = new HashSet&lt;String&gt;(2);</span><br><span class="line">			beanNameSet.add((String) curVal);</span><br><span class="line">			beanNameSet.add(beanName);</span><br><span class="line">			this.prototypesCurrentlyInCreation.set(beanNameSet);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			Set&lt;String&gt; beanNameSet = (Set&lt;String&gt;) curVal;</span><br><span class="line">			beanNameSet.add(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected void afterPrototypeCreation(String beanName) &#123;</span><br><span class="line">		Object curVal = this.prototypesCurrentlyInCreation.get();</span><br><span class="line">		if (curVal instanceof String) &#123;</span><br><span class="line">			this.prototypesCurrentlyInCreation.remove();</span><br><span class="line">		&#125;</span><br><span class="line">		else if (curVal instanceof Set) &#123;</span><br><span class="line">			Set&lt;String&gt; beanNameSet = (Set&lt;String&gt;) curVal;</span><br><span class="line">			beanNameSet.remove(beanName);</span><br><span class="line">			if (beanNameSet.isEmpty()) &#123;</span><br><span class="line">				this.prototypesCurrentlyInCreation.remove();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>通过上面对向 IOC 容器获取 Bean 方法的分析，我们可以看到在 Spring 中，如果 Bean 定义的单例模式<br>(Singleton)，则容器在创建之前先从缓存中查找，以确保整个容器中只存在一个实例对象。如果 Bean<br>定义的是原型模式(Prototype)，则容器每次都会创建一个新的实例对象。除此之外，Bean 定义还可以<br>扩展为指定其生命周期范围。</p><p>上面的源码只是定义了根据 Bean 定义的模式，采取的不同创建 Bean 实例对象的策略，具体的 Bean 实<br>例对象的创建过程由实现了 ObejctFactory 接口的匿名内部类的 createBean 方法完成，ObejctFactory<br>使用委派模式，具体的 Bean 实例创建过程交由其实现类 AbstractAutowireCapableBeanFactory 完成，<br>我们继续分析 AbstractAutowireCapableBeanFactory 的 createBean 方法的源码，理解其创建 Bean 实<br>例的具体实现过程。</p><h1><a id="_37"></a>循环依赖的产生和解决的前提</h1><ul><li>A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象</li><li>A的构造方法中依赖了B的实例对象，同时B的某个field或者setter需要A的实例对象</li><li>A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象<br>当然，Spring对于循环依赖的解决不是无条件的，首先前提条件是针对scope单例并且没有显式指明不需要解决循环依赖的对象，而且要求该对象没有被代理过。同时Spring解决循环依赖也不是万能，以上三种情况只能解决两种，第一种在构造方法中相互依赖的情况Spring也无力回天。结论先给在这，下面来看看Spring的解决方法，知道了解决方案就能明白为啥第一种情况无法解决了。<br>Spring单例对象的初始化其实可以分为三步：</li><li>createBeanInstance， 实例化，实际上就是调用对应的构造方法构造对象，此时只是调用了构造方法，spring xml中指定的property并没有进行populate</li><li>populateBean 填充属性，这步对spring xml中指定的property进行populate</li><li>initializeBean 调用spring xml中指定的init方法，或者AfterPropertiesSet方法会发生循环依赖的步骤集中在第一步和第二步。</li></ul><h2><a id="_47"></a><a class="header-anchor" href="#三级缓存">¶</a>三级缓存</h2><p>对于单例对象来说，在Spring的整个容器的生命周期内，有且只存在一个对象，很容易想到这个对象应该存在Cache中，Spring大量运用了Cache的手段，在循环依赖问题的解决过程中甚至使用了“三级缓存”。<br>“三级缓存”主要是指</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 完美并且已经在使用的bean</span><br><span class="line">/** Cache of singleton objects: bean name --&gt; bean instance */</span><br><span class="line">private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(256);</span><br><span class="line">// bean的工厂方法</span><br><span class="line">/** Cache of early singleton objects: bean name --&gt; bean instance */</span><br><span class="line">private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;String, Object&gt;(16);</span><br><span class="line">// 新创建或不完美的bean</span><br><span class="line">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span><br><span class="line">private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(16);</span><br></pre></td></tr></table></figure><p>从字面意思来说：singletonObjects指单例对象的cache，singletonFactories指单例对象工厂的cache，earlySingletonObjects指提前曝光的单例对象的cache。以上三个cache构成了三级缓存，Spring就用这三级缓存巧妙的解决了循环依赖问题。<br>首先Spring会尝试从缓存中获取，这个缓存就是指singletonObjects，主要调用的方法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class="line">   Object singletonObject = this.singletonObjects.get(beanName);</span><br><span class="line">   if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      synchronized (this.singletonObjects) &#123;</span><br><span class="line">         singletonObject = this.earlySingletonObjects.get(beanName);</span><br><span class="line">         if (singletonObject == null &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">            ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);</span><br><span class="line">            if (singletonFactory != null) &#123;</span><br><span class="line">               singletonObject = singletonFactory.getObject();</span><br><span class="line">               this.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">               this.singletonFactories.remove(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return (singletonObject != NULL_OBJECT ? singletonObject : null);&#125;</span><br></pre></td></tr></table></figure><p>首先解释两个参数：</p><ul><li>isSingletonCurrentlyInCreation 判断对应的单例对象是否在创建中，当单例对象没有被初始化完全(例如A定义的构造函数依赖了B对象，得先去创建B对象，或者在populatebean过程中依赖了B对象，得先去创建B对象，此时A处于创建中)</li><li>allowEarlyReference 是否允许从singletonFactories中通过getObject拿到对象，其实就是是否允许我重新创建一个</li></ul><p>分析getSingleton的整个过程，Spring首先从singletonObjects（一级缓存）中尝试获取，如果获取不到并且对象在创建中，则尝试从earlySingletonObjects(二级缓存)中获取，如果还是获取不到并且允许从singletonFactories通过getObject获取，则通过singletonFactory.getObject()(三级缓存)获取。如果获取到了则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">this.singletonFactories.remove(beanName);</span><br></pre></td></tr></table></figure><p>Spring解决循环依赖的诀窍就在于singletonFactories这个cache，这个cache中存的是类型为ObjectFactory，其定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface ObjectFactory&lt;T&gt; &#123;</span><br><span class="line">    T getObject() throws BeansException;&#125;</span><br></pre></td></tr></table></figure><p>在bean创建过程中，有两处比较重要的匿名内部类实现了该接口。一处是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">   @Override   public Object getObject() throws BeansException &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         return createBean(beanName, mbd, args);</span><br><span class="line">      &#125;      catch (BeansException ex) &#123;</span><br><span class="line">         destroySingleton(beanName);</span><br><span class="line">         throw ex;</span><br><span class="line">      &#125;   &#125;</span><br></pre></td></tr></table></figure><p>另一处就是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">   @Override   public Object getObject() throws BeansException &#123;</span><br><span class="line">      return getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">   &#125;&#125;);</span><br></pre></td></tr></table></figure><p>此处就是解决循环依赖的关键，这段代码发生在createBeanInstance之后，也就是说单例对象此时已经被创建出来的。这个对象已经被生产出来了，虽然还不完美（还没有进行初始化的第二步和第三步），但是已经能被人认出来了（根据对象引用能定位到堆中的对象），所以Spring此时将这个对象提前曝光出来让大家认识，让大家使用。</p><p>这样做有什么好处呢？让我们来分析一下“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。A首先完成了初始化的第一步，并且将自己提前曝光到singletonFactories中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程，B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，长大成人，进去了一级缓存singletonObjects中，而且更加幸运的是，由于B拿到了A的对象引用，所以B现在hold住的A对象也蜕变完美了！</p><p>知道了这个原理时候，肯定就知道为啥Spring不能解决“A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象”这类问题了！</p><h1><a id="AbstractAutowireCapableBeanFactory__Bean__74"></a>AbstractAutowireCapableBeanFactory 创建 Bean 实例对象</h1><p>AbstractAutowireCapableBeanFactory 类实现了 ObejctFactory 接口，创建容器指定的 Bean 实例对象，<br>同时还对创建的 Bean 实例对象进行初始化处理。其创建 Bean 实例对象的方法源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">  //创建 Bean 实例对象</span><br><span class="line">  protected Object createBean(final String beanName, final RootBeanDefinition mbd, final Object[]</span><br><span class="line">          args)</span><br><span class="line">          throws BeanCreationException &#123;</span><br><span class="line">      if (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(&quot;Creating instance of bean &apos;&quot; + beanName + &quot;&apos;&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      //判断需要创建的 Bean 是否可以实例化，即是否可以通过当前的类加载器加载</span><br><span class="line">      resolveBeanClass(mbd, beanName);</span><br><span class="line">      //校验和准备 Bean 中的方法覆盖</span><br><span class="line">//除了原型模式，其他的bean基本上都会使用代理去创建</span><br><span class="line">//默认使用cglib创建代理，好处就是spring有了代理类的控制权，同时也兼容接口代理</span><br><span class="line">      try &#123;</span><br><span class="line">          mbd.prepareMethodOverrides();</span><br><span class="line">      &#125;</span><br><span class="line">      catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">          throw new BeanDefinitionStoreException(mbd.getResourceDescription(),</span><br><span class="line">                  beanName, &quot;Validation of method overrides failed&quot;, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      try &#123;</span><br><span class="line">          //如果 Bean 配置了初始化前和初始化后的处理器，则试图返回一个需要创建 Bean 的代理对象</span><br><span class="line">          Object bean = resolveBeforeInstantiation(beanName, mbd);</span><br><span class="line">          if (bean != null) &#123;</span><br><span class="line">              return bean;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Throwable ex) &#123;</span><br><span class="line">          throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      //创建 Bean 的入口</span><br><span class="line">      Object beanInstance = doCreateBean(beanName, mbd, args);</span><br><span class="line">      if (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(&quot;Finished creating instance of bean &apos;&quot; + beanName + &quot;&apos;&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      return beanInstance;</span><br><span class="line">  &#125;</span><br><span class="line">  //真正创建 Bean 的方法</span><br><span class="line">  protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[]</span><br><span class="line">          args) &#123;</span><br><span class="line">      //封装被创建的 Bean 对象</span><br><span class="line">      BeanWrapper instanceWrapper = null;</span><br><span class="line">      if (mbd.isSingleton())&#123;</span><br><span class="line">          //单例模式的 Bean，先从容器中缓存中获取同名 Bean</span><br><span class="line">          instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      if (instanceWrapper == null) &#123;</span><br><span class="line">          //创建实例对象</span><br><span class="line">	//生成 Bean 所包含的 java 对象实例</span><br><span class="line">          instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">      &#125;</span><br><span class="line">      final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);</span><br><span class="line">      //获取实例化对象的类型</span><br><span class="line">      Class beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);</span><br><span class="line">      //调用 PostProcessor 后置处理器</span><br><span class="line">//就是类似aware监听器一样，监听对象什么时候初始化成功</span><br><span class="line">      synchronized (mbd.postProcessingLock) &#123;</span><br><span class="line">          if (!mbd.postProcessed) &#123;</span><br><span class="line">              applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">              mbd.postProcessed = true;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // Eagerly cache singletons to be able to resolve circular references</span><br><span class="line">      //向容器中缓存单例模式的 Bean 对象，以防循环引用</span><br><span class="line">      boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class="line">              isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">      //earlySingletonExposure：如果你的bean允许被早期暴露出去 也就是说可以被循环引用  那这里就会进行检查</span><br><span class="line">      if (earlySingletonExposure) &#123;</span><br><span class="line">          if (logger.isDebugEnabled()) &#123;</span><br><span class="line">              logger.debug(&quot;Eagerly caching bean &apos;&quot; + beanName +</span><br><span class="line">                      &quot;&apos; to allow for resolving potential circular references&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          //这里是一个匿名内部类，为了防止循环引用，尽早持有对象的引用</span><br><span class="line">          addSingletonFactory(beanName, new ObjectFactory() &#123;</span><br><span class="line">              public Object getObject() throws BeansException &#123;</span><br><span class="line">                  return getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      //Bean 对象的初始化，依赖注入在此触发</span><br><span class="line">      //这个 exposedObject 在初始化完成之后返回作为依赖注入完成后的 Bean</span><br><span class="line">      Object exposedObject = bean;</span><br><span class="line">      try &#123;</span><br><span class="line">          //将 Bean 实例对象封装，并且 Bean 定义中配置的属性值赋值给实例对象</span><br><span class="line">	//对 Bean 属性的依赖注入进行处理。</span><br><span class="line">          populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">          if (exposedObject != null) &#123;</span><br><span class="line">              //初始化 Bean 对象</span><br><span class="line">              exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Throwable ex) &#123;</span><br><span class="line">          if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException)</span><br><span class="line">                  ex).getBeanName())) &#123;</span><br><span class="line">              throw (BeanCreationException) ex;</span><br><span class="line">          &#125;</span><br><span class="line">          else &#123;</span><br><span class="line">              throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                      &quot;Initialization of bean failed&quot;, ex);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //此时一级缓存肯定还没数据，但是呢此时候二级缓存earlySingletonObjects也没数据</span><br><span class="line">      if (earlySingletonExposure) &#123;</span><br><span class="line">          //获取指定名称的已注册的单例模式 Bean 对象</span><br><span class="line">          //此时一级缓存肯定还没数据，但是呢此时候二级缓存earlySingletonObjects也没数据</span><br><span class="line">          //第二参数为false  表示不会再去三级缓存里查了~~~</span><br><span class="line">          Object earlySingletonReference = getSingleton(beanName, false);</span><br><span class="line">          if (earlySingletonReference != null) &#123;</span><br><span class="line">              //根据名称获取的已注册的 Bean 和正在实例化的 Bean 是同一个</span><br><span class="line">              if (exposedObject == bean) &#123;</span><br><span class="line">                  //当前实例化的 Bean 初始化完成</span><br><span class="line">                  exposedObject = earlySingletonReference;</span><br><span class="line">              &#125;</span><br><span class="line">              //当前 Bean 依赖其他 Bean，并且当发生循环引用时不允许新创建实例对象</span><br><span class="line">              // allowRawInjectionDespiteWrapping这个值默认是false</span><br><span class="line">		// hasDependentBean：若它有依赖的bean 那就需要继续校验了~~~(若没有依赖的 就放过它~)</span><br><span class="line">              else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                  String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                  Set&lt;String&gt; actualDependentBeans = new</span><br><span class="line">                          LinkedHashSet&lt;String&gt;(dependentBeans.length);</span><br><span class="line">                  //获取当前 Bean 所依赖的其他 Bean</span><br><span class="line">                  // 一个个检查它所以Bean</span><br><span class="line">			// removeSingletonIfCreatedForTypeCheckOnly这个放见下面  在AbstractBeanFactory里面</span><br><span class="line">			// 简单的说，它如果判断到该dependentBean并没有在创建中的了的情况下,那就把它从所有缓存中移除~~~  并且返回true</span><br><span class="line">			// 否则（比如确实在创建中） 那就返回false 进入我们的if里面~  表示所谓的真正依赖</span><br><span class="line">			//（解释：就是真的需要依赖它先实例化，才能实例化自己的依赖）</span><br><span class="line">                  for (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                      //对依赖 Bean 进行类型检查</span><br><span class="line">                      if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                          actualDependentBeans.add(dependentBean);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  if (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                      throw new BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                              &quot;Bean with name &apos;&quot; + beanName + &quot;&apos; has been injected into other beans</span><br><span class="line">                                      [&quot; +</span><br><span class="line">                              StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                                      &quot;] in its raw version as part of a circular reference, but has eventually</span><br><span class="line">                              been &quot; +</span><br><span class="line">                              &quot;wrapped. This means that said other beans do not use the final version</span><br><span class="line">                              of the &quot; +</span><br><span class="line">                              &quot;bean. This is often the result of over-eager type matching - consider</span><br><span class="line">                              using &quot; +</span><br><span class="line">                              &quot;&apos;getBeanNamesOfType&apos; with the &apos;allowEagerInit&apos; flag turned off, for</span><br><span class="line">                              example.&quot;);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //注册完成依赖注入的 Bean</span><br><span class="line">      try &#123;</span><br><span class="line">          registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">      catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">          throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Invalid</span><br><span class="line">                  destruction signature&quot;, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      return exposedObject;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191114115523.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/ 虽然是remove方法 但是它的返回值也非常重要</span><br><span class="line">// 该方法唯一调用的地方就是循环依赖的最后检查处</span><br><span class="line">protected boolean removeSingletonIfCreatedForTypeCheckOnly(String beanName) &#123;</span><br><span class="line">        // 如果这个bean不在创建中  比如是ForTypeCheckOnly的  那就移除掉</span><br><span class="line">		if (!this.alreadyCreated.containsKey(beanName)) &#123;</span><br><span class="line">			removeSingleton(beanName);</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>通过对方法源码的分析，我们看到具体的依赖注入实现在以下两个方法中：</p><ul><li>createBeanInstance：生成 Bean 所包含的 java 对象实例</li><li>populateBean ：对 Bean 属性的依赖注入进行处理。</li></ul><h1><a id="createBeanInstance__Bean__java__86"></a>createBeanInstance 方法创建 Bean 的 java 实例对象</h1><p>在 createBeanInstance 方法中，根据指定的初始化策略，使用静态工厂、工厂方法或者容器的自动装<br>配特性生成 java 实例对象，创建对象的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">//创建 Bean 的实例对象</span><br><span class="line">protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args)</span><br><span class="line">&#123;</span><br><span class="line">    //检查确认 Bean 是可实例化的</span><br><span class="line">    Class beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    //使用工厂方法对 Bean 进行实例化</span><br><span class="line">    if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers())</span><br><span class="line">            &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">        throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                &quot;Bean class isn&apos;t public, and non-public access not allowed: &quot; +</span><br><span class="line">                        beanClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    if (mbd.getFactoryMethodName() != null) &#123;</span><br><span class="line">        //调用工厂方法实例化</span><br><span class="line">        return instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    //使用容器的自动装配方法进行实例化</span><br><span class="line">    boolean resolved = false;</span><br><span class="line">    boolean autowireNecessary = false;</span><br><span class="line">    if (args == null) &#123;</span><br><span class="line">        synchronized (mbd.constructorArgumentLock) &#123;</span><br><span class="line">            if (mbd.resolvedConstructorOrFactoryMethod != null) &#123;</span><br><span class="line">                resolved = true;</span><br><span class="line">                autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (resolved) &#123;</span><br><span class="line">        if (autowireNecessary) &#123;</span><br><span class="line">            //配置了自动装配属性，使用容器的自动装配实例化</span><br><span class="line">            //容器的自动装配是根据参数类型匹配 Bean 的构造方法</span><br><span class="line">            return autowireConstructor(beanName, mbd, null, null);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            //使用默认的无参构造方法实例化</span><br><span class="line">            return instantiateBean(beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //使用 Bean 的构造方法进行实例化</span><br><span class="line">    Constructor[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">    if (ctors != null ||</span><br><span class="line">            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">            mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">        //使用容器的自动装配特性，调用匹配的构造方法实例化</span><br><span class="line">        return autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">    &#125;</span><br><span class="line">    //使用默认的无参构造方法实例化</span><br><span class="line">    return instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">//使用默认的无参构造方法实例化 Bean 对象</span><br><span class="line">protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Object beanInstance;</span><br><span class="line">        final BeanFactory parent = this;</span><br><span class="line">        //获取系统的安全管理接口，JDK 标准的安全管理 API</span><br><span class="line">        if (System.getSecurityManager() != null) &#123;</span><br><span class="line">            //这里是一个匿名内置类，根据实例化策略创建实例对象</span><br><span class="line">            beanInstance = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                public Object run() &#123;</span><br><span class="line">                    return getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            //将实例化的对象封装起来</span><br><span class="line">            beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">        &#125;</span><br><span class="line">        BeanWrapper bw = new BeanWrapperImpl(beanInstance);</span><br><span class="line">        initBeanWrapper(bw);</span><br><span class="line">        return bw;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable ex) &#123;</span><br><span class="line">        throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Instantiation of</span><br><span class="line">                bean failed&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过对上面的代码分析，我们可以看出，对使用工厂方法和自动装配特性的 Bean 的实例化相当比较清<br>楚，调用相应的工厂方法或者参数匹配的构造方法即可完成实例化对象的工作，但是对于我们最常使用<br>的默认无参构造方法就需要使用相应的初始化策略(JDK 的反射机制或者 CGLIB)来进行初始化了，在方<br>法 getInstantiationStrategy().instantiate 中就具体实现类使用初始策略实例化对象</p><h1><a id="SimpleInstantiationStrategy__Bean__95"></a>SimpleInstantiationStrategy 类使用默认的无参构造方法创建 Bean 实例化对象</h1><p>在使用默认的无参构造方法创建Bean的实例化对象时，方法getInstantiationStrategy().instantiate<br>调用了 SimpleInstantiationStrategy 类中的实例化 Bean 的方法，其源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">  //使用初始化策略实例化 Bean 对象</span><br><span class="line">  public Object instantiate(RootBeanDefinition beanDefinition, String beanName, BeanFactory owner)</span><br><span class="line">  &#123;</span><br><span class="line">      //如果 Bean 定义中没有方法覆盖，则就不需要 CGLIB </span><br><span class="line">//那么是什么条件才会触发这个MethodOverrides呢？</span><br><span class="line">//其实是Spring配置文件中的lookup-method和replace-method，</span><br><span class="line">//这其实是两个方法级别的注入，和一般的属性(Property)注入是不一样的，</span><br><span class="line">//它们注入的是方法(Method)。</span><br><span class="line">//两者的差别是这样的</span><br><span class="line">//如果需要替换的方法没有返回值，那么只能使用replace-method来替换，而不能用lookup-method来替换。</span><br><span class="line">//replace-method必须实现MethodReplacer接口的Bean才能替换，而lookup-method则由BeanFactory自动为我们处理了。，</span><br><span class="line">      if (beanDefinition.getMethodOverrides().isEmpty()) &#123;</span><br><span class="line">          Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">          synchronized (beanDefinition.constructorArgumentLock) &#123;</span><br><span class="line">              //获取对象的构造方法或工厂方法</span><br><span class="line">              constructorToUse = (Constructor&lt;?&gt;)</span><br><span class="line">                      beanDefinition.resolvedConstructorOrFactoryMethod;</span><br><span class="line">              //如果没有构造方法且没有工厂方法</span><br><span class="line">              if (constructorToUse == null) &#123;</span><br><span class="line">                  //使用 JDK 的反射机制，判断要实例化的 Bean 是否是接口</span><br><span class="line">                  final Class clazz = beanDefinition.getBeanClass();</span><br><span class="line">                  if (clazz.isInterface()) &#123;</span><br><span class="line">                      throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;);</span><br><span class="line">                  &#125;</span><br><span class="line">                  try &#123;</span><br><span class="line">                      if (System.getSecurityManager() != null) &#123;</span><br><span class="line">                          //这里是一个匿名内置类，使用反射机制获取 Bean 的构造方法</span><br><span class="line">                          constructorToUse = AccessController.doPrivileged(new</span><br><span class="line">                                                                                   PrivilegedExceptionAction&lt;Constructor&gt;() &#123;</span><br><span class="line">                                                                                       public Constructor run() throws Exception &#123;</span><br><span class="line">                                                                                           return clazz.getDeclaredConstructor((Class[]) null);</span><br><span class="line">                                                                                       &#125;</span><br><span class="line">                                                                                   &#125;);</span><br><span class="line">                      &#125;</span><br><span class="line">                      else &#123;</span><br><span class="line">                          constructorToUse = clazz.getDeclaredConstructor((Class[]) null);</span><br><span class="line">                      &#125;</span><br><span class="line">                      beanDefinition.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">                  &#125;</span><br><span class="line">                  catch (Exception ex) &#123;</span><br><span class="line">                      throw new BeanInstantiationException(clazz, &quot;No default constructor found&quot;,</span><br><span class="line">                              ex);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          //使用 BeanUtils 实例化，通过反射机制调用”构造方法.newInstance(arg)”来进行实例化</span><br><span class="line">          return BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">          //使用 CGLIB 来实例化对象</span><br><span class="line">          return instantiateWithMethodInjection(beanDefinition, beanName, owner);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码分析，我们看到了如果 Bean 有方法被覆盖了，则使用 JDK 的反射机制进行实例化，否<br>则，使用 CGLIB 进行实例化。</p><p>instantiateWithMethodInjection 方法调用 SimpleInstantiationStrategy 的子类<br>CglibSubclassingInstantiationStrategy 使用 CGLIB 来进行初始化，其源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//使用 CGLIB 进行 Bean 对象实例化</span><br><span class="line">public Object instantiate(Constructor ctor, Object[] args) &#123;</span><br><span class="line">    //CGLIB 中的类</span><br><span class="line">    Enhancer enhancer = new Enhancer();</span><br><span class="line">    //将 Bean 本身作为其基类</span><br><span class="line">    enhancer.setSuperclass(this.beanDefinition.getBeanClass());</span><br><span class="line">    enhancer.setCallbackFilter(new CallbackFilterImpl());</span><br><span class="line">    enhancer.setCallbacks(new Callback[] &#123;</span><br><span class="line">            NoOp.INSTANCE,</span><br><span class="line">            new LookupOverrideMethodInterceptor(),</span><br><span class="line">            new ReplaceOverrideMethodInterceptor()</span><br><span class="line">    &#125;);</span><br><span class="line">    //使用 CGLIB 的 create 方法生成实例对象</span><br><span class="line">    return (ctor == null) ?</span><br><span class="line">            enhancer.create() :</span><br><span class="line">            enhancer.create(ctor.getParameterTypes(), args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CGLIB 是一个常用的字节码生成器的类库，它提供了一系列 API 实现 java 字节码的生成和转换功能。我<br>们在学习 JDK 的动态代理时都知道，JDK 的动态代理只能针对接口，如果一个类没有实现任何接口，要<br>对其进行动态代理只能使用 CGLIB。</p><h1><a id="populateBean__Bean__109"></a>populateBean 方法对 Bean 属性的依赖注入</h1><p>在上面的分析中我们已经了解到 Bean 的依赖注入分为以下两个过程</p><ul><li>createBeanInstance：生成 Bean 所包含的 java 对象实例</li><li>populateBean ：对 Bean 属性的依赖注入进行处理</li></ul><p>我们已经分析了容器初始化生成 Bean 所包含的 Java 实例对象的过程，现在我们继续分析<br>生成对象后，Spring IOC 容器是如何将 Bean 的属性依赖关系注入 Bean 实例对象中并设置好的，属性<br>依赖注入的代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line">   //将 Bean 属性设置到生成的实例对象上</span><br><span class="line">   protected void populateBean(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw) &#123;</span><br><span class="line">       //获取容器在解析 Bean 定义资源时为 BeanDefiniton 中设置的属性值</span><br><span class="line">       PropertyValues pvs = mbd.getPropertyValues();</span><br><span class="line">       //实例对象为 null</span><br><span class="line">       if (bw == null) &#123;</span><br><span class="line">           //属性值不为空</span><br><span class="line">           if (!pvs.isEmpty()) &#123;</span><br><span class="line">               throw new BeanCreationException(</span><br><span class="line">                       mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null</span><br><span class="line">                       instance&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           else &#123;</span><br><span class="line">               //实例对象为 null，属性值也为空，不需要设置属性值，直接返回</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //在设置属性之前调用 Bean 的 PostProcessor 后置处理器</span><br><span class="line">       boolean continueWithPropertyPopulation = true;</span><br><span class="line">       if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">           for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">               if (bp instanceof InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                   InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)</span><br><span class="line">                           bp;</span><br><span class="line">                   if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">                       continueWithPropertyPopulation = false;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (!continueWithPropertyPopulation) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       //依赖注入开始，首先处理 autowire 自动装配的注入</span><br><span class="line">       if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">               mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">           MutablePropertyValues newPvs = new MutablePropertyValues(pvs);</span><br><span class="line">           //对 autowire 自动装配的处理，根据 Bean 名称自动装配注入</span><br><span class="line">           if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">               autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">           &#125;</span><br><span class="line">           //根据 Bean 类型自动装配注入</span><br><span class="line">           if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">               autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">           &#125;</span><br><span class="line">           pvs = newPvs;</span><br><span class="line">       &#125;</span><br><span class="line">       //检查容器是否持有用于处理单例模式 Bean 关闭时的后置处理器</span><br><span class="line">       boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">       //Bean 实例对象没有依赖，即没有继承基类</span><br><span class="line">       boolean needsDepCheck = (mbd.getDependencyCheck() !=</span><br><span class="line">               RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line">       if (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line">           //从实例对象中提取属性描述符</span><br><span class="line">           PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw);</span><br><span class="line">           if (hasInstAwareBpps) &#123;</span><br><span class="line">               for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">                   if (bp instanceof InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                       InstantiationAwareBeanPostProcessor ibp =</span><br><span class="line">                               (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                       //使用 BeanPostProcessor 处理器处理属性值</span><br><span class="line">                       pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(),</span><br><span class="line">                               beanName);</span><br><span class="line">                       if (pvs == null) &#123;</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (needsDepCheck) &#123;</span><br><span class="line">               //为要设置的属性进行依赖检查</span><br><span class="line">               checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //对属性进行注入</span><br><span class="line">       applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   protected void autowireByName(</span><br><span class="line">		String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) &#123;</span><br><span class="line"></span><br><span class="line">	String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">	for (String propertyName : propertyNames) &#123;</span><br><span class="line">		if (containsBean(propertyName)) &#123;</span><br><span class="line">			//使用当前Bean的属性名，在IoC容器中获取对应的bean，让将获取的bean设置为当前的Bean的属性值</span><br><span class="line">			Object bean = getBean(propertyName);</span><br><span class="line">			pvs.add(propertyName, bean);</span><br><span class="line">			registerDependentBean(propertyName, beanName);</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Added autowiring by name from bean name &apos;&quot; + beanName +</span><br><span class="line">						&quot;&apos; via property &apos;&quot; + propertyName + &quot;&apos; to bean named &apos;&quot; + propertyName + &quot;&apos;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			if (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(&quot;Not autowiring property &apos;&quot; + propertyName + &quot;&apos; of bean &apos;&quot; + beanName +</span><br><span class="line">						&quot;&apos; by name: no matching bean found&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   public void registerDependentBean(String beanName, String dependentBeanName) &#123;</span><br><span class="line">	String canonicalName = canonicalName(beanName);</span><br><span class="line">	// 翻译一下就是：set里的bean都要依赖 key</span><br><span class="line">	synchronized (this.dependentBeanMap) &#123;</span><br><span class="line">		Set&lt;String&gt; dependentBeans = this.dependentBeanMap.get(canonicalName);</span><br><span class="line">		if (dependentBeans == null) &#123;</span><br><span class="line">			dependentBeans = new LinkedHashSet&lt;String&gt;(8);</span><br><span class="line">			this.dependentBeanMap.put(canonicalName, dependentBeans);</span><br><span class="line">		&#125;</span><br><span class="line">		dependentBeans.add(dependentBeanName);</span><br><span class="line">	&#125;</span><br><span class="line">	// 翻译一下就是：key需要依赖set中的bean</span><br><span class="line">	synchronized (this.dependenciesForBeanMap) &#123;</span><br><span class="line">		Set&lt;String&gt; dependenciesForBean = this.dependenciesForBeanMap.get(dependentBeanName);</span><br><span class="line">		if (dependenciesForBean == null) &#123;</span><br><span class="line">			dependenciesForBean = new LinkedHashSet&lt;String&gt;(8);</span><br><span class="line">			this.dependenciesForBeanMap.put(dependentBeanName, dependenciesForBean);</span><br><span class="line">		&#125;</span><br><span class="line">		dependenciesForBean.add(canonicalName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   protected Map&lt;String, Object&gt; findAutowireCandidates(</span><br><span class="line">		String beanName, Class&lt;?&gt; requiredType, DependencyDescriptor descriptor) &#123;</span><br><span class="line"></span><br><span class="line">	//找一下所有的Bean定义中指定Type的实现类或者子类</span><br><span class="line">	String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">			this, requiredType, true, descriptor.isEager());</span><br><span class="line">	Map&lt;String, Object&gt; result = new LinkedHashMap&lt;String, Object&gt;(candidateNames.length);</span><br><span class="line">	//要自动装配的类型是不是要自动装配的纠正类型，这个在</span><br><span class="line">	// 非懒加载的单例Bean初始化前后的一些操作，如果要自动装配的类型是纠正类型，</span><br><span class="line">	// 比如是一个ResourceLoader，那么就会为该类型生成一个代理实例，</span><br><span class="line">	// 具体可以看一下 AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType);</span><br><span class="line">	for (Class&lt;?&gt; autowiringType : this.resolvableDependencies.keySet()) &#123;</span><br><span class="line">		if (autowiringType.isAssignableFrom(requiredType)) &#123;</span><br><span class="line">			Object autowiringValue = this.resolvableDependencies.get(autowiringType);</span><br><span class="line">			autowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType);</span><br><span class="line">			if (requiredType.isInstance(autowiringValue)) &#123;</span><br><span class="line">				result.put(ObjectUtils.identityToString(autowiringValue), autowiringValue);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//逐个判断查找一下beanName对应的BeanDefinition，判断一下是不是自动装配候选者，默认都是的，如果&lt;bean&gt;的autowire-candidate属性设置为false就不是</span><br><span class="line">	for (String candidateName : candidateNames) &#123;</span><br><span class="line">		if (!candidateName.equals(beanName) &amp;&amp; isAutowireCandidate(candidateName, descriptor)) &#123;</span><br><span class="line">			result.put(candidateName, getBean(candidateName));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   @Override</span><br><span class="line">public String[] getBeanNamesForType(Class&lt;?&gt; type, boolean includeNonSingletons, boolean allowEagerInit) &#123;</span><br><span class="line">	if (!isConfigurationFrozen()  || type == null || !allowEagerInit) &#123;</span><br><span class="line">		return doGetBeanNamesForType(type, includeNonSingletons, allowEagerInit);</span><br><span class="line">	&#125;</span><br><span class="line">	Map&lt;Class&lt;?&gt;, String[]&gt; cache =</span><br><span class="line">			(includeNonSingletons ? this.allBeanNamesByType : this.singletonBeanNamesByType);</span><br><span class="line">	String[] resolvedBeanNames = cache.get(type);</span><br><span class="line">	if (resolvedBeanNames != null) &#123;</span><br><span class="line">		return resolvedBeanNames;</span><br><span class="line">	&#125;</span><br><span class="line">	resolvedBeanNames = doGetBeanNamesForType(type, includeNonSingletons, allowEagerInit);</span><br><span class="line">	cache.put(type, resolvedBeanNames);</span><br><span class="line">	return resolvedBeanNames;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   //解析并注入依赖属性的过程</span><br><span class="line">   protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw,</span><br><span class="line">                                      PropertyValues pvs) &#123;</span><br><span class="line">       if (pvs == null || pvs.isEmpty()) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       //封装属性值</span><br><span class="line">       MutablePropertyValues mpvs = null;</span><br><span class="line">       List&lt;PropertyValue&gt; original;</span><br><span class="line">       if (System.getSecurityManager()!= null) &#123;</span><br><span class="line">           if (bw instanceof BeanWrapperImpl) &#123;</span><br><span class="line">               //设置安全上下文，JDK 安全机制</span><br><span class="line">               ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (pvs instanceof MutablePropertyValues) &#123;</span><br><span class="line">           mpvs = (MutablePropertyValues) pvs;</span><br><span class="line">           //属性值已经转换</span><br><span class="line">           if (mpvs.isConverted()) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   //为实例化对象设置属性值</span><br><span class="line">                   bw.setPropertyValues(mpvs);</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">               catch (BeansException ex) &#123;</span><br><span class="line">                   throw new BeanCreationException(</span><br><span class="line">                           mbd.getResourceDescription(), beanName, &quot;Error setting property values&quot;,</span><br><span class="line">                           ex);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           //获取属性值对象的原始类型值</span><br><span class="line">           original = mpvs.getPropertyValueList();</span><br><span class="line">       &#125;</span><br><span class="line">       else &#123;</span><br><span class="line">           original = Arrays.asList(pvs.getPropertyValues());</span><br><span class="line">       &#125;</span><br><span class="line">       //获取用户自定义的类型转换</span><br><span class="line">       TypeConverter converter = getCustomTypeConverter();</span><br><span class="line">       if (converter == null) &#123;</span><br><span class="line">           converter = bw;</span><br><span class="line">       &#125;</span><br><span class="line">       //创建一个 Bean 定义属性值解析器，将 Bean 定义中的属性值解析为 Bean 实例对象的实际值</span><br><span class="line">       BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName,</span><br><span class="line">               mbd, converter);</span><br><span class="line">       //为属性的解析值创建一个拷贝，将拷贝的数据注入到实例对象中</span><br><span class="line">       List&lt;PropertyValue&gt; deepCopy = new ArrayList&lt;PropertyValue&gt;(original.size());</span><br><span class="line">       boolean resolveNecessary = false;</span><br><span class="line">       for (PropertyValue pv : original) &#123;</span><br><span class="line">           //属性值不需要转换</span><br><span class="line">           if (pv.isConverted()) &#123;</span><br><span class="line">               deepCopy.add(pv);</span><br><span class="line">           &#125;</span><br><span class="line">           //属性值需要转换</span><br><span class="line">           else &#123;</span><br><span class="line">               String propertyName = pv.getName();</span><br><span class="line">               //原始的属性值，即转换之前的属性值</span><br><span class="line">               Object originalValue = pv.getValue();</span><br><span class="line">               //转换属性值，例如将引用转换为 IOC 容器中实例化对象引用</span><br><span class="line">			//检查，接口和类、父类和子类之间的关系是否正确</span><br><span class="line">			//同时处理ref类型数据</span><br><span class="line">			/**</span><br><span class="line">			 * &lt;bean class=&quot;com.jphoebe.xxx&quot;&gt;</span><br><span class="line">			 *     &lt;property name=&quot;referBeanName&quot; ref=&quot;otherBeanName&quot; /&gt;</span><br><span class="line">			 * &lt;/bean&gt;</span><br><span class="line">			 */</span><br><span class="line">               Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">               //转换之后的属性值</span><br><span class="line">               Object convertedValue = resolvedValue;</span><br><span class="line">               //属性值是否可以转换</span><br><span class="line">               boolean convertible = bw.isWritableProperty(propertyName) &amp;&amp;</span><br><span class="line">                       !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</span><br><span class="line">               if (convertible) &#123;</span><br><span class="line">                   //使用用户自定义的类型转换器转换属性值</span><br><span class="line">                   convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);</span><br><span class="line">               &#125;</span><br><span class="line">               //存储转换后的属性值，避免每次属性注入时的转换工作</span><br><span class="line">               if (resolvedValue == originalValue) &#123;</span><br><span class="line">                   if (convertible) &#123;</span><br><span class="line">                       //设置属性转换之后的值</span><br><span class="line">                       pv.setConvertedValue(convertedValue);</span><br><span class="line">                   &#125;</span><br><span class="line">                   deepCopy.add(pv);</span><br><span class="line">               &#125;</span><br><span class="line">               //属性是可转换的，且属性原始值是字符串类型，且属性的原始类型值不是</span><br><span class="line">               //动态生成的字符串，且属性的原始值不是集合或者数组类型</span><br><span class="line">               else if (convertible &amp;&amp; originalValue instanceof TypedStringValue &amp;&amp;</span><br><span class="line">                       !((TypedStringValue) originalValue).isDynamic() &amp;&amp;</span><br><span class="line">                       !(convertedValue instanceof Collection ||</span><br><span class="line">                               ObjectUtils.isArray(convertedValue))) &#123;</span><br><span class="line">                   pv.setConvertedValue(convertedValue);</span><br><span class="line">                   deepCopy.add(pv);</span><br><span class="line">               &#125;</span><br><span class="line">               else &#123;</span><br><span class="line">                   resolveNecessary = true;</span><br><span class="line">                   //重新封装属性的值</span><br><span class="line">                   deepCopy.add(new PropertyValue(pv, convertedValue));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (mpvs != null &amp;&amp; !resolveNecessary) &#123;</span><br><span class="line">           //标记属性值已经转换过</span><br><span class="line">           mpvs.setConverted();</span><br><span class="line">       &#125;</span><br><span class="line">       //进行属性依赖注入</span><br><span class="line">       try &#123;</span><br><span class="line">           bw.setPropertyValues(new MutablePropertyValues(deepCopy));</span><br><span class="line">       &#125;</span><br><span class="line">       catch (BeansException ex) &#123;</span><br><span class="line">           throw new BeanCreationException(</span><br><span class="line">                   mbd.getResourceDescription(), beanName, &quot;Error setting property values&quot;, ex);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>分析上述代码，我们可以看出，对属性的注入过程分以下两种情况:</p><ul><li>属性值类型不需要转换时，不需要解析属性值，直接准备进行依赖注入</li><li>属性值需要进行类型转换时，如对其他对象的引用等，首先需要解析属性值，然后对解析后的属性值进行依赖注入。</li></ul><p>对属性值的解析是在 BeanDefinitionValueResolver 类中的 resolveValueIfNecessary 方法中进行的，<br>对属性值的依赖注入是通过 bw.setPropertyValues 方法实现的，在分析属性值的依赖注入之前，我们<br>先分析一下对属性值的解析过程。</p><h1><a id="BeanDefinitionValueResolver__126"></a>BeanDefinitionValueResolver 解析属性值</h1><p>当容器在对属性进行依赖注入时，如果发现属性值需要进行类型转换，如属性值是容器中另一个 Bean<br>实例对象的引用，则容器首先需要根据属性值解析出所引用的对象，然后才能将该引用对象注入到目标<br>实例对象的属性上去，对属性进行解析的由 resolveValueIfNecessary 方法实现，其源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">//解析属性值，对注入类型进行转换</span><br><span class="line">    public Object resolveValueIfNecessary(Object argName, Object value) &#123;</span><br><span class="line">        //对引用类型的属性进行解析</span><br><span class="line">        if (value instanceof RuntimeBeanReference) &#123;</span><br><span class="line">            RuntimeBeanReference ref = (RuntimeBeanReference) value;</span><br><span class="line">            //调用引用类型属性的解析方法</span><br><span class="line">            return resolveReference(argName, ref);</span><br><span class="line">        &#125;</span><br><span class="line">        //对属性值是引用容器中另一个 Bean 名称的解析</span><br><span class="line">        else if (value instanceof RuntimeBeanNameReference) &#123;</span><br><span class="line">            String refName = ((RuntimeBeanNameReference) value).getBeanName();</span><br><span class="line">            refName = String.valueOf(evaluate(refName));</span><br><span class="line">            //从容器中获取指定名称的 Bean</span><br><span class="line">            if (!this.beanFactory.containsBean(refName)) &#123;</span><br><span class="line">                throw new BeanDefinitionStoreException(</span><br><span class="line">                        &quot;Invalid bean name &apos;&quot; + refName + &quot;&apos; in bean reference for &quot; + argName);</span><br><span class="line">            &#125;</span><br><span class="line">            return refName;</span><br><span class="line">        &#125;</span><br><span class="line">        //对 Bean 类型属性的解析，主要是 Bean 中的内部类</span><br><span class="line">        else if (value instanceof BeanDefinitionHolder) &#123;</span><br><span class="line">            BeanDefinitionHolder bdHolder = (BeanDefinitionHolder) value;</span><br><span class="line">            return resolveInnerBean(argName, bdHolder.getBeanName(), bdHolder.getBeanDefinition());</span><br><span class="line">        &#125;</span><br><span class="line">        else if (value instanceof BeanDefinition) &#123;</span><br><span class="line">            BeanDefinition bd = (BeanDefinition) value;</span><br><span class="line">            return resolveInnerBean(argName, &quot;(inner bean)&quot;, bd);</span><br><span class="line">        &#125;</span><br><span class="line">        //对集合数组类型的属性解析</span><br><span class="line">        else if (value instanceof ManagedArray) &#123;</span><br><span class="line">            ManagedArray array = (ManagedArray) value;</span><br><span class="line">            //获取数组的类型</span><br><span class="line">            Class elementType = array.resolvedElementType;</span><br><span class="line">            if (elementType == null) &#123;</span><br><span class="line">                //获取数组元素的类型</span><br><span class="line">                String elementTypeName = array.getElementTypeName();</span><br><span class="line">                if (StringUtils.hasText(elementTypeName)) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        //使用反射机制创建指定类型的对象</span><br><span class="line">                        elementType = ClassUtils.forName(elementTypeName,</span><br><span class="line">                                this.beanFactory.getBeanClassLoader());</span><br><span class="line">                        array.resolvedElementType = elementType;</span><br><span class="line">                    &#125;</span><br><span class="line">                    catch (Throwable ex) &#123;</span><br><span class="line">                        throw new BeanCreationException(</span><br><span class="line">                                this.beanDefinition.getResourceDescription(), this.beanName,</span><br><span class="line">                                &quot;Error resolving array type for &quot; + argName, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //没有获取到数组的类型，也没有获取到数组元素的类型</span><br><span class="line">                //则直接设置数组的类型为 Object</span><br><span class="line">                else &#123;</span><br><span class="line">                    elementType = Object.class;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //创建指定类型的数组</span><br><span class="line">            return resolveManagedArray(argName, (List&lt;?&gt;) value, elementType);</span><br><span class="line">        &#125;</span><br><span class="line">        //解析 list 类型的属性值</span><br><span class="line">        else if (value instanceof ManagedList) &#123;</span><br><span class="line">            return resolveManagedList(argName, (List&lt;?&gt;) value);</span><br><span class="line">        &#125;</span><br><span class="line">        //解析 set 类型的属性值</span><br><span class="line">        else if (value instanceof ManagedSet) &#123;</span><br><span class="line">            return resolveManagedSet(argName, (Set&lt;?&gt;) value);</span><br><span class="line">        &#125;</span><br><span class="line">        //解析 map 类型的属性值</span><br><span class="line">        else if (value instanceof ManagedMap) &#123;</span><br><span class="line">            return resolveManagedMap(argName, (Map&lt;?, ?&gt;) value);</span><br><span class="line">        &#125;</span><br><span class="line">        //解析 props 类型的属性值，props 其实就是 key 和 value 均为字符串的 map</span><br><span class="line">        else if (value instanceof ManagedProperties) &#123;</span><br><span class="line">            Properties original = (Properties) value;</span><br><span class="line">            //创建一个拷贝，用于作为解析后的返回值</span><br><span class="line">            Properties copy = new Properties();</span><br><span class="line">            for (Map.Entry propEntry : original.entrySet()) &#123;</span><br><span class="line">                Object propKey = propEntry.getKey();</span><br><span class="line">                Object propValue = propEntry.getValue();</span><br><span class="line">                if (propKey instanceof TypedStringValue) &#123;</span><br><span class="line">                    propKey = evaluate((TypedStringValue) propKey);</span><br><span class="line">                &#125;</span><br><span class="line">                if (propValue instanceof TypedStringValue) &#123;</span><br><span class="line">                    propValue = evaluate((TypedStringValue) propValue);</span><br><span class="line">                &#125;</span><br><span class="line">                copy.put(propKey, propValue);</span><br><span class="line">            &#125;</span><br><span class="line">            return copy;</span><br><span class="line">        &#125;</span><br><span class="line">        //解析字符串类型的属性值</span><br><span class="line">        else if (value instanceof TypedStringValue) &#123;</span><br><span class="line">            TypedStringValue typedStringValue = (TypedStringValue) value;</span><br><span class="line">            Object valueObject = evaluate(typedStringValue);</span><br><span class="line">            try &#123;</span><br><span class="line">                //获取属性的目标类型</span><br><span class="line">                Class&lt;?&gt; resolvedTargetType = resolveTargetType(typedStringValue);</span><br><span class="line">                if (resolvedTargetType != null) &#123;</span><br><span class="line">                    //对目标类型的属性进行解析，递归调用</span><br><span class="line">                    return this.typeConverter.convertIfNecessary(valueObject, resolvedTargetType);</span><br><span class="line">                &#125;</span><br><span class="line">                //没有获取到属性的目标对象，则按 Object 类型返回</span><br><span class="line">                else &#123;</span><br><span class="line">                    return valueObject;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Throwable ex) &#123;</span><br><span class="line">                throw new BeanCreationException(</span><br><span class="line">                        this.beanDefinition.getResourceDescription(), this.beanName,</span><br><span class="line">                        &quot;Error converting typed String value for &quot; + argName, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return evaluate(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //解析引用类型的属性值</span><br><span class="line">    private Object resolveReference(Object argName, RuntimeBeanReference ref) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //获取引用的 Bean 名称</span><br><span class="line">            String refName = ref.getBeanName();</span><br><span class="line">            refName = String.valueOf(evaluate(refName));</span><br><span class="line">            //如果引用的对象在父类容器中，则从父类容器中获取指定的引用对象</span><br><span class="line">            if (ref.isToParent()) &#123;</span><br><span class="line">                if (this.beanFactory.getParentBeanFactory() == null) &#123;</span><br><span class="line">                    throw new BeanCreationException(</span><br><span class="line">                            this.beanDefinition.getResourceDescription(), this.beanName,</span><br><span class="line">                            &quot;Can&apos;t resolve reference to bean &apos;&quot; + refName +</span><br><span class="line">                                    &quot;&apos; in parent factory: no parent factory available&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                return this.beanFactory.getParentBeanFactory().getBean(refName);</span><br><span class="line">            &#125;</span><br><span class="line">            //从当前的容器中获取指定的引用 Bean 对象，如果指定的 Bean 没有被实例化</span><br><span class="line">            //则会递归触发引用 Bean 的初始化和依赖注入</span><br><span class="line">            else &#123;</span><br><span class="line">                Object bean = this.beanFactory.getBean(refName);</span><br><span class="line">                //将当前实例化对象的依赖引用对象</span><br><span class="line">                this.beanFactory.registerDependentBean(refName, this.beanName);</span><br><span class="line">                return bean;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (BeansException ex) &#123;</span><br><span class="line">            throw new BeanCreationException(</span><br><span class="line">                    this.beanDefinition.getResourceDescription(), this.beanName,</span><br><span class="line">                    &quot;Cannot resolve reference to bean &apos;&quot; + ref.getBeanName() + &quot;&apos; while setting &quot; +</span><br><span class="line">                            argName, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //解析 array 类型的属性</span><br><span class="line">    private Object resolveManagedArray(Object argName, List&lt;?&gt; ml, Class elementType) &#123;</span><br><span class="line">        //创建一个指定类型的数组，用于存放和返回解析后的数组</span><br><span class="line">        Object resolved = Array.newInstance(elementType, ml.size());</span><br><span class="line">        for (int i = 0; i &lt; ml.size(); i++) &#123;</span><br><span class="line">            //递归解析 array 的每一个元素，并将解析后的值设置到 resolved 数组中，索引为 i</span><br><span class="line">            Array.set(resolved, i,</span><br><span class="line">                    resolveValueIfNecessary(new KeyedArgName(argName, i), ml.get(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        return resolved;</span><br><span class="line">    &#125;</span><br><span class="line">    //解析 list 类型的属性</span><br><span class="line">    private List resolveManagedList(Object argName, List&lt;?&gt; ml) &#123;</span><br><span class="line">        List&lt;Object&gt; resolved = new ArrayList&lt;Object&gt;(ml.size());</span><br><span class="line">        for (int i = 0; i &lt; ml.size(); i++) &#123;</span><br><span class="line">            //递归解析 list 的每一个元素</span><br><span class="line">            resolved.add(</span><br><span class="line">                    resolveValueIfNecessary(new KeyedArgName(argName, i), ml.get(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        return resolved;</span><br><span class="line">    &#125;</span><br><span class="line">    //解析 set 类型的属性</span><br><span class="line">    private Set resolveManagedSet(Object argName, Set&lt;?&gt; ms) &#123;</span><br><span class="line">        Set&lt;Object&gt; resolved = new LinkedHashSet&lt;Object&gt;(ms.size());</span><br><span class="line">        int i = 0;</span><br><span class="line">        //递归解析 set 的每一个元素</span><br><span class="line">        for (Object m : ms) &#123;</span><br><span class="line">            resolved.add(resolveValueIfNecessary(new KeyedArgName(argName, i), m));</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return resolved;</span><br><span class="line">    &#125;</span><br><span class="line">    //解析 map 类型的属性</span><br><span class="line">    private Map resolveManagedMap(Object argName, Map&lt;?, ?&gt; mm) &#123;</span><br><span class="line">        Map&lt;Object, Object&gt; resolved = new LinkedHashMap&lt;Object, Object&gt;(mm.size());</span><br><span class="line">        //递归解析 map 中每一个元素的 key 和 value</span><br><span class="line">        for (Map.Entry entry : mm.entrySet()) &#123;</span><br><span class="line">            Object resolvedKey = resolveValueIfNecessary(argName, entry.getKey());</span><br><span class="line">            Object resolvedValue = resolveValueIfNecessary(</span><br><span class="line">                    new KeyedArgName(argName, entry.getKey()), entry.getValue());</span><br><span class="line">            resolved.put(resolvedKey, resolvedValue);</span><br><span class="line">        &#125;</span><br><span class="line">        return resolved;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码分析，我们明白了 Spring 是如何将引用类型，内部类以及集合类型等属性进行解析的，<br>属性值解析完成后就可以进行依赖注入了，依赖注入的过程就是 Bean 对象实例设置到它所依赖的 Bean<br>对象属性上去，在第 7 步中我们已经说过，依赖注入是通过 bw.setPropertyValues 方法实现的，该方<br>法也使用了委托模式，在 BeanWrapper 接口中至少定义了方法声明，依赖注入的具体实现交由其实现类<br>BeanWrapperImpl 来完成，下面我们就分析依 BeanWrapperImpl 中赖注入相关的源码。</p><h1><a id="BeanWrapperImpl__Bean__137"></a>BeanWrapperImpl 对 Bean 属性的依赖注入</h1><p>BeanWrapperImpl 类主要是对容器中完成初始化的 Bean 实例对象进行属性的依赖注入，即把 Bean 对象<br>设置到它所依赖的另一个 Bean 的属性中去，依赖注入的相关源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line">//实现属性依赖注入功能</span><br><span class="line">    private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException &#123;</span><br><span class="line">        //PropertyTokenHolder 主要保存属性的名称、路径，以及集合的 size 等信息</span><br><span class="line">        String propertyName = tokens.canonicalName;</span><br><span class="line">        String actualName = tokens.actualName;</span><br><span class="line">        //keys 是用来保存集合类型属性的 size</span><br><span class="line">        if (tokens.keys != null) &#123;</span><br><span class="line">            //将属性信息拷贝</span><br><span class="line">            PropertyTokenHolder getterTokens = new PropertyTokenHolder();</span><br><span class="line">            getterTokens.canonicalName = tokens.canonicalName;</span><br><span class="line">            getterTokens.actualName = tokens.actualName;</span><br><span class="line">            getterTokens.keys = new String[tokens.keys.length - 1];</span><br><span class="line">            System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);</span><br><span class="line">            Object propValue;</span><br><span class="line">            try &#123;</span><br><span class="line">                //获取属性值，该方法内部使用 JDK 的内省( Introspector)机制</span><br><span class="line">                //调用属性的 getter(readerMethod)方法，获取属性的值</span><br><span class="line">                propValue = getPropertyValue(getterTokens);</span><br><span class="line">            &#125; catch (NotReadablePropertyException ex) &#123;</span><br><span class="line">                throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,</span><br><span class="line">                        &quot;Cannot access indexed value in property referenced &quot; +</span><br><span class="line">                                &quot;in indexed property path &apos;&quot; + propertyName + &quot;&apos;&quot;, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            //获取集合类型属性的长度</span><br><span class="line">            String key = tokens.keys[tokens.keys.length - 1];</span><br><span class="line">            if (propValue == null) &#123;</span><br><span class="line">                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath +</span><br><span class="line">                        propertyName,</span><br><span class="line">                        &quot;Cannot access indexed value in property referenced &quot; +</span><br><span class="line">                                &quot;in indexed property path &apos;&quot; + propertyName + &quot;&apos;: returned null&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            //注入 array 类型的属性值</span><br><span class="line">            else if (propValue.getClass().isArray()) &#123;</span><br><span class="line">                //获取属性的描述符</span><br><span class="line">                PropertyDescriptor pd =</span><br><span class="line">                        getCachedIntrospectionResults().getPropertyDescriptor(actualName);</span><br><span class="line">                //获取数组的类型</span><br><span class="line">                Class requiredType = propValue.getClass().getComponentType();</span><br><span class="line">                //获取数组的长度</span><br><span class="line">                int arrayIndex = Integer.parseInt(key);</span><br><span class="line">                Object oldValue = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //获取数组以前初始化的值</span><br><span class="line">                    if (isExtractOldValueForEditor()) &#123;</span><br><span class="line">                        oldValue = Array.get(propValue, arrayIndex);</span><br><span class="line">                    &#125;</span><br><span class="line">                    //将属性的值赋值给数组中的元素</span><br><span class="line">                    Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),</span><br><span class="line">                            requiredType,</span><br><span class="line">                            new PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(),</span><br><span class="line">                                    -1), requiredType));</span><br><span class="line">                    Array.set(propValue, arrayIndex, convertedValue);</span><br><span class="line">                &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                    throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,</span><br><span class="line">                            &quot;Invalid array index in property path &apos;&quot; + propertyName + &quot;&apos;&quot;, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //注入 list 类型的属性值</span><br><span class="line">            else if (propValue instanceof List) &#123;</span><br><span class="line">                PropertyDescriptor pd =</span><br><span class="line">                        getCachedIntrospectionResults().getPropertyDescriptor(actualName);</span><br><span class="line">                //获取 list 集合的类型</span><br><span class="line">                Class requiredType = GenericCollectionTypeResolver.getCollectionReturnType(</span><br><span class="line">                        pd.getReadMethod(), tokens.keys.length);</span><br><span class="line">                List list = (List) propValue;</span><br><span class="line">                //获取 list 集合的 size</span><br><span class="line">                int index = Integer.parseInt(key);</span><br><span class="line">                Object oldValue = null;</span><br><span class="line">                if (isExtractOldValueForEditor() &amp;&amp; index &lt; list.size()) &#123;</span><br><span class="line">                    oldValue = list.get(index);</span><br><span class="line">                &#125;</span><br><span class="line">                //获取 list 解析后的属性值</span><br><span class="line">                Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(),</span><br><span class="line">                        requiredType,</span><br><span class="line">                        new PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1),</span><br><span class="line">                                requiredType));</span><br><span class="line">                if (index &lt; list.size()) &#123;</span><br><span class="line">                    //为 list 属性赋值</span><br><span class="line">                    list.set(index, convertedValue);</span><br><span class="line">                &#125;</span><br><span class="line">                //如果 list 的长度大于属性值的长度，则多余的元素赋值为 null</span><br><span class="line">                else if (index &gt;= list.size()) &#123;</span><br><span class="line">                    for (int i = list.size(); i &lt; index; i++) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            list.add(null);</span><br><span class="line">                        &#125; catch (NullPointerException ex) &#123;</span><br><span class="line">                            throw new InvalidPropertyException(getRootClass(), this.nestedPath +</span><br><span class="line">                                    propertyName,</span><br><span class="line">                                    &quot;Cannot set element with index &quot; + index + &quot; in List of size &quot; +</span><br><span class="line">                                            list.size() + &quot;, accessed using property path &apos;&quot; + propertyName +</span><br><span class="line">                                            &quot;&apos;: List does not support filling up gaps with null elements&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    list.add(convertedValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //注入 map 类型的属性值</span><br><span class="line">            else if (propValue instanceof Map) &#123;</span><br><span class="line">                PropertyDescriptor pd =</span><br><span class="line">                        getCachedIntrospectionResults().getPropertyDescriptor(actualName);</span><br><span class="line">                //获取 map 集合 key 的类型</span><br><span class="line">                Class mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(</span><br><span class="line">                        pd.getReadMethod(), tokens.keys.length);</span><br><span class="line">                //获取 map 集合 value 的类型</span><br><span class="line">                Class mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(</span><br><span class="line">                        pd.getReadMethod(), tokens.keys.length);</span><br><span class="line">                Map map = (Map) propValue;</span><br><span class="line">                //解析 map 类型属性 key 值</span><br><span class="line">                Object convertedMapKey = convertIfNecessary(null, null, key, mapKeyType,</span><br><span class="line">                        new PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1),</span><br><span class="line">                                mapKeyType));</span><br><span class="line">                Object oldValue = null;</span><br><span class="line">                if (isExtractOldValueForEditor()) &#123;</span><br><span class="line">                    oldValue = map.get(convertedMapKey);</span><br><span class="line">                &#125;</span><br><span class="line">                //解析 map 类型属性 value 值</span><br><span class="line">                Object convertedMapValue = convertIfNecessary(</span><br><span class="line">                        propertyName, oldValue, pv.getValue(), mapValueType,</span><br><span class="line">                        new TypeDescriptor(new MethodParameter(pd.getReadMethod(), -1,</span><br><span class="line">                                tokens.keys.length + 1)));</span><br><span class="line">                //将解析后的 key 和 value 值赋值给 map 集合属性</span><br><span class="line">                map.put(convertedMapKey, convertedMapValue);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,</span><br><span class="line">                        &quot;Property referenced in indexed property path &apos;&quot; + propertyName +</span><br><span class="line">                                &quot;&apos; is neither an array nor a List nor a Map; returned value was [&quot; + pv.getValue()</span><br><span class="line">                                + &quot;]&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //对非集合类型的属性注入</span><br><span class="line">        else &#123;</span><br><span class="line">            PropertyDescriptor pd = pv.resolvedDescriptor;</span><br><span class="line">            if (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) &#123;</span><br><span class="line">                pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);</span><br><span class="line">                //无法获取到属性名或者属性没有提供 setter(写方法)方法</span><br><span class="line">                if (pd == null || pd.getWriteMethod() == null) &#123;</span><br><span class="line">                    //如果属性值是可选的，即不是必须的，则忽略该属性值</span><br><span class="line">                    if (pv.isOptional()) &#123;</span><br><span class="line">                        logger.debug(&quot;Ignoring optional value for property &apos;&quot; + actualName +</span><br><span class="line">                                &quot;&apos; - property not found on bean class [&quot; + getRootClass().getName() +</span><br><span class="line">                                &quot;]&quot;);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //如果属性值是必须的，则抛出无法给属性赋值，因为没提供 setter 方法异常</span><br><span class="line">                    else &#123;</span><br><span class="line">                        PropertyMatches matches = PropertyMatches.forProperty(propertyName,</span><br><span class="line">                                getRootClass());</span><br><span class="line">                        throw new NotWritablePropertyException(</span><br><span class="line">                                getRootClass(), this.nestedPath + propertyName,</span><br><span class="line">                                matches.buildErrorMessage(), matches.getPossibleMatches());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                pv.getOriginalPropertyValue().resolvedDescriptor = pd;</span><br><span class="line">            &#125;</span><br><span class="line">            Object oldValue = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                Object originalValue = pv.getValue();</span><br><span class="line">                Object valueToApply = originalValue;</span><br><span class="line">                if (!Boolean.FALSE.equals(pv.conversionNecessary)) &#123;</span><br><span class="line">                    if (pv.isConverted()) &#123;</span><br><span class="line">                        valueToApply = pv.getConvertedValue();</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        if (isExtractOldValueForEditor() &amp;&amp; pd.getReadMethod() != null) &#123;</span><br><span class="line">                            //获取属性的 getter 方法(读方法)，JDK 内省机制</span><br><span class="line">                            final Method readMethod = pd.getReadMethod();</span><br><span class="line">                            //如果属性的 getter 方法不是 public 访问控制权限的，即访问控制权限比较严格，</span><br><span class="line">                            //则使用 JDK 的反射机制强行访问非 public 的方法(暴力读取属性值)</span><br><span class="line">                            if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &amp;&amp;</span><br><span class="line">                                    !readMethod.isAccessible()) &#123;</span><br><span class="line">                                if (System.getSecurityManager() != null) &#123;</span><br><span class="line">                                    //匿名内部类，根据权限修改属性的读取控制限制</span><br><span class="line">                                    AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                                        public Object run() &#123;</span><br><span class="line">                                            readMethod.setAccessible(true);</span><br><span class="line">                                            return null;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;);</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                    readMethod.setAccessible(true);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                //属性没有提供 getter 方法时，调用潜在的读取属性值的方法，获取属性值</span><br><span class="line">                                if (System.getSecurityManager() != null) &#123;</span><br><span class="line">                                    oldValue = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line">                                         public Object run() throws Exception &#123;</span><br><span class="line">                                             return readMethod.invoke(object);</span><br><span class="line">                                         &#125;</span><br><span class="line">                                     &#125;, acc);</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                    oldValue = readMethod.invoke(object);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; catch (Exception ex) &#123;</span><br><span class="line">                                if (ex instanceof PrivilegedActionException) &#123;</span><br><span class="line">                                    ex = ((PrivilegedActionException) ex).getException();</span><br><span class="line">                                &#125;</span><br><span class="line">                                if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                                    logger.debug(&quot;Could not read previous value of property &apos;&quot; +</span><br><span class="line">                                            this.nestedPath + propertyName + &quot;&apos;&quot;, ex);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //设置属性的注入值</span><br><span class="line">                        valueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);</span><br><span class="line">                    &#125;</span><br><span class="line">                    pv.getOriginalPropertyValue().conversionNecessary = (valueToApply !=</span><br><span class="line">                            originalValue);</span><br><span class="line">                &#125;</span><br><span class="line">                //根据 JDK 的内省机制，获取属性的 setter(写方法)方法</span><br><span class="line">                final Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ?</span><br><span class="line">                        ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :</span><br><span class="line">                        pd.getWriteMethod());</span><br><span class="line">                //如果属性的 setter 方法是非 public，即访问控制权限比较严格，则使用 JDK 的反射机制，</span><br><span class="line">                //强行设置 setter 方法可访问(暴力为属性赋值)</span><br><span class="line">                if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())</span><br><span class="line">                        &amp;&amp; !writeMethod.isAccessible()) &#123;</span><br><span class="line">                    //如果使用了 JDK 的安全机制，则需要权限验证</span><br><span class="line">                    if (System.getSecurityManager() != null) &#123;</span><br><span class="line">                        AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                            public Object run() &#123;</span><br><span class="line">                                writeMethod.setAccessible(true);</span><br><span class="line">                                return null;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        writeMethod.setAccessible(true);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                final Object value = valueToApply;</span><br><span class="line">                if (System.getSecurityManager() != null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        //将属性值设置到属性上去</span><br><span class="line">                        AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line">                            public Object run() throws Exception &#123;</span><br><span class="line">                                writeMethod.invoke(object, value);</span><br><span class="line">                                return null;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;, acc);</span><br><span class="line">                    &#125; catch (PrivilegedActionException ex) &#123;</span><br><span class="line">                        throw ex.getException();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    writeMethod.invoke(this.object, value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (TypeMismatchException ex) &#123;</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125; catch (InvocationTargetException ex) &#123;</span><br><span class="line">                PropertyChangeEvent propertyChangeEvent =</span><br><span class="line">                        new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName,</span><br><span class="line">                                oldValue, pv.getValue());</span><br><span class="line">                if (ex.getTargetException() instanceof ClassCastException) &#123;</span><br><span class="line">                    throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(),</span><br><span class="line">                            ex.getTargetException());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new MethodInvocationException(propertyChangeEvent,</span><br><span class="line">                            ex.getTargetException());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception ex) &#123;</span><br><span class="line">                PropertyChangeEvent pce =</span><br><span class="line">                        new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName,</span><br><span class="line">                                oldValue, pv.getValue());</span><br><span class="line">                throw new MethodInvocationException(pce, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过对上面注入依赖代码的分析，我们已经明白了 Spring IOC 容器是如何将属性的值注入到 Bean 实<br>例对象中去的：</p><ul><li>对于集合类型的属性，将其属性值解析为目标类型的集合后直接赋值给属性。</li><li>对于非集合类型的属性，大量使用了 JDK 的反射和内省机制，通过属性的 getter 方法(reader method)获取指定属性注入以前的值，同时调用属性的 setter 方法(writer method)为属性设置注入后的值。看到这里相信很多人都明白了 Spring 的 setter 注入原理。</li></ul><p>至此 Spring IOC 容器对 Bean 定义资源文件的定位，载入、解析和依赖注入已经全部分析完毕，现在<br>Spring IOC 容器中管理了一系列靠依赖关系联系起来的 Bean，程序不需要应用自己手动创建所需的对<br>象，Spring IOC 容器会在我们使用的时候自动为我们创建，并且为我们注入好相关的依赖，这就是<br>Spring 核心功能的控制反转和依赖注入的相关功能。</p><p><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/DI%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jeff-eric.github.com/blog/blog/2019/10/22/spring%20-%20%E7%AE%80%E4%BB%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jeff-Eric"><meta itemprop="description" content=""><meta itemprop="image" content="/blog/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="纯天然绿色学渣"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/blog/2019/10/22/spring%20-%20%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">spring - 简介</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-22 18:51:56" itemprop="dateCreated datePublished" datetime="2019-10-22T18:51:56+08:00">2019-10-22</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-11-06 15:56:12" itemprop="dateModified" datetime="2019-11-06T15:56:12+08:00">2019-11-06</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/blog/2019/10/22/spring%20-%20%E7%AE%80%E4%BB%8B/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/2019/10/22/spring%20-%20%E7%AE%80%E4%BB%8B/" itemprop="commentCount"></span> </a></span><span id="/blog/2019/10/22/spring%20-%20%E7%AE%80%E4%BB%8B/" class="leancloud_visitors" data-flag-title="spring - 简介"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body han-init-context" itemprop="articleBody"><h1><a id="spring_1"></a>spring</h1><h2><a id="_2"></a><a class="header-anchor" href="#轻量级">¶</a>轻量级</h2><ul><li>零配置变成</li><li>API使用简单</li></ul><h2><a id="bean_6"></a><a class="header-anchor" href="#面向bean">¶</a>面向bean</h2><ul><li>只需要编写非常普通的bean</li></ul><h2><a id="_9"></a><a class="header-anchor" href="#松耦合">¶</a>松耦合</h2><ul><li>充分利用AOP思想</li></ul><h2><a id="_12"></a><a class="header-anchor" href="#万能胶">¶</a>万能胶</h2><ul><li>与主流框架无缝集成</li></ul><h2><a id="_15"></a><a class="header-anchor" href="#设计模式">¶</a>设计模式</h2><ul><li>将java中进店调的设计模式运用的淋漓尽致</li></ul><h2><a id="_18"></a><a class="header-anchor" href="#简化开发">¶</a>简化开发</h2><ul><li>基于entry的轻量级和最小侵入性变成</li><li>通过依赖注入和面向接口松耦合</li><li>基于且米娜和惯性进行声明式变成</li><li>通过切面和模板减少样版式代码</li></ul><h1><a id="IOCIOC_24"></a>IOC、IOC容器</h1><p>业务人员不需要实例化和对对象的管理，只需要让spring知道对象创建的方式，剩下的事情都是spring来做。<br>等到需要使用它的时候直接拿来用就行了。<br>ioc容器其实就是存储实例化的bean</p><h2><a id="_29"></a><a class="header-anchor" href="#注入的方式">¶</a>注入的方式</h2><ul><li>set方法</li><li>构造方法</li><li>强制赋值</li></ul><h1><a id="AOP_34"></a>AOP</h1><p>主要思想是：解耦<br>过程：先把一个有规律的整体拆了，分别开发，等到发布的时候，再组装起来。<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191031215151.png" alt></p><ul><li>事务 transaction</li><li>权限认证 authentication</li><li>日志 logging</li><li>懒加载 lazy loading</li><li>上下文处理 context process</li><li>错误跟踪(异常捕获机制) error handler</li><li>cache 缓存</li></ul><p><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191105202651.png" alt></p><h1><a id="_49"></a>整体架构</h1><p><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191105205224.png" alt><br>spring 4架构图：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/QQ%E6%88%AA%E5%9B%BE20191105205007.png" alt><br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191105210336.png" alt><br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191105210755.png" alt></p><p><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191106092949.png" alt></p><h1><a id="_58"></a>源码编译</h1><p><a href="https://github.com/spring-projects/spring-framework" target="_blank" rel="noopener">官方github</a></p><h2><a id="gradlejdk_60"></a><a class="header-anchor" href="#不同版本的源码要对应不同的gradle-jdk">¶</a>不同版本的源码要对应不同的gradle、jdk</h2><p>文件夹内有相应的README.MD文件，可以查看具体的环境配置<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191106142926.png" alt><br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191106115718.png" alt><br>修改Gradlew.bat中相应的版本配置<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/20191106130827.png" alt><br>解压后的源码不被ide工具识别，需要进行编译转换，解压后的文件夹内有相关的转换指导</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">idea 导入方法，执行以下两个命令</span><br><span class="line">gradlew.bat</span><br><span class="line">gradlew.bat cleanIdea :spring-oxm:compileTestJava</span><br></pre></td></tr></table></figure><h4><a id="326RELEASE__16_gradle__jdk7_68"></a><a class="header-anchor" href="#3-2-6-release-1-6-gradle-jdk7">¶</a>3.2.6.RELEASE -&gt; 1.6 gradle / jdk7</h4><h3><a id="326RELEASE__70"></a><a class="header-anchor" href="#3-2-6-release-已编译版">¶</a>3.2.6.RELEASE 已编译版</h3><p><a href="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/spring-framework-3.2.6.RELEASE.7z" target="_blank" rel="noopener">3.2.6.RELEASE 已编译版下载</a></p><h3><a id="504RELEASE__72"></a><a class="header-anchor" href="#5-0-4-release-已编译版">¶</a>5.0.4.RELEASE 已编译版</h3><p><a href="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/spring-framework-5.0.4.RELEASE.7z" target="_blank" rel="noopener">5.0.4.RELEASE 已编译版下载</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jeff-eric.github.com/blog/blog/2019/10/22/synchronized-%E5%92%8C-Lock/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jeff-Eric"><meta itemprop="description" content=""><meta itemprop="image" content="/blog/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="纯天然绿色学渣"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/blog/2019/10/22/synchronized-%E5%92%8C-Lock/" class="post-title-link" itemprop="url">synchronized 和 Lock</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-22 18:51:56" itemprop="dateCreated datePublished" datetime="2019-10-22T18:51:56+08:00">2019-10-22</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-10-24 09:40:50" itemprop="dateModified" datetime="2019-10-24T09:40:50+08:00">2019-10-24</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/blog/2019/10/22/synchronized-%E5%92%8C-Lock/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/2019/10/22/synchronized-%E5%92%8C-Lock/" itemprop="commentCount"></span> </a></span><span id="/blog/2019/10/22/synchronized-%E5%92%8C-Lock/" class="leancloud_visitors" data-flag-title="synchronized 和 Lock"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body han-init-context" itemprop="articleBody"><h1><a id="_1"></a>锁的相关概念介绍</h1><h2><a id="_2"></a><a class="header-anchor" href="#可重入锁">¶</a>可重入锁</h2><p>如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。</p><p>看下面这段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * LockTest class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2017/09/22</span><br><span class="line"> */</span><br><span class="line">public class LockTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        final LockTest test = new LockTest();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            test.get();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            test.get();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void get() &#123;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void method2() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>你认为结果会是怎样的呢，会不会造成死锁呢？</b></p><p>上述代码中的两个方法method1和method2都用synchronized修饰了，假如某一时刻，线程A执行到了method1，此时线程A获取了这个对象的锁，而由于method2也是synchronized方法，假如synchronized不具备可重入性，此时线程A需要重新申请锁。但是这就会造成一个问题，因为线程A已经持有了该对象的锁，而又在申请获取该对象的锁，这样就会线程A一直等待永远不会获取到的锁。<br>而由于synchronized和Lock都具备可重入性，所以不会发生上述现象</p><h2><a id="_12"></a><a class="header-anchor" href="#可中断锁">¶</a>可中断锁</h2><p>可中断锁：顾名思义，就是可以相应中断的锁。<br>在Java中，synchronized就不是可中断锁，而Lock是可中断锁。<br>如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。<br>在前面演示lockInterruptibly()的用法时已经体现了Lock的可中断性。</p><h2><a id="_18"></a><a class="header-anchor" href="#公平锁">¶</a>公平锁</h2><p>公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。<br>非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。<br>在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。<br>而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/UTOOLS1571752755472.png" alt><br>在ReentrantLock中定义了2个静态内部类，一个是NotFairSync，一个是FairSync，分别用来实现非公平锁和公平锁。<br>我们可以在创建ReentrantLock对象时，通过以下方式来设置锁的公平性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = new ReentrantLock(true);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/UTOOLS1571752769518.png" alt><br>另外在ReentrantLock类中定义了很多方法，比如：</p><ul><li>isFair() //判断锁是否是公平锁</li><li>isLocked() //判断锁是否被任何线程获取了</li><li>isHeldByCurrentThread() //判断锁是否被当前线程获取了</li><li>hasQueuedThreads() //判断是否有线程在等待该锁</li></ul><p>在ReentrantReadWriteLock中也有类似的方法，同样也可以设置为公平锁和非公平锁。不过要记住，ReentrantReadWriteLock并未实现Lock接口，它实现的是ReadWriteLock接口。</p><h2><a id="_36"></a><a class="header-anchor" href="#读写锁">¶</a>读写锁</h2><p>读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。<br>正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。<br>ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。<br>可以通过readLock()获取读锁，通过writeLock()获取写锁。</p><h1><a id="synchronized_43"></a>synchronized</h1><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，只有一个线程可以执行某个方法或某个代码块，同时synchronized可以保证一个线程的变化可见（可见性），即可以代替volatile，保证共享变量的内存可见性</p><h4><a id="_45"></a><a class="header-anchor" href="#常见的几种应用是：">¶</a>常见的几种应用是：</h4><ul><li>synchronized(this)、synchronize方法</li><li>synchronized(class)、synchronized静态同步方法</li><li>synchronized(Object)</li></ul><h3><a id="synchronizedthissynchronize_50"></a><a class="header-anchor" href="#synchronized-this-synchronize方法">¶</a>synchronized(this)、synchronize方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Lock1 class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2017/09/22</span><br><span class="line"> */</span><br><span class="line">public class SynchronizedTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        SynchronizedTest synchronizedTest = new SynchronizedTest();</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(100);</span><br><span class="line"></span><br><span class="line">        executorService.execute(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                synchronizedTest.test();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        // 保证第一个线程先启动并执行</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        executorService.execute(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                synchronizedTest.test2();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test() throws InterruptedException &#123;</span><br><span class="line">        synchronized (this)&#123;</span><br><span class="line">            System.out.println(&quot;test start&quot;);</span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line">            System.out.println(&quot;test end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void test2() &#123;</span><br><span class="line">        synchronized (this)&#123;</span><br><span class="line">            System.out.println(&quot;test22222222 start&quot;);</span><br><span class="line">            System.out.println(&quot;test22222222 end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test start</span><br><span class="line">test end</span><br><span class="line">test22222222 start</span><br><span class="line">test22222222 end</span><br></pre></td></tr></table></figure><p>将test2方法的锁去掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void test2() &#123;</span><br><span class="line">    System.out.println(&quot;test22222222 start&quot;);</span><br><span class="line">    System.out.println(&quot;test22222222 end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test start</span><br><span class="line">test22222222 start</span><br><span class="line">test22222222 end</span><br><span class="line">test end</span><br></pre></td></tr></table></figure><p>将test2改成方法锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void test2() &#123;</span><br><span class="line">    System.out.println(&quot;test22222222 start&quot;);</span><br><span class="line">    System.out.println(&quot;test22222222 end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test start</span><br><span class="line">test end</span><br><span class="line">test22222222 start</span><br><span class="line">test22222222 end</span><br></pre></td></tr></table></figure><h4><a id="_62"></a><a class="header-anchor" href="#总结">¶</a>总结</h4><p>上面的结果我们能看到即使 test方法 耗时较长，test2方法 也并不会获得执行的机会，<br>如果将 test2方法 的同步锁去掉，test2方法 就可以执行<br>如果将 test2方法 改成方法锁，执行结果和 synchronized(this) 结果相同<br>so,<br><strong>synchronized (this)使用的对象监视器该对象自身, 当一个线程访问SynchronizedTest中的一个synchronized (this)同步代码块时，其它线程对同一个SynchronizedTest中的synchronized (this)【包括本方法和其它被修饰的方法】同步代码块的访问将是堵塞，实现了代码顺序的同步执行</strong><br><strong>synchronized(this) == synchronize方法 【前提是this不是写在其他线程里的，如果是写在其他线程里的，则代表这个线程对象】</strong></p><h3><a id="synchronizedObject_70"></a><a class="header-anchor" href="#synchronized-object">¶</a>synchronized(Object)</h3><h5><a id="object_71"></a><a class="header-anchor" href="#object">¶</a>object</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">/**</span><br><span class="line"> * Lock1 class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2017/09/22</span><br><span class="line"> */</span><br><span class="line">public class SynchronizedTest &#123;</span><br><span class="line"></span><br><span class="line">    private Object objectLock = new Object();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        SynchronizedTest synchronizedTest = new SynchronizedTest();</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(100);</span><br><span class="line"></span><br><span class="line">        executorService.execute(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                synchronizedTest.test(&quot;线程A&quot;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        // 保证第一个线程先启动并执行</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        executorService.execute(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                synchronizedTest.test(&quot;线程B&quot;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test(String msg) throws InterruptedException &#123;</span><br><span class="line">        synchronized (objectLock)&#123;</span><br><span class="line">            System.out.println(msg + &quot; test start&quot;);</span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line">            System.out.println(msg + &quot; test end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程A test start</span><br><span class="line">线程A test end</span><br><span class="line">线程B test start</span><br><span class="line">线程B test end</span><br></pre></td></tr></table></figure><p>将 objectLock 锁对象放入到 <strong>方法内</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void test(String msg) throws InterruptedException &#123;</span><br><span class="line">    Object objectLock = new Object();</span><br><span class="line">    synchronized (objectLock)&#123;</span><br><span class="line">        System.out.println(msg + &quot; test start&quot;);</span><br><span class="line">        Thread.sleep(5000);</span><br><span class="line">        System.out.println(msg + &quot; test end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程A test start</span><br><span class="line">线程B test start</span><br><span class="line">线程A test end</span><br><span class="line">线程B test end</span><br></pre></td></tr></table></figure><h4><a id="_79"></a><a class="header-anchor" href="#总结-v2">¶</a>总结</h4><p>object 和 this 本质上是一样的，只不过this是当前对象，而object是我们额外引入的对象</p><h3><a id="synchronizedclasssynchronized_82"></a><a class="header-anchor" href="#synchronized-class-synchronized静态同步方法">¶</a>synchronized(class)、synchronized静态同步方法</h3><h5><a id="class_83"></a><a class="header-anchor" href="#class">¶</a>class</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * LockTest class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2017/09/22</span><br><span class="line"> */</span><br><span class="line">public class LockTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line"></span><br><span class="line">        LockTest lockTest = new LockTest();</span><br><span class="line">        LockTest lockTest2 = new LockTest();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            synchronized (LockTest.class)&#123;</span><br><span class="line">                lockTest.print();</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            synchronized (LockTest.class)&#123;</span><br><span class="line">                lockTest2.print();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;父类正在执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果发现 线程2 也是无法执行的，至到 线程1 释放锁</p><h5><a id="synchronized_86"></a><a class="header-anchor" href="#静态同步synchronized方法">¶</a>静态同步synchronized方法</h5><p>把 print 方法改成静态锁方法，发现结果和锁class是一样的</p><h4><a id="_89"></a><a class="header-anchor" href="#总结-v3">¶</a>总结</h4><p>静态同步synchronized方法 默认锁的是当前的.class对象，<br>通过实例可以发现 class 锁的当前对象的所有实例，区别于this，this只是锁当前的实例对象<br>so, <strong>synchronized(class) == synchronized静态同步方法</strong></p><h1><a id="Lock_95"></a>Lock</h1><h2><a id="_96"></a><a class="header-anchor" href="#概念">¶</a>概念</h2><p>synchronized是java中的一个关键字，也就是说是Java语言内置的特性。那么为什么会出现Lock呢？<br>如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：</p><ul><li>获取锁的线程执行完了该代码块，然后线程释放对锁的占有</li><li>线程执行发生异常，此时JVM会让线程自动释放锁。</li></ul><p>那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。<br>因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。<br>再举个例子：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。<br>但是采用synchronized关键字来实现同步的话，就会导致一个问题：<br>如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。<br>因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。</p><p>另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。<br>总结一下，也就是说Lock提供了比synchronized更多的功能。但是要注意以下几点：</p><ul><li>Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；</li><li>Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</li></ul><p>首先要说明的就是Lock，通过查看Lock的源码可知，Lock是一个接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Lock &#123;</span><br><span class="line">    void lock();</span><br><span class="line">    void lockInterruptibly() throws InterruptedException;</span><br><span class="line">    boolean tryLock();</span><br><span class="line">    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line">    void unlock();</span><br><span class="line">    Condition newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lock()、tryLock()、tryLock(long time, TimeUnit unit)和lockInterruptibly()是用来获取锁的<br>unLock()方法是用来释放锁的</p><p>在Lock中声明了四个方法来获取锁，那么这四个方法有何区别呢？<br>首先lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待</p><h5><a id="lock_122"></a><a class="header-anchor" href="#lock">¶</a>lock()</h5><p>由于在前面讲到如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。</p><p>通常使用Lock来进行同步的话，是以下面这种形式去使用的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line">lock.lock();</span><br><span class="line">try&#123;</span><br><span class="line">    //处理任务</span><br><span class="line">&#125;catch(Exception ex)&#123;</span><br><span class="line">     </span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    lock.unlock();   //释放锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><a id="tryLocktryLocklong_time_TimeUnit_unit_127"></a><a class="header-anchor" href="#trylock-trylock-long-time-timeunit-unit">¶</a>tryLock()、tryLock(long time, TimeUnit unit)</h5><p>tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。<br>tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true</p><p>所以，一般情况下通过tryLock来获取锁时是这样使用的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line">if(lock.tryLock()) &#123;</span><br><span class="line">     try&#123;</span><br><span class="line">         //处理任务</span><br><span class="line">     &#125;catch(Exception ex)&#123;</span><br><span class="line">         </span><br><span class="line">     &#125;finally&#123;</span><br><span class="line">         lock.unlock();   //释放锁</span><br><span class="line">     &#125; </span><br><span class="line">&#125;else &#123;</span><br><span class="line">    //如果不能获取锁，则直接做其他事情</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><a id="lockInterruptibly_134"></a><a class="header-anchor" href="#lockinterruptibly">¶</a>lockInterruptibly()</h5><p>lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。</p><p>由于lockInterruptibly()的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly()的方法外声明抛出InterruptedException。</p><p>因此lockInterruptibly()一般的使用形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void method() throws InterruptedException &#123;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;  </span><br><span class="line">     //.....</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red">注意:</font><br>当一个线程获取了锁之后，是不会被interrupt()方法中断的。单独调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。</p><h2><a id="ReentrantLock_144"></a><a class="header-anchor" href="#reentrantlock">¶</a>ReentrantLock</h2><p>ReentrantLock，意思是“可重入锁”，ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。<br>具体的使用和synchronized 差不多，都需要注意锁的对象，不要把lock对象定义在方法中，导致线程不能共享锁</p><p>lock()、tryLock()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">**</span><br><span class="line"> * LockTest class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2017/09/22</span><br><span class="line"> */</span><br><span class="line">public class LockTest &#123;</span><br><span class="line"></span><br><span class="line">    private ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        final LockTest test = new LockTest();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            test.lock(Thread.currentThread());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            test.lock(Thread.currentThread());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void lock(Thread thread) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(thread.getName()+&quot;得到了锁&quot;);</span><br><span class="line">            </span><br><span class="line">            // TODO: 2019/10/22 执行业务逻辑 </span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // TODO: handle exception</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            System.out.println(thread.getName()+&quot;释放了锁&quot;);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void tryLock(Thread thread) &#123;</span><br><span class="line">        if(lock.tryLock()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(thread.getName()+&quot;得到了锁&quot;);</span><br><span class="line"></span><br><span class="line">                // TODO: 2019/10/22 执行业务逻辑</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                // TODO: handle exception</span><br><span class="line">            &#125;finally &#123;</span><br><span class="line">                System.out.println(thread.getName()+&quot;释放了锁&quot;);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(thread.getName()+&quot;获取锁失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lockInterruptibly()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * LockTest class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2017/09/22</span><br><span class="line"> */</span><br><span class="line">public class LockTest &#123;</span><br><span class="line"></span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        final LockTest test = new LockTest();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                test.lockInterruptibly(Thread.currentThread());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;被中断&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread thread2 = new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                test.lockInterruptibly(Thread.currentThread());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;被中断&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line"></span><br><span class="line">        thread2.interrupt();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(10000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void lockInterruptibly(Thread thread) throws InterruptedException &#123;</span><br><span class="line">        //注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将InterruptedException抛出</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(thread.getName()+&quot;得到了锁&quot;);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line"></span><br><span class="line">            // TODO: 2019/10/22 执行业务逻辑</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;执行finally&quot;);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(thread.getName()+&quot;释放了锁&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，发现thread2能够被正确中断。</p><h2><a id="ReadWriteLock_154"></a><a class="header-anchor" href="#readwritelock">¶</a>ReadWriteLock</h2><p>ReadWriteLock也是一个接口，在它里面只定义了两个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface ReadWriteLock &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Returns the lock used for reading.</span><br><span class="line">     *</span><br><span class="line">     * @return the lock used for reading.</span><br><span class="line">     */</span><br><span class="line">    Lock readLock();</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * Returns the lock used for writing.</span><br><span class="line">     *</span><br><span class="line">     * @return the lock used for writing.</span><br><span class="line">     */</span><br><span class="line">    Lock writeLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的ReentrantReadWriteLock实现了ReadWriteLock接口。</p><h2><a id="ReentrantReadWriteLock_159"></a><a class="header-anchor" href="#reentrantreadwritelock">¶</a>ReentrantReadWriteLock</h2><p>ReentrantReadWriteLock里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和writeLock()用来获取读锁和写锁。<br>假如有多个线程要同时进行读操作的话，先看一下synchronized达到的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * LockTest class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2017/09/22</span><br><span class="line"> */</span><br><span class="line">public class LockTest &#123;</span><br><span class="line"></span><br><span class="line">    private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        final LockTest test = new LockTest();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            test.get(Thread.currentThread());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            test.get(Thread.currentThread());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void get(Thread thread) &#123;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        while(System.currentTimeMillis() - start &lt;= 1) &#123;</span><br><span class="line">            System.out.println(thread.getName()+&quot;正在进行读操作&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(thread.getName()+&quot;读操作完毕&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序的输出结果会是，直到thread1执行完读操作之后，才会打印thread2执行读操作的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0读操作完毕</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1读操作完毕</span><br></pre></td></tr></table></figure><p>而改成用读写锁的话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * LockTest class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2017/09/22</span><br><span class="line"> */</span><br><span class="line">public class LockTest &#123;</span><br><span class="line"></span><br><span class="line">    private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        final LockTest test = new LockTest();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            test.get(Thread.currentThread());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            test.get(Thread.currentThread());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void get(Thread thread) &#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            while(System.currentTimeMillis() - start &lt;= 1) &#123;</span><br><span class="line">                System.out.println(thread.getName()+&quot;正在进行读操作&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(thread.getName()+&quot;读操作完毕&quot;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-0正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-0读操作完毕</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1正在进行读操作</span><br><span class="line">Thread-1读操作完毕</span><br></pre></td></tr></table></figure><p>说明thread1和thread2在同时进行读操作。<br>这样就大大提升了读操作的效率。<br>不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。<br>如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。</p><h2><a id="Condition__174"></a><a class="header-anchor" href="#condition-类">¶</a>Condition 类</h2><p>Condition与重入锁是通过lock.newCondition()方法产生一个与当前重入锁绑定的Condtion实例，我们通知该实例来控制线程的等待与通知。该接口的所有方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface Condition &#123;</span><br><span class="line">     //当前线程进入等待状态，直到被通知（signal）或者被中断时，当前线程进入运行状态，从await()返回。与Object.wait()类似。</span><br><span class="line">    void await() throws InterruptedException;</span><br><span class="line"> </span><br><span class="line">    //当前线程进入等待状态，直到被通知，对中断不做响应； </span><br><span class="line">    //线程在调用condition.await()后处于await状态，此时调用thread.interrupt()会报错</span><br><span class="line">    //但是使用condition.awaitUninterruptibly()后，调用thread.interrupt()则不会报错</span><br><span class="line">    void awaitUninterruptibly();</span><br><span class="line"> </span><br><span class="line">    //nanosTimeout指定该方法等待信号的的最大时间（单位为纳秒）。若指定时间内收到signal()或signalALL()则返回nanosTimeout减去已经等待的时间；</span><br><span class="line">    //若指定时间内有其它线程中断该线程，则抛出InterruptedException并清除当前线程的打断状态；</span><br><span class="line">    //增加了超时响应，返回值表示当前剩余的时间，如果在nanosTimeout之前被唤醒，返回值 = nanosTimeout - 实际消耗的时间，返回值 &lt;= 0表示超时；</span><br><span class="line">    long awaitNanos(long nanosTimeout) throws InterruptedException;</span><br><span class="line"> </span><br><span class="line">    //与await()基本一致，唯一不同点在于，返回值返回true/false，在time之前被唤醒，返回true，超时返回false。</span><br><span class="line">    boolean await(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line"> </span><br><span class="line">   //适用条件与行为与awaitNanos(long nanosTimeout)完全一样，唯一不同点在于它不是等待指定时间，而是等待由参数指定的某一时刻。</span><br><span class="line">    boolean awaitUntil(Date deadline) throws InterruptedException;</span><br><span class="line">    </span><br><span class="line">    //唤醒一个在 await()等待队列中的线程。与Object.notify()相似</span><br><span class="line">    void signal();</span><br><span class="line"> </span><br><span class="line">   //唤醒 await()等待队列中所有的线程。与object.notifyAll()相似</span><br><span class="line">    void signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><a id="CountDownLatch_178"></a><a class="header-anchor" href="#countdownlatch">¶</a>CountDownLatch</h2><ul><li>countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。</li><li>是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。</li></ul><p>countDownLatch类中只提供了一个构造器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//参数count为计数值</span><br><span class="line">public CountDownLatch(int count) &#123;  &#125;;</span><br></pre></td></tr></table></figure><p>类中有三个方法是最重要的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span><br><span class="line">public void await() throws InterruptedException &#123; &#125;;   </span><br><span class="line">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span><br><span class="line">public boolean await(long timeout, TimeUnit unit) throws InterruptedException &#123; &#125;;  </span><br><span class="line">//将count值减1</span><br><span class="line">public void countDown() &#123; &#125;;</span><br></pre></td></tr></table></figure><h2><a id="CyclicBarrier_187"></a><a class="header-anchor" href="#cyclicbarrier">¶</a>CyclicBarrier</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//调用await方法的线程告诉CyclicBarrier自己已经到达同步点，然后当前线程被阻塞。直到parties个参与线程调用了await方法，CyclicBarrier同样提供带超时时间的await和不带超时时间的await方法</span><br><span class="line">await()</span><br><span class="line">//broken标识该当前CyclicBarrier是否已经处于中断状态。</span><br><span class="line">//默认barrier是没有损坏的。当barrier损坏了或者有一个线程中断了，则通过breakBarrier()来终止所有的线程</span><br><span class="line">breakBarrier()</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>dowait(boolean, long)方法，它也是CyclicBarrier的核心方法，该方法定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">private int dowait(boolean timed, long nanos)</span><br><span class="line">    throws InterruptedException, BrokenBarrierException,</span><br><span class="line">            TimeoutException &#123;</span><br><span class="line">    // 获取独占锁</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 当前代</span><br><span class="line">        final Generation g = generation;</span><br><span class="line">        // 如果这代损坏了，抛出异常</span><br><span class="line">        if (g.broken)</span><br><span class="line">            throw new BrokenBarrierException();</span><br><span class="line"> </span><br><span class="line">        // 如果线程中断了，抛出异常</span><br><span class="line">        if (Thread.interrupted()) &#123;</span><br><span class="line">            // 将损坏状态设置为true</span><br><span class="line">            // 并通知其他阻塞在此栅栏上的线程</span><br><span class="line">            breakBarrier();</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        // 获取下标</span><br><span class="line">        int index = --count;</span><br><span class="line">        // 如果是 0，说明最后一个线程调用了该方法</span><br><span class="line">        if (index == 0) &#123;  // tripped</span><br><span class="line">            boolean ranAction = false;</span><br><span class="line">            try &#123;</span><br><span class="line">                final Runnable command = barrierCommand;</span><br><span class="line">                // 执行栅栏任务</span><br><span class="line">                if (command != null)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = true;</span><br><span class="line">                // 更新一代，将count重置，将generation重置</span><br><span class="line">                // 唤醒之前等待的线程</span><br><span class="line">                nextGeneration();</span><br><span class="line">                return 0;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // 如果执行栅栏任务的时候失败了，就将损坏状态设置为true</span><br><span class="line">                if (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        // loop until tripped, broken, interrupted, or timed out</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                 // 如果没有时间限制，则直接等待，直到被唤醒</span><br><span class="line">                if (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                // 如果有时间限制，则等待指定时间</span><br><span class="line">                else if (nanos &gt; 0L)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                // 当前代没有损坏</span><br><span class="line">                if (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    // 让栅栏失效</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    throw ie;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 上面条件不满足，说明这个线程不是这代的</span><br><span class="line">                    // 就不会影响当前这代栅栏的执行，所以，就打个中断标记</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            // 当有任何一个线程中断了，就会调用breakBarrier方法</span><br><span class="line">            // 就会唤醒其他的线程，其他线程醒来后，也要抛出异常</span><br><span class="line">            if (g.broken)</span><br><span class="line">                throw new BrokenBarrierException();</span><br><span class="line"> </span><br><span class="line">            // g != generation表示正常换代了，返回当前线程所在栅栏的下标</span><br><span class="line">            // 如果 g == generation，说明还没有换代，那为什么会醒了？</span><br><span class="line">            // 因为一个线程可以使用多个栅栏，当别的栅栏唤醒了这个线程，就会走到这里，所以需要判断是否是当前代。</span><br><span class="line">            // 正是因为这个原因，才需要generation来保证正确。</span><br><span class="line">            if (g != generation)</span><br><span class="line">                return index;</span><br><span class="line">            </span><br><span class="line">            // 如果有时间限制，且时间小于等于0，销毁栅栏并抛出异常</span><br><span class="line">            if (timed &amp;&amp; nanos &lt;= 0L) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                throw new TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 释放独占锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dowait(boolean, long)方法的主要逻辑处理比较简单，如果该线程不是最后一个调用await方法的线程，则它会一直处于等待状态，除非发生以下情况：</p><ul><li>最后一个线程到达，即index == 0</li><li>某个参与线程等待超时</li><li>某个参与线程被中断</li><li>调用了CyclicBarrier的reset()方法。该方法会将屏障重置为初始状态<br>在上面的源代码中，我们可能需要注意Generation 对象，在上述代码中我们总是可以看到抛出BrokenBarrierException异常，那么什么时候抛出异常呢？如果一个线程处于等待状态时，如果其他线程调用reset()，或者调用的barrier原本就是被损坏的，则抛出BrokenBarrierException异常。同时，任何线程在等待时被中断了，则其他所有线程都将抛出BrokenBarrierException异常，并将barrier置于损坏状态。</li></ul><p>同时，Generation描述着CyclicBarrier的更新换代。在CyclicBarrier中，同一批线程属于同一代。当有parties个线程到达barrier之后，generation就会被更新换代。其中broken标识该当前CyclicBarrier是否已经处于中断状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static class Generation &#123;</span><br><span class="line">    boolean broken = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认barrier是没有损坏的。当barrier损坏了或者有一个线程中断了，则通过breakBarrier()来终止所有的线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void breakBarrier() &#123;</span><br><span class="line">    generation.broken = true;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在breakBarrier()中除了将broken设置为true，还会调用signalAll将在CyclicBarrier处于等待状态的线程全部唤醒。</p><p>当所有线程都已经到达barrier处（index == 0），则会通过nextGeneration()进行更新换地操作，在这个步骤中，做了三件事：唤醒所有线程，重置count，generation：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void nextGeneration() &#123;</span><br><span class="line">    // signal completion of last generation</span><br><span class="line">    trip.signalAll();</span><br><span class="line">    // set up next generation</span><br><span class="line">    count = parties;</span><br><span class="line">    generation = new Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了上面讲到的栅栏更新换代以及损坏状态，我们在使用CyclicBarrier时还要要注意以下几点：</p><ul><li>CyclicBarrier使用独占锁来执行await方法，并发性可能不是很高</li><li>如果在等待过程中，线程被中断了，就抛出异常。但如果中断的线程所对应的CyclicBarrier不是这代的，比如，在最后一次线程执行signalAll后，并且更新了这个“代”对象。在这个区间，这个线程被中断了，那么，JDK认为任务已经完成了，就不必在乎中断了，只需要打个标记。该部分源码已在dowait(boolean, long)方法中进行了注释。</li><li>如果线程被其他的CyclicBarrier唤醒了，那么g肯定等于generation，这个事件就不能return了，而是继续循环阻塞。反之，如果是当前CyclicBarrier唤醒的，就返回线程在CyclicBarrier的下标。完成了一次冲过栅栏的过程。该部分源码已在dowait(boolean, long)方法中进行了注释。</li></ul><p>我们自定义的工作线程必须要等所有参与线程开始之后才可以执行，我们可以使用CyclicBarrier类来帮助我们完成。从程序的执行结果中也可以看出，所有的工作线程都运行await()方法之后都到达了栅栏位置，然后，工作线程才开始执行业务处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class CyclicBarrier &#123;</span><br><span class="line">    </span><br><span class="line">    private static class Generation &#123;</span><br><span class="line">        boolean broken = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 独占锁成员</span><br><span class="line">    private final ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    // 条件成员</span><br><span class="line">    private final Condition trip = lock.newCondition();</span><br><span class="line">    // 必须满足障碍条件的线程个数</span><br><span class="line">    private final int parties;</span><br><span class="line">    // 当障碍条件满足会被自动执行的任务</span><br><span class="line">    private final Runnable barrierCommand;</span><br><span class="line">    // 当前世代(cyclicBarrier可重复利用，每一次利用是一个世代)</span><br><span class="line">    private Generation generation = new Generation();</span><br><span class="line">    // 满足障碍锁条件还需要的阻塞线程个数</span><br><span class="line">    private int count;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    ..</span><br><span class="line">    .</span><br><span class="line">    // 构造函数</span><br><span class="line">    public CyclicBarrier(int parties, Runnable barrierAction) &#123;</span><br><span class="line">        if (parties &lt;= 0) throw new IllegalArgumentException();</span><br><span class="line">        // 初始化障碍条件总数</span><br><span class="line">        this.parties = parties;</span><br><span class="line">        // 初始化阻塞线程个数</span><br><span class="line">        this.count = parties;</span><br><span class="line">        // 初始化条件满足时自动执行任务</span><br><span class="line">        this.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">public int await() throws InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 调用dowait来实现。</span><br><span class="line">        return dowait(false, 0L);</span><br><span class="line">    &#125; catch (TimeoutException toe) &#123;</span><br><span class="line">        throw new Error(toe); // cannot happen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> private int dowait(boolean timed, long nanos)</span><br><span class="line">        throws InterruptedException, BrokenBarrierException,</span><br><span class="line">               TimeoutException &#123;</span><br><span class="line">    // 获取独占锁。下面的操作都是同步的。</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 设置当前世代</span><br><span class="line">        final Generation g = generation;</span><br><span class="line"></span><br><span class="line">        if (g.broken)</span><br><span class="line">            throw new BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        if (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        // 由于本线程调用await()，则需要的阻塞线程个数-1。</span><br><span class="line">       int index = --count;</span><br><span class="line">       // 若为0则代表障碍条件满足</span><br><span class="line">       if (index == 0) &#123;  // tripped</span><br><span class="line">           boolean ranAction = false;</span><br><span class="line">           try &#123;</span><br><span class="line">               // 执行注册的自动执行任务</span><br><span class="line">               final Runnable command = barrierCommand;</span><br><span class="line">               if (command != null)</span><br><span class="line">                   command.run();</span><br><span class="line">               ranAction = true;</span><br><span class="line">               // 设置世代为下一世代，以方便障碍锁的二次利用。</span><br><span class="line">               nextGeneration();</span><br><span class="line">               return 0;</span><br><span class="line">           &#125; finally &#123;</span><br><span class="line">               if (!ranAction)</span><br><span class="line">                   breakBarrier();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        // 通过循环</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 若没有阻塞时间限制，则阻塞</span><br><span class="line">                if (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                // 若有阻塞时间限制，则阻塞相应的时间</span><br><span class="line">                else if (nanos &gt; 0L)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                if (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    throw ie;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (g.broken)</span><br><span class="line">                throw new BrokenBarrierException();</span><br><span class="line">            // 阻塞线程被唤醒后，若generation已被更新则代表障碍条件达成，线程继续执行。</span><br><span class="line">            if (g != generation)</span><br><span class="line">                return index;</span><br><span class="line">            // 阻塞线程若超过了阻塞时间，被唤醒后，则抛出异常</span><br><span class="line">            if (timed &amp;&amp; nanos &lt;= 0L) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                throw new TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 释放同步锁。</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">.....</span><br><span class="line">...</span><br><span class="line">..</span><br><span class="line">// 更新当前障碍锁世代。</span><br><span class="line">private void nextGeneration() &#123;</span><br><span class="line">    // 唤醒所有在当前障碍锁上阻塞的线程</span><br><span class="line">    trip.signalAll();</span><br><span class="line">    // reset障碍锁条件</span><br><span class="line">    count = parties;</span><br><span class="line">    // 初始化新世代</span><br><span class="line">    generation = new Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><a id="CyclicBarrierCountDownLatch_216"></a><a class="header-anchor" href="#cyclicbarrier和countdownlatch的区别">¶</a>CyclicBarrier和CountDownLatch的区别</h4><ul><li>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置，可以使用多次，所以CyclicBarrier能够处理更为复杂的场景；</li><li>CyclicBarrier还提供了一些其他有用的方法，比如getNumberWaiting()方法可以获得CyclicBarrier阻塞的线程数量，isBroken()方法用来了解阻塞的线程是否被中断；</li><li>CountDownLatch允许一个或多个线程等待一组事件的产生，而CyclicBarrier用于等待其他线程运行到栅栏位置。</li><li>CountDownLatch : 一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行。 CyclicBarrier : N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。这样应该就清楚一点了，对于CountDownLatch来说，重点是那个“一个线程”, 是它在等待， 而另外那N的线程在把“某个事</li><li>情”做完之后可以继续等待，可以终止。而对于CyclicBarrier来说，重点是那N个线程，他们之间任何一个没有完成，所有的线程都必须等待。</li></ul><h1><a id="Locksynchronized_224"></a>Lock和synchronized的选择</h1><p>总结来说，Lock和synchronized有以下几点不同：</p><ul><li>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</li><li>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</li><li>Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li><li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</li><li>Lock可以提高多个线程进行读操作的效率。<br>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jeff-eric.github.com/blog/blog/2019/10/22/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8C%96/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jeff-Eric"><meta itemprop="description" content=""><meta itemprop="image" content="/blog/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="纯天然绿色学渣"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/blog/2019/10/22/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8C%96/" class="post-title-link" itemprop="url">分布式架构的演化</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-22 18:51:56" itemprop="dateCreated datePublished" datetime="2019-10-22T18:51:56+08:00">2019-10-22</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-11-26 14:00:08" itemprop="dateModified" datetime="2019-11-26T14:00:08+08:00">2019-11-26</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/blog/2019/10/22/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8C%96/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/2019/10/22/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8C%96/" itemprop="commentCount"></span> </a></span><span id="/blog/2019/10/22/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8C%96/" class="leancloud_visitors" data-flag-title="分布式架构的演化"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body han-init-context" itemprop="articleBody"><p><img src="/blog/.com//20191126015724169.png" alt></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jeff-eric.github.com/blog/blog/2019/10/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A2%98%E7%9B%AE/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jeff-Eric"><meta itemprop="description" content=""><meta itemprop="image" content="/blog/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="纯天然绿色学渣"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/blog/2019/10/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A2%98%E7%9B%AE/" class="post-title-link" itemprop="url">多线程题目</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-22 18:51:56" itemprop="dateCreated datePublished" datetime="2019-10-22T18:51:56+08:00">2019-10-22</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-10-24 14:55:38" itemprop="dateModified" datetime="2019-10-24T14:55:38+08:00">2019-10-24</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/blog/2019/10/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A2%98%E7%9B%AE/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/2019/10/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A2%98%E7%9B%AE/" itemprop="commentCount"></span> </a></span><span id="/blog/2019/10/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A2%98%E7%9B%AE/" class="leancloud_visitors" data-flag-title="多线程题目"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body han-init-context" itemprop="articleBody"><h3><a id="ASCII11001100_1"></a><a class="header-anchor" href="#实现在一个程序中同时完成如下两个任务-任务一：能将ascii值为1到100对应的字符输出到控制台；任务二：能将1-100的数以数输出-要求他们交叉输出">¶</a>实现在一个程序中同时完成如下两个任务，任务一：能将ASCII值为1到100对应的字符输出到控制台；任务二：能将1-100的数以数输出。要求他们交叉输出。</h3><details><summary>方法一</summary><pre><code>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Test1 class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2019/10/23</span><br><span class="line"> */</span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(100);</span><br><span class="line"></span><br><span class="line">        Test test = new Test();</span><br><span class="line">        executorService.execute(()-&gt;&#123;</span><br><span class="line">            test.ascll();</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.execute(()-&gt;&#123;</span><br><span class="line">            test.number();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void ascll()&#123;</span><br><span class="line">        for (int i = 1; i &lt; 100; i++) &#123;</span><br><span class="line">            System.out.println((char)i);</span><br><span class="line">            notify();</span><br><span class="line">            try &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void number()&#123;</span><br><span class="line">        for (int i = 1; i &lt; 100; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            notify();</span><br><span class="line">            try &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre></details><details><summary>方法二</summary><pre><code>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Test1 class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2019/10/23</span><br><span class="line"> */</span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    volatile boolean lock = false;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(100);</span><br><span class="line"></span><br><span class="line">        Test test = new Test();</span><br><span class="line">        executorService.execute(()-&gt;&#123;</span><br><span class="line">            test.ascll();</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.execute(()-&gt;&#123;</span><br><span class="line">            test.number();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ascll()&#123;</span><br><span class="line">        for (int i = 1; i &lt; 100; i++) &#123;</span><br><span class="line">            while (lock)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println((char)i);</span><br><span class="line">            lock = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void number()&#123;</span><br><span class="line">        for (int i = 1; i &lt; 100; i++) &#123;</span><br><span class="line">            while (!lock)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            lock = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre></details><details><summary>方法三</summary><pre><code>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Test1 class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2019/10/23</span><br><span class="line"> */</span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(100);</span><br><span class="line"></span><br><span class="line">        Test test = new Test();</span><br><span class="line">        executorService.execute(()-&gt;&#123;</span><br><span class="line">            test.ascll();</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.execute(()-&gt;&#123;</span><br><span class="line">            test.number();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ascll()&#123;</span><br><span class="line">        for (int i = 1; i &lt; 100; i++) &#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println((char)i);</span><br><span class="line">                condition.signal();</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void number()&#123;</span><br><span class="line">        for (int i = 1; i &lt; 100; i++) &#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                condition.signal();</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre></details><details><summary>方法四</summary><pre><code>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Test1 class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2019/10/23</span><br><span class="line"> */</span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">//    CountDownLatch countDownLatch = new CountDownLatch(1);</span><br><span class="line">    CyclicBarrier cyclicBarrier = new CyclicBarrier(2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(100);</span><br><span class="line">        Test test = new Test();</span><br><span class="line">        executorService.execute(()-&gt;&#123;</span><br><span class="line">            test.ascll();</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.execute(()-&gt;&#123;</span><br><span class="line">            test.number();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ascll()&#123;</span><br><span class="line">        for (int i = 1; i &lt; 100; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println((char)i);</span><br><span class="line">            try &#123;</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void number()&#123;</span><br><span class="line">        for (int i = 1; i &lt; 100; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            try &#123;</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre></details><details><summary>方法五</summary><pre><code>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Test1 class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2019/10/23</span><br><span class="line"> */</span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    Semaphore semaphore = new Semaphore(1, true);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(100);</span><br><span class="line">        Test test = new Test();</span><br><span class="line">        executorService.execute(()-&gt;&#123;</span><br><span class="line">            test.ascll();</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.execute(()-&gt;&#123;</span><br><span class="line">            test.number();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ascll()&#123;</span><br><span class="line">        // 保证另一个线程启动</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; 100; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println((char)i);</span><br><span class="line"></span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void number()&#123;</span><br><span class="line">        // 保证另一个线程启动</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; 100; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre></details><br><h1><a id="_40"></a>下一题</h1></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jeff-eric.github.com/blog/blog/2019/10/22/%E9%94%81/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jeff-Eric"><meta itemprop="description" content=""><meta itemprop="image" content="/blog/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="纯天然绿色学渣"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/blog/2019/10/22/%E9%94%81/" class="post-title-link" itemprop="url">锁</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-22 18:51:56" itemprop="dateCreated datePublished" datetime="2019-10-22T18:51:56+08:00">2019-10-22</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-10-23 10:16:13" itemprop="dateModified" datetime="2019-10-23T10:16:13+08:00">2019-10-23</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/blog/2019/10/22/%E9%94%81/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/2019/10/22/%E9%94%81/" itemprop="commentCount"></span> </a></span><span id="/blog/2019/10/22/%E9%94%81/" class="leancloud_visitors" data-flag-title="锁"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body han-init-context" itemprop="articleBody"><h1><a id="_1"></a>锁的种类</h1><ul><li>乐观锁、悲观锁</li><li>独享锁、共享锁</li><li>互斥锁、读写锁</li><li>可重入锁</li><li>公平锁、非公平锁</li><li>分段锁</li><li>自旋锁</li><li>偏向锁、轻量级锁、重量级锁</li></ul><p>以上是一些锁的名词，这些分类并不是全是指锁的状态，有的指锁的特性，有的指锁的设计，下面总结的内容是对每个锁的名词进行一定的解释。</p><h2><a id="_13"></a><a class="header-anchor" href="#乐观锁-悲观锁">¶</a>乐观锁、悲观锁</h2><p>乐观锁与悲观锁并不是特指某两种类型的锁，是人们定义出来的概念或思想，主要是指看待并发同步的角度。</p><p>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS(Compare and Swap 比较并交换)实现的。</p><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。比如Java里面的同步原语synchronized关键字的实现就是悲观锁。</p><p>悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。</p><p>悲观锁在Java中的使用，就是利用各种锁。<br>乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。</p><h3><a id="_25"></a><a class="header-anchor" href="#乐观锁">¶</a>乐观锁</h3><p>乐观锁总是认为不存在并发问题，每次去取数据的时候，总认为不会有其他线程对数据进行修改，因此不会上锁。但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用“数据版本机制”或“CAS操作”来实现。</p><h4><a id="_27"></a><a class="header-anchor" href="#数据版本机制">¶</a>数据版本机制</h4><p>实现数据版本一般有两种，第一种是使用版本号，第二种是使用时间戳。以版本号方式为例。</p><p>版本号方式：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。<br>核心SQL代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update table set xxx=#&#123;xxx&#125;, version=version+1 where id=#&#123;id&#125; and version=#&#123;version&#125;;</span><br></pre></td></tr></table></figure><h4><a id="CAS_33"></a><a class="header-anchor" href="#cas操作">¶</a>CAS操作</h4><p>CAS（Compare and Swap 比较并交换），当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p><p>CAS操作中包含三个操作数——需要读写的内存位置(V)、进行比较的预期原值(A)和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B，否则处理器不做任何操作。</p><h3><a id="_38"></a><a class="header-anchor" href="#悲观锁">¶</a>悲观锁</h3><p>悲观锁认为对于同一个数据的并发操作，一定会发生修改的，哪怕没有修改，也会认为修改。因此对于同一份数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁并发操作一定会出问题。</p><p>在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）<br>如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。<br>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。<br>期间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</p><h2><a id="_46"></a><a class="header-anchor" href="#独享锁-共享锁">¶</a>独享锁、共享锁</h2><p>独享锁是指该锁一次只能被一个线程所持有。<br>对于Java ReentrantLock而言，就是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。<br>读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的。<br>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。<br>对于Synchronized而言，当然是独享锁。</p><h2><a id="_53"></a><a class="header-anchor" href="#互斥锁-读写锁">¶</a>互斥锁、读写锁</h2><p>上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。<br>互斥锁在Java中的具体实现就是ReentrantLock。<br>读写锁在Java中的具体实现就是ReadWriteLock。</p><h2><a id="_58"></a><a class="header-anchor" href="#可重入锁">¶</a>可重入锁</h2><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。说的有点抽象，下面会有一个代码的示例。<br>对于Java ReetrantLock而言，从名字就可以看出是一个重入锁，其名字是Re entrant Lock 重新进入锁。<br>对于Synchronized而言，也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。<br>如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。</p><p>看下面这段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * LockTest class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2017/09/22</span><br><span class="line"> */</span><br><span class="line">public class LockTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        final LockTest test = new LockTest();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            test.get();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            test.get();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void get() &#123;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void method2() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>你认为结果会是怎样的呢，会不会造成死锁呢？</b></p><p>上述代码中的两个方法method1和method2都用synchronized修饰了，假如某一时刻，线程A执行到了method1，此时线程A获取了这个对象的锁，而由于method2也是synchronized方法，假如synchronized不具备可重入性，此时线程A需要重新申请锁。但是这就会造成一个问题，因为线程A已经持有了该对象的锁，而又在申请获取该对象的锁，这样就会线程A一直等待永远不会获取到的锁。<br>而由于synchronized和Lock都具备可重入性，所以不会发生上述现象</p><h2><a id="_71"></a><a class="header-anchor" href="#公平锁-非公平锁">¶</a>公平锁、非公平锁</h2><p>公平锁是指多个线程按照申请锁的顺序来获取锁。<br>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。<br>对于Java ReetrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。<br>对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。<br>公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。</p><p>非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。<br>在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。<br>而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/UTOOLS1571752809217.png" alt><br>在ReentrantLock中定义了2个静态内部类，一个是NotFairSync，一个是FairSync，分别用来实现非公平锁和公平锁。<br>我们可以在创建ReentrantLock对象时，通过以下方式来设置锁的公平性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = new ReentrantLock(true);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/UTOOLS1571752819916.png" alt><br>另外在ReentrantLock类中定义了很多方法，比如：</p><ul><li>isFair() //判断锁是否是公平锁</li><li>isLocked() //判断锁是否被任何线程获取了</li><li>isHeldByCurrentThread() //判断锁是否被当前线程获取了</li><li>hasQueuedThreads() //判断是否有线程在等待该锁</li></ul><p>在ReentrantReadWriteLock中也有类似的方法，同样也可以设置为公平锁和非公平锁。不过要记住，ReentrantReadWriteLock并未实现Lock接口，它实现的是ReadWriteLock接口。</p><h2><a id="_94"></a><a class="header-anchor" href="#分段锁">¶</a>分段锁</h2><p>分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。<br>我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7和JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock）。<br>当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在哪一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。<br>但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。<br>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</p><h2><a id="_101"></a><a class="header-anchor" href="#自旋锁">¶</a>自旋锁</h2><p>在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。比如 while(true){}</p><h2><a id="_104"></a><a class="header-anchor" href="#偏向锁-轻量级锁-重量级锁">¶</a>偏向锁、轻量级锁、重量级锁</h2><p>这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。<br>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。<br>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。<br>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入阻塞，性能降低。</p><h1><a id="_111"></a>储备知识</h1><h2><a id="AQS_112"></a><a class="header-anchor" href="#aqs">¶</a>AQS</h2><p>AbstractQueuedSynchronized 抽象队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch…<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/UTOOLS1571752834325.png" alt><br>AQS维护了一个volatile int state(代表共享资源)和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。</p><p>state的访问方式有三种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getState()</span><br><span class="line">setState()</span><br><span class="line">compareAndSetState()</span><br></pre></td></tr></table></figure><p>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively():该线程是否正在独占资源。只有用到condition才需要去实现它。</span><br><span class="line">tryAquire(int):独占方式。尝试获取资源，成功则返回true，失败则返回false。</span><br><span class="line">tryRelease(int):独占方式。尝试释放资源，成功则返回true，失败则返回false。</span><br><span class="line">tryAcquireShared(int):共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><br><span class="line">tryReleaseShared(int):共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</span><br></pre></td></tr></table></figure><p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其他线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多少次，这样才能保证state是能回到零态的。</p><p>再以CountDownLatch为例，任务分为N个子线程去执行，state为初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后（即state=0），会unpark()主调用线程，然后主调用线程就会await()函数返回，继续后余动作。</p><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p><h2><a id="CAS_128"></a><a class="header-anchor" href="#cas">¶</a>CAS</h2><p>CAS（Compare and Swap 比较并交换）是乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其他线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。<br>CAS操作中包含三个操作数——需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值（B）。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B，否则处理器不做任何操作。无论哪种情况，它都会在CAS指令之前返回该位置的值（在CAS的一些特殊情况下将仅返回CAS是否成功，而不提取当前值）。CAS有效地说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可”。这其实和乐观锁的冲突检查+数据更新的原理是一样的。</p><p>JAVA对CAS的支持：<br>在JDK1.5中新增java.util.concurrent包就是建立在CAS之上的。相对于synchronized这种阻塞算法，CAS是非阻塞算法的一种常见实现。所以java.util.concurrent包中的AtomicInteger为例，看一下在不使用锁的情况下是如何保证线程安全的。主要理解getAndIncrement方法，该方法的作用相当于++i操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicInteger extends Number implements java.io.Serializable&#123;</span><br><span class="line">　　private volatile int value;</span><br><span class="line">　　public final int get()&#123;</span><br><span class="line">　　　　return value;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　 public final int getAndIncrement()&#123;</span><br><span class="line">　　　　for (;;)&#123;</span><br><span class="line">　　　　　　int current = get();</span><br><span class="line">　　　　　　int next = current + 1;</span><br><span class="line">　　　　　　if (compareAndSet(current, next))</span><br><span class="line">　　　　　　return current;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line"> </span><br><span class="line">　　public final boolean compareAndSet(int expect, int update)&#123;</span><br><span class="line">　　　　return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jeff-eric.github.com/blog/blog/2019/10/22/CompletableFuture/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jeff-Eric"><meta itemprop="description" content=""><meta itemprop="image" content="/blog/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="纯天然绿色学渣"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/blog/2019/10/22/CompletableFuture/" class="post-title-link" itemprop="url">CompletableFuture</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-22 10:25:00" itemprop="dateCreated datePublished" datetime="2019-10-22T10:25:00+08:00">2019-10-22</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-10-23 10:10:09" itemprop="dateModified" datetime="2019-10-23T10:10:09+08:00">2019-10-23</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/blog/2019/10/22/CompletableFuture/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/2019/10/22/CompletableFuture/" itemprop="commentCount"></span> </a></span><span id="/blog/2019/10/22/CompletableFuture/" class="leancloud_visitors" data-flag-title="CompletableFuture"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body han-init-context" itemprop="articleBody"><h1><a id="_1"></a>简介</h1><h3><a id="_2"></a><a class="header-anchor" href="#异步计算">¶</a>异步计算</h3><p>所谓异步调用其实就是实现一个可无需等待被调用函数的返回值而让操作继续运行的方法。在 Java 语言中，简单的讲就是另启一个线程来完成调用中的部分计算，使调用继续运行或返回，而不需要等待计算结果。但调用者仍需要取线程的计算结果。</p><p>JDK5新增了Future接口，用于描述一个异步计算的结果。虽然 Future 以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无谓的 CPU 资源，而且也不能及时地得到计算结果。</p><p>以前我们获取一个异步任务的结果可能是这样写的：<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/UTOOLS1571752538400.png" alt></p><h3><a id="Future__10"></a><a class="header-anchor" href="#future-接口的局限性">¶</a>Future 接口的局限性</h3><p>Future接口可以构建异步应用，但依然有其局限性。它很难直接表述多个Future 结果之间的依赖性。实际开发中，我们经常需要达成以下目的：</p><ul><li>将多个异步计算的结果合并成一个</li><li>等待Future集合中的所有任务都完成</li><li>Future完成事件（即，任务完成以后触发执行动作）</li></ul><h3><a id="CompletionStage_16"></a><a class="header-anchor" href="#completionstage">¶</a>CompletionStage</h3><ul><li>CompletionStage代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段</li><li>一个阶段的计算执行可以是一个Function，Consumer或者Runnable。比如：stage.thenApply(x -&gt; square(x)).thenAccept(x -&gt; System.out.print(x)).thenRun(() -&gt; System.out.println())</li><li>一个阶段的执行可能是被单个阶段的完成触发，也可能是由多个阶段一起触发</li></ul><h3><a id="CompletableFuture_21"></a><a class="header-anchor" href="#completablefuture">¶</a>CompletableFuture</h3><ul><li>在Java8中，CompletableFuture提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，并且提供了函数式编程的能力，可以通过回调的方式处理计算结果，也提供了转换和组合 CompletableFuture 的方法</li><li>它可能代表一个明确完成的Future，也有可能代表一个完成阶段（ CompletionStage ），它支持在计算完成以后触发一些函数或执行某些动作。</li><li>它实现了Future和CompletionStage接口<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/UTOOLS1571752571017.png" alt></li></ul><h3><a id="_27"></a><a class="header-anchor" href="#实例代码">¶</a>实例代码</h3><h4><a id="CompletableFuter_28"></a><a class="header-anchor" href="#基本的completablefuter使用">¶</a>基本的CompletableFuter使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.CompletableFuture;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">public class BaseComFuture &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		long start = System.nanoTime();</span><br><span class="line">//</span><br><span class="line">//		System.out.println(&quot;get start&quot;);</span><br><span class="line">//		TimeUnit.SECONDS.sleep(3);</span><br><span class="line">//		TimeUnit.SECONDS.sleep(3);</span><br><span class="line">//		TimeUnit.SECONDS.sleep(3);</span><br><span class="line">//		System.out.println(456);</span><br><span class="line">//</span><br><span class="line">//		System.out.println(System.nanoTime()-start);</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * 新建一个CompletableFuture对象</span><br><span class="line">		 */</span><br><span class="line">		start = System.nanoTime();</span><br><span class="line">		CompletableFuture&lt;String&gt; resultCompletableFuture = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				System.out.println(&quot;get start1&quot;);</span><br><span class="line">				TimeUnit.SECONDS.sleep(3);</span><br><span class="line">				System.out.println(Thread.currentThread().getName());</span><br><span class="line">			&#125; catch (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			return &quot;Hello CompletableFuture&quot;;</span><br><span class="line">		&#125;);</span><br><span class="line">//		CompletableFuture&lt;String&gt; resultCompletableFuture1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">//			try &#123;</span><br><span class="line">//				System.out.println(&quot;get start2&quot;);</span><br><span class="line">//				TimeUnit.SECONDS.sleep(3);</span><br><span class="line">//				System.out.println(Thread.currentThread().getName());</span><br><span class="line">//			&#125; catch (Exception e) &#123;</span><br><span class="line">//				e.printStackTrace();</span><br><span class="line">//			&#125;</span><br><span class="line">//</span><br><span class="line">//			return &quot;Hello CompletableFuture&quot;;</span><br><span class="line">//		&#125;);</span><br><span class="line">//		CompletableFuture&lt;String&gt; resultCompletableFuture2 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">//			try &#123;</span><br><span class="line">//				System.out.println(&quot;get start3&quot;);</span><br><span class="line">//				TimeUnit.SECONDS.sleep(5);</span><br><span class="line">//				System.out.println(Thread.currentThread().getName());</span><br><span class="line">//			&#125; catch (Exception e) &#123;</span><br><span class="line">//				e.printStackTrace();</span><br><span class="line">//			&#125;</span><br><span class="line">//</span><br><span class="line">//			return &quot;Hello CompletableFuture&quot;;</span><br><span class="line">//		&#125;);</span><br><span class="line">		TimeUnit.SECONDS.sleep(1);</span><br><span class="line">		System.out.println(123);</span><br><span class="line">		System.out.println(resultCompletableFuture.get());</span><br><span class="line">		System.out.println(&quot;aaaaaaa&quot;);</span><br><span class="line">//		System.out.println(resultCompletableFuture1.get());</span><br><span class="line">		System.out.println(&quot;aaaaaaa&quot;);</span><br><span class="line">//		System.out.println(resultCompletableFuture2.get());</span><br><span class="line">		System.out.println(&quot;aaaaaaa&quot;);</span><br><span class="line">		System.out.println(456);</span><br><span class="line">		System.out.println(System.nanoTime()-start);</span><br><span class="line">		/***</span><br><span class="line">		 * ps : 首先会进入该进程，执行get方法 //所以输出结果中立马会输出get start 然后，sleep模拟长时间计算操作/或者其他情况的阻塞</span><br><span class="line">		 * //所以这个时候屏幕会等三秒，一直停在那里 3秒后才会打印 // 三秒后，才会开始打印相关信息，按照顺序执行</span><br><span class="line">		 * (不要被try语句迷惑了啊，那就是一个一瞬执行下来的逻辑) 打印完后该进程退出！</span><br><span class="line">		 *</span><br><span class="line">		 * 如果我用resultCompletableFuture的回调函数去处理这个会有什么现象呢？ 请看BaseComFutureCallback类中的演示</span><br><span class="line">		 */</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 上面那个打印语句会阻塞3秒，执行完后 ，才会执行这一句</span><br><span class="line">		 */</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><a id="_30"></a><a class="header-anchor" href="#回调">¶</a>回调</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.CompletableFuture;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">public class BaseComFutureCallback &#123;</span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		ExecutorService executor = Executors.newFixedThreadPool(5);</span><br><span class="line">		/*</span><br><span class="line">		 * 新建一个CompletableFuture对象</span><br><span class="line">		 */</span><br><span class="line">		CompletableFuture&lt;String&gt; resultCompletableFuture = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				System.out.println(&quot;get start,will sleep 3s&quot;);</span><br><span class="line">				TimeUnit.SECONDS.sleep(3);</span><br><span class="line">				System.out.println(Thread.currentThread().getName());</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			return &quot;Hello CompletableFuture&quot;;</span><br><span class="line">		&#125;, executor);</span><br><span class="line"></span><br><span class="line">		CompletableFuture&lt;String&gt; resultCompletableFuture2 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				System.out.println(&quot;get start,will sleep 3s&quot;);</span><br><span class="line">				TimeUnit.SECONDS.sleep(3);</span><br><span class="line">				System.out.println(Thread.currentThread().getName());</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			return &quot;Hello CompletableFuture&quot;;</span><br><span class="line">		&#125;, executor);</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * ps: 回调函数，顾名思义 那就是调用的对象中声明的方法正确执行完后，就会调用这个方法。</span><br><span class="line">		 * 其中，accept中的参数就是get函数返回的参数</span><br><span class="line">		 */</span><br><span class="line">		System.out.println(resultCompletableFuture.thenAccept((t)-&gt;&#123;</span><br><span class="line">			System.out.println(&quot;进入回调函数-&quot; + t);</span><br><span class="line">			System.out.println(Thread.currentThread().getName());</span><br><span class="line">		&#125;));</span><br><span class="line">		System.out.println(resultCompletableFuture2.thenAccept((t)-&gt;&#123;</span><br><span class="line">			System.out.println(&quot;进入回调函数-&quot; + t);</span><br><span class="line">			System.out.println(Thread.currentThread().getName());</span><br><span class="line">		&#125;));</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;带有回调的print语句后面一句话&quot;);</span><br><span class="line">		System.out.println(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * it will shutdown 10&apos;s later</span><br><span class="line">		 */</span><br><span class="line">		System.out.println(&quot;it will shutdown 10&apos;s later&quot;);</span><br><span class="line">		TimeUnit.SECONDS.sleep(10);</span><br><span class="line"></span><br><span class="line">		executor.shutdown();</span><br><span class="line">		System.out.println(&quot;shutdown&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * ps: 两点</span><br><span class="line"> * 1.这个时候你会看到 ,在带有回调的print语句后的一个print会先打印（因为那个回调在等着get函数里面sleep3秒钟）,</span><br><span class="line"> * 但是，不会阻塞着等，而是会执行下面的语句，然后，上面的语句执行完后，再来执行这个带有回调的print</span><br><span class="line"> * 2.当打印线程的时候，我们可以看到，回调与get是统一个线程！</span><br><span class="line"> *   因为我们用的thenAccept去做回调，</span><br><span class="line"> *   那么，当我们尝试用带Async的回调方法去回调试试看</span><br><span class="line"> *   详见BaseComFutureCallbackAsync</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * 补充：</span><br><span class="line"> *  这里与上一个不同，因为这个地方加了个executor，为什么？</span><br><span class="line"> * 	 由于回调，resultCompletableFuture中的get不知道会阻塞到什么时候</span><br><span class="line"> * 	 （虽然现在写死的是3秒，但是生产环境中 ，哪个能保证3秒？）</span><br><span class="line"> *  但是，这个地方他又不会像上一个程序那样一顺执行，非得等阻塞完成再执行下一句</span><br><span class="line"> *  而是马上执行下面的print，当main中所有语句顺序执行完了之后，这个main线程就关闭了，</span><br><span class="line"> *  所以，你的回调永远不会执行，因为主线程都down掉了。你咋回来。（可惜啊，main不会等，等了不还是阻塞）</span><br><span class="line"> *</span><br><span class="line"> *  所以，这里我先起一个executor，用来开一个线程池，如果不显式关闭，</span><br><span class="line"> *  他就会一直挂在那，既然一直挂在那里，我显然，会等到我回调的那天（get必然会返回值，只是时间长短啊）</span><br><span class="line"> *</span><br><span class="line"> *  所以，哪怕你main语句执行完了，但是我只要不关闭这个线程池，你的main就一直跟我挂在那，因为还有一句话没有执行完嘛.</span><br><span class="line"> *</span><br><span class="line"> *  BaseComFutureCallback2中对这个的演示会更明显</span><br><span class="line"> *</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h4><a id="_32"></a><a class="header-anchor" href="#异常通知的情况">¶</a>异常通知的情况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.CompletableFuture;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.function.Consumer;</span><br><span class="line">import java.util.function.Function;</span><br><span class="line">import java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line">public class BaseComFutureExceptionally2 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		ExecutorService executor = Executors.newFixedThreadPool(5);</span><br><span class="line">		/*</span><br><span class="line">		 * 新建一个CompletableFuture对象</span><br><span class="line">		 */</span><br><span class="line">		CompletableFuture&lt;String&gt; resultCompletableFuture = CompletableFuture.supplyAsync(new Supplier&lt;String&gt;() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public String get() &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					System.out.println(&quot;get start,will sleep 3s&quot;);</span><br><span class="line">					TimeUnit.SECONDS.sleep(3);</span><br><span class="line">					throw new RuntimeException(&quot;错误&quot;);</span><br><span class="line">					//			System.out.println(Thread.currentThread().getName());</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				return &quot;Hello CompletableFuture&quot;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, executor);</span><br><span class="line"></span><br><span class="line">		System.out.println(resultCompletableFuture.thenAccept(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void accept(String t) &#123;</span><br><span class="line">				System.out.println(&quot;进入回调函数-&quot; + t);</span><br><span class="line">				throw new RuntimeException(&quot;aaaaa&quot;);</span><br><span class="line">//				System.out.println(Thread.currentThread().getName());</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;).exceptionally(new Function&lt;Throwable, Void&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			/**</span><br><span class="line">			 * ps</span><br><span class="line">			 * 当出现异常的的时候，会执行这个function</span><br><span class="line">			 * 这里就是对异常进行一些处理</span><br><span class="line">			 */</span><br><span class="line">			@Override</span><br><span class="line">			public Void apply(Throwable t) &#123;</span><br><span class="line">				System.out.println(t.getMessage());</span><br><span class="line">				return null;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;));</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * ps: 我们返现，其余的流程都是一样的，就是回调函数不再执行了！</span><br><span class="line">		 * 任务还是会执行完成（只要主线程等待足够时间再结束，或者不结束 ）</span><br><span class="line">		 * 但是，我们的回调函数，一般应用中肯定是希望执行的（既然是回调，我肯定希望在目标方法执行完后，进行一些处理工作），哪</span><br><span class="line">		 * 怕是你报错，我也要指导你报错了，你完全不执行，显然是不合理的</span><br><span class="line">		 *</span><br><span class="line">		 * 但是我们实际应用中坑定不是通过</span><br><span class="line">		 * resultCompletableFuture.completeExceptionally(new Exception(&quot;error&quot;));</span><br><span class="line">		 * 这个方法来抛出异常，肯定是在get中执行的时候出现异常然后抛出</span><br><span class="line">		 * 这种情况详见BaseComFutureExceptionally2</span><br><span class="line">		 */</span><br><span class="line">		resultCompletableFuture.completeExceptionally(new RuntimeException(&quot;error&quot;));</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;it will shutdown 10&apos;s later&quot;);</span><br><span class="line">		TimeUnit.SECONDS.sleep(10);</span><br><span class="line"></span><br><span class="line">		executor.shutdown();</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;time out ,main shutdown now&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 我们往往不仅需要通过回调的方式，让线程不阻塞</span><br><span class="line"> * 我们还需要将这些回调操作串起来</span><br><span class="line"> * 接着请看下面的转换</span><br><span class="line"> * 需要用到apply函数组</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * public &lt;U&gt; CompletableFuture&lt;U&gt; 	thenApply(Function&lt;? super T,? extends U&gt; fn)</span><br><span class="line"> * public &lt;U&gt; CompletableFuture&lt;U&gt; 	thenApplyAsync(Function&lt;? super T,? extends U&gt; fn)</span><br><span class="line"> * public &lt;U&gt; CompletableFuture&lt;U&gt; 	thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor)</span><br><span class="line"> * 当原来的CompletableFuture计算完后，</span><br><span class="line"> * 将结果传递给函数fn，</span><br><span class="line"> * 将fn的结果作为新的CompletableFuture的参数去参与运算。</span><br><span class="line"> * 因此它的功能相当于将CompletableFuture&lt;T&gt;转换成CompletableFuture&lt;U&gt;</span><br><span class="line"> *</span><br><span class="line"> * 持续这么循环的调下去，有点像递归，当然，递归是本函数的持续调用（直到递归条件不满足）</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h4><a id="__34"></a><a class="header-anchor" href="#我们不仅仅回调-还可以将这些回调-操作串起来">¶</a>我们不仅仅回调，还可以将这些回调 操作串起来</h4><p>需要用到apply函数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.*;</span><br><span class="line">import java.util.function.Function;</span><br><span class="line"></span><br><span class="line">public class ConvertComFuture &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">		ExecutorService executor = Executors.newFixedThreadPool(5);</span><br><span class="line">		CompletableFuture&lt;String&gt; f1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">//			throw new RuntimeException(&quot;错误&quot;);</span><br><span class="line">			System.out.println(&quot;aaaaa&quot;);</span><br><span class="line">			try &#123;</span><br><span class="line">				TimeUnit.SECONDS.sleep(2);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			return &quot;zero&quot;;</span><br><span class="line">		&#125;, executor);</span><br><span class="line"></span><br><span class="line">		CompletableFuture&lt;Integer&gt; f2 = f1.thenApply(new Function&lt;String, Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			@Override</span><br><span class="line">			public Integer apply(String t) &#123;</span><br><span class="line">				System.out.println(&quot;进入f2的apply方法&quot;);</span><br><span class="line">				System.out.println(&quot;f1传进来的字符串-&quot;+t);</span><br><span class="line">				System.out.println(&quot;返回该字符串的长度-&quot;+Integer.valueOf(t.length()));</span><br><span class="line"></span><br><span class="line">				try &#123;</span><br><span class="line">					TimeUnit.SECONDS.sleep(3);</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				return Integer.valueOf(t.length());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).exceptionally(new Function&lt;Throwable, Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			@Override</span><br><span class="line">			public Integer apply(Throwable t) &#123;</span><br><span class="line">				System.out.println(t.getMessage());</span><br><span class="line">				return null;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;);</span><br><span class="line">		System.out.println(&quot;bbbbb&quot;);</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 此处，apply的是f1</span><br><span class="line">		 */</span><br><span class="line"></span><br><span class="line">		CompletableFuture&lt;Double&gt; f3 = f2.thenApply(self -&gt; self * 2.0).thenApply(self -&gt; self*3).exceptionally(new Function&lt;Throwable, Double&gt;() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public Double apply(Throwable t) &#123;</span><br><span class="line">				System.out.println(t.getMessage());</span><br><span class="line">				return null;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);//这个参数名字随便取，叫self最合适,因为他本来就是把f2自身的结果带到f3中去,参与f3的运算</span><br><span class="line">		/**</span><br><span class="line">		 * 此处，apply的是f2</span><br><span class="line">		 *</span><br><span class="line">		 * 这个地方的self，不严格的说，就是一个的代名词,就是代表了f2的返回值</span><br><span class="line">		 *</span><br><span class="line">		 * 如果想要看的清楚一点，可以像f1一样显式声明一个function匿名对象，覆盖apply方法，然后写逻辑</span><br><span class="line">		 * 其中，方括号前面的参数是传进来的参数类型，后面的参数类型是返回类型</span><br><span class="line">		 *</span><br><span class="line">		 * 不过,我们一般采用f2的方式，更简洁一点</span><br><span class="line">		 *</span><br><span class="line">		 * 这里需要注意的是，f3获得最终结果还真不会马上执行，也不会导致主进程阻塞</span><br><span class="line">		 * 而是等着这里面所有的“回调”阶段一个接一个的完成后，再显示出来(或者说再进入f3的执行执行逻辑)。</span><br><span class="line">		 *</span><br><span class="line">		 * 但是，这个方法一旦有异常，就会抛出</span><br><span class="line">		 */</span><br><span class="line">		//System.out.println(f3.get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;shutdown in 3s&quot;);</span><br><span class="line">		TimeUnit.SECONDS.sleep(3);</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;shutdown&quot;);</span><br><span class="line">		executor.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jeff-eric.github.com/blog/blog/2019/09/10/NIO%E3%80%81BIO%E3%80%81AIO/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jeff-Eric"><meta itemprop="description" content=""><meta itemprop="image" content="/blog/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="纯天然绿色学渣"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/blog/2019/09/10/NIO%E3%80%81BIO%E3%80%81AIO/" class="post-title-link" itemprop="url">NIO、BIO、AIO网络通信</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-09-10 09:42:46" itemprop="dateCreated datePublished" datetime="2019-09-10T09:42:46+08:00">2019-09-10</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-10-23 10:12:46" itemprop="dateModified" datetime="2019-10-23T10:12:46+08:00">2019-10-23</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/blog/2019/09/10/NIO%E3%80%81BIO%E3%80%81AIO/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/2019/09/10/NIO%E3%80%81BIO%E3%80%81AIO/" itemprop="commentCount"></span> </a></span><span id="/blog/2019/09/10/NIO%E3%80%81BIO%E3%80%81AIO/" class="leancloud_visitors" data-flag-title="NIO、BIO、AIO网络通信"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body han-init-context" itemprop="articleBody"><h1><a id="_1"></a>一、概念</h1><h3><a id="1_2"></a><a class="header-anchor" href="#1-同步和异步">¶</a>1、同步和异步</h3><h4><a id="_3"></a><a class="header-anchor" href="#同步：">¶</a>同步：</h4><p>用户线程发起I/O请求后需要等待或者轮询内核I/O操作完成后才能继续执行</p><h4><a id="_5"></a><a class="header-anchor" href="#异步：">¶</a>异步：</h4><p>用户线程发起I/O请求后仍需要继续执行，当内核I/O操作完成后会通知用户线程，或者调用用户线程注册的回调函数</p><h3><a id="2_8"></a><a class="header-anchor" href="#2-阻塞和非阻塞">¶</a>2、阻塞和非阻塞</h3><p>讨论的是参与通信双方的工作机制,是否需要互相等待对方的执行</p><h4><a id="_10"></a><a class="header-anchor" href="#阻塞：">¶</a>阻塞：</h4><p>在通信过程中，<br>一方在处理通信，<br>另一方要等待对方执行并返回信息不能去做其他无关的事</p><h4><a id="_14"></a><a class="header-anchor" href="#非阻塞：">¶</a>非阻塞：</h4><p>在通信过程中，<br>一方在处理通信，<br>另一方可以不用等待执行并返回信息而可以去做其他无关的事 直到对方处理通信完成 再在适合的时候继续处理通信过程</p><h1><a id="BIO__19"></a>二、BIO (同步阻塞)</h1><h4><a id="_20"></a><a class="header-anchor" href="#代码示例">¶</a>代码示例</h4><p>服务端业务代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">import javax.script.ScriptEngine;</span><br><span class="line">import javax.script.ScriptEngineManager;</span><br><span class="line">import javax.script.ScriptException;</span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 客户端消息处理线程ServerHandler</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2017/6/24</span><br><span class="line"> */</span><br><span class="line">public class ServerHandler implements Runnable&#123;</span><br><span class="line">    private Socket socket;</span><br><span class="line">    public ServerHandler(Socket socket) &#123;</span><br><span class="line">        this.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        BufferedReader in = null;</span><br><span class="line">        PrintWriter out = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">            out = new PrintWriter(socket.getOutputStream(),true);</span><br><span class="line">            String expression;</span><br><span class="line">            String result;</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                //通过BufferedReader读取一行</span><br><span class="line">                //如果已经读到输入流尾部，返回null,退出循环</span><br><span class="line">                //如果得到非空值，就尝试计算结果并返回</span><br><span class="line">                if((expression = in.readLine())==null) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;server阻塞测试&quot;);</span><br><span class="line">                System.out.println(&quot;服务器收到消息：&quot; + expression);</span><br><span class="line">                try&#123;</span><br><span class="line">                    result = Calculator.cal(expression).toString();</span><br><span class="line">                &#125;catch(Exception e)&#123;</span><br><span class="line">                    result = &quot;计算错误：&quot; + e.getMessage();</span><br><span class="line">                &#125;</span><br><span class="line">                out.println(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            //一些必要的清理工作</span><br><span class="line">            if(in != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                in = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(out != null)&#123;</span><br><span class="line">                out.close();</span><br><span class="line">                out = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(socket != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                socket = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final class Calculator &#123;</span><br><span class="line">    private final static ScriptEngine jse = new ScriptEngineManager().getEngineByName(&quot;JavaScript&quot;);</span><br><span class="line">    public static Object cal(String expression) throws ScriptException &#123;</span><br><span class="line">        return jse.eval(expression);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">public class ServerNormal &#123;</span><br><span class="line"></span><br><span class="line">    //默认的端口号</span><br><span class="line">    private static int DEFAULT_PORT = 12344;</span><br><span class="line">    //单例的ServerSocket</span><br><span class="line">    private static ServerSocket server;</span><br><span class="line"></span><br><span class="line">    //线程池 懒汉式的单例</span><br><span class="line">    private static ExecutorService executorService = Executors.newFixedThreadPool(1);</span><br><span class="line"></span><br><span class="line">    //根据传入参数设置监听端口，如果没有参数调用以下方法并使用默认值</span><br><span class="line">    public static void start() throws IOException &#123;</span><br><span class="line">        //使用默认值</span><br><span class="line">        start(DEFAULT_PORT);</span><br><span class="line">    &#125;</span><br><span class="line">    //这个方法不会被大量并发访问，不太需要考虑效率，直接进行方法同步就行了</span><br><span class="line">    public synchronized static void start(int port) throws IOException&#123;</span><br><span class="line">        if(server != null) return;</span><br><span class="line">        try&#123;</span><br><span class="line">            //通过构造函数创建ServerSocket</span><br><span class="line">            //如果端口合法且空闲，服务端就监听成功</span><br><span class="line">            server = new ServerSocket(port);</span><br><span class="line">            System.out.println(&quot;服务器已启动，端口号：&quot; + port);</span><br><span class="line">            //通过无线循环监听客户端连接</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                //如果没有客户端接入，将阻塞在accept操作上。</span><br><span class="line">                Socket socket = server.accept();</span><br><span class="line">                //当有新的客户端接入时，会执行下面的代码</span><br><span class="line">                //然后创建一个新的线程处理这条Socket链路</span><br><span class="line">                // TODO: 2019/8/28  问题所在</span><br><span class="line">//                new Thread(new ServerHandler(socket)).start();</span><br><span class="line">                executorService.execute(new ServerHandler(socket));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            //一些必要的清理工作</span><br><span class="line">            if(server != null)&#123;</span><br><span class="line">                System.out.println(&quot;服务器已关闭。&quot;);</span><br><span class="line">                server.close();</span><br><span class="line">                server = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 同步阻塞式I/O创建的Client源码</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2017/6/24</span><br><span class="line"> */</span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    //默认的端口号</span><br><span class="line">    private static int DEFAULT_SERVER_PORT = 12344;</span><br><span class="line">    private static String DEFAULT_SERVER_IP = &quot;127.0.0.1&quot;;</span><br><span class="line">    public static void send(String expression)&#123;</span><br><span class="line">        send(DEFAULT_SERVER_PORT,expression);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void send(int port,String expression)&#123;</span><br><span class="line">        System.out.println(&quot;算术表达式为：&quot; + expression);</span><br><span class="line">        Socket socket = null;</span><br><span class="line">        BufferedReader in = null;</span><br><span class="line">        PrintWriter out = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            socket = new Socket(DEFAULT_SERVER_IP,port);</span><br><span class="line">            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">            out = new PrintWriter(socket.getOutputStream(),true);</span><br><span class="line">            out.println(expression);</span><br><span class="line">            System.out.println(&quot;___结果为：&quot; + in.readLine());</span><br><span class="line">            System.out.println(&quot;client阻塞测试&quot;);</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            //一下必要的清理工作</span><br><span class="line">            if(in != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                in = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(out != null)&#123;</span><br><span class="line">                out.close();</span><br><span class="line">                out = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(socket != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                socket = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.Random;</span><br><span class="line">/**</span><br><span class="line"> * Test class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2017/6/24</span><br><span class="line"> */</span><br><span class="line">public class BIOTest &#123;</span><br><span class="line"></span><br><span class="line">    //测试主方法</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        //运行服务器</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ServerNormal.start();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        //避免客户端先于服务器启动前执行代码</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">        //运行客户端</span><br><span class="line">        char operators[] = &#123;&apos;+&apos;,&apos;-&apos;,&apos;*&apos;,&apos;/&apos;&#125;;</span><br><span class="line">        Random random = new Random(System.currentTimeMillis());</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                //随机产生算术表达式</span><br><span class="line">                String expression = random.nextInt(10)+&quot;&quot;+operators[random.nextInt(4)]+(random.nextInt(10)+1);</span><br><span class="line">                Client.send(expression);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(random.nextInt(1000));</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><a id="_31"></a><a class="header-anchor" href="#问题">¶</a>问题</h3><p>同步阻塞式I/O创建的Server</p><h4><a id="_33"></a><a class="header-anchor" href="#结构图">¶</a>结构图</h4><p><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/UTOOLS1571752639463.png" alt></p><h4><a id="1BIO_35"></a><a class="header-anchor" href="#1-bio主要的问题在于每当有一个新的客户端请求接入时-服务端必须创建一个新的线程来处理这条链路-在需要满足高性能-高并发的场景是没法应用的-大量创建新的线程会严重影响服务器性能-甚至罢工">¶</a>1、BIO主要的问题在于每当有一个新的客户端请求接入时，服务端必须创建一个新的线程来处理这条链路，在需要满足高性能、高并发的场景是没法应用的（大量创建新的线程会严重影响服务器性能，甚至罢工）</h4><h4><a id="1Socket_36"></a><a class="header-anchor" href="#1-限制了线程数量-如果发生大量并发请求-超过最大数量的线程就只能等待-直到线程池中的有空闲的线程可以被复用-而对socket的输入流进行读取时-会一直阻塞">¶</a>1、限制了线程数量，如果发生大量并发请求，超过最大数量的线程就只能等待，直到线程池中的有空闲的线程可以被复用。而对Socket的输入流进行读取时，会一直阻塞</h4><p>所以在读取数据较慢时（比如数据量大、网络传输慢等），大量并发的情况下，其他接入的消息，只能一直等待，这就是最大的弊端。而NIO，就能解决这个难题</p><h1><a id="NIO_39"></a>三、NIO</h1><h4><a id="_40"></a><a class="header-anchor" href="#代码示例-v2">¶</a>代码示例</h4><p>服务端代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line">import javax.script.ScriptEngine;</span><br><span class="line">import javax.script.ScriptEngineManager;</span><br><span class="line">import javax.script.ScriptException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.SelectionKey;</span><br><span class="line">import java.nio.channels.Selector;</span><br><span class="line">import java.nio.channels.ServerSocketChannel;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class Server &#123;</span><br><span class="line">    private static int DEFAULT_PORT = 12345;</span><br><span class="line">    private static ServerHandle serverHandle;</span><br><span class="line">    public static void start()&#123;</span><br><span class="line">        start(DEFAULT_PORT);</span><br><span class="line">    &#125;</span><br><span class="line">    public static synchronized void start(int port)&#123;</span><br><span class="line">        if(serverHandle!=null) &#123;</span><br><span class="line">            serverHandle.stop();</span><br><span class="line">        &#125;</span><br><span class="line">        serverHandle = new ServerHandle(port);</span><br><span class="line">        new Thread(serverHandle,&quot;Server&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ServerHandle implements Runnable&#123;</span><br><span class="line">    private Selector selector;</span><br><span class="line">    private ServerSocketChannel serverChannel;</span><br><span class="line">    private volatile boolean started;</span><br><span class="line">    /**</span><br><span class="line">     * 构造方法</span><br><span class="line">     * @param port 指定要监听的端口号</span><br><span class="line">     */</span><br><span class="line">    public ServerHandle(int port) &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            //创建选择器</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            //打开监听通道</span><br><span class="line">            serverChannel = ServerSocketChannel.open();</span><br><span class="line">            //如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式</span><br><span class="line">            serverChannel.configureBlocking(false);//开启非阻塞模式</span><br><span class="line">            //绑定端口 backlog设为1024</span><br><span class="line">            serverChannel.socket().bind(new InetSocketAddress(port),1024);</span><br><span class="line">            //监听客户端连接请求</span><br><span class="line">            // 如果你对不止一种事件感兴趣，使用或运算符即可，如下：</span><br><span class="line">            // int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br><span class="line">            serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            //标记服务器已开启</span><br><span class="line">            started = true;</span><br><span class="line">            System.out.println(&quot;服务器已启动，端口号：&quot; + port);</span><br><span class="line">        &#125;catch(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void stop()&#123;</span><br><span class="line">        started = false;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        //循环遍历selector</span><br><span class="line">        while(started)&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                // 阻塞,阻塞到至少有一个通道在你注册的事件上就绪了。</span><br><span class="line">                // 这个过程可能会造成调用线程进入阻塞状态, 通过调用Selector对象的wakeup（）方法让处在阻塞状态的select()方法立刻返回</span><br><span class="line">                // wakeup（）该方法使得选择器上的第一个还没有返回的选择操作立即返回。如果当前没有进行中的选择操作，那么下一次对select()方法的一次调用将立即返回。</span><br><span class="line">//				selector.select();</span><br><span class="line">                // 和select()一样，但最长阻塞时间为timeout毫秒。</span><br><span class="line">//                selector.select(1000);</span><br><span class="line">                // 非阻塞，只要有通道就绪就立刻返回。</span><br><span class="line">                selector.selectNow();</span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; it = keys.iterator();</span><br><span class="line">                SelectionKey key = null;</span><br><span class="line">                while(it.hasNext())&#123;</span><br><span class="line">                    key = it.next();</span><br><span class="line">                    it.remove();</span><br><span class="line">                    try&#123;</span><br><span class="line">                        handleInput(key);</span><br><span class="line">                    &#125;catch(Exception e)&#123;</span><br><span class="line">                        if(key != null)&#123;</span><br><span class="line">                            key.cancel();</span><br><span class="line">                            if(key.channel() != null)&#123;</span><br><span class="line">                                key.channel().close();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;catch(Throwable t)&#123;</span><br><span class="line">                t.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //selector关闭后会自动释放里面管理的资源</span><br><span class="line">        if(selector != null) &#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                selector.close();</span><br><span class="line">            &#125;catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void handleInput(SelectionKey key) throws IOException&#123;</span><br><span class="line">        if(key.isValid())&#123;</span><br><span class="line">            //处理新接入的请求消息</span><br><span class="line">            if(key.isAcceptable())&#123;</span><br><span class="line">                ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</span><br><span class="line">                //通过ServerSocketChannel的accept创建SocketChannel实例</span><br><span class="line">                //完成该操作意味着完成TCP三次握手，TCP物理链路正式建立</span><br><span class="line">                SocketChannel sc = ssc.accept();</span><br><span class="line">                //设置为非阻塞的</span><br><span class="line">                // 神奇的事情，blocking默认是true</span><br><span class="line">                // TODO: 2019/8/28</span><br><span class="line">                sc.configureBlocking(false);</span><br><span class="line">                //注册为读</span><br><span class="line">                sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            &#125;</span><br><span class="line">            //读消息</span><br><span class="line">            if(key.isReadable())&#123;</span><br><span class="line">                SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                //创建ByteBuffer，并开辟一个1M的缓冲区</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">                //读取请求码流，返回读取到的字节数</span><br><span class="line">                int readBytes = sc.read(buffer);</span><br><span class="line">                //读取到字节，对字节进行编解码</span><br><span class="line">                if(readBytes&gt;0)&#123;</span><br><span class="line">                    //将缓冲区当前的limit设置为position=0，用于后续对缓冲区的读取操作</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    //根据缓冲区可读字节数创建字节数组</span><br><span class="line">                    byte[] bytes = new byte[buffer.remaining()];</span><br><span class="line">                    //将缓冲区可读字节数组复制到新建的数组中</span><br><span class="line">                    buffer.get(bytes);</span><br><span class="line">                    String expression = new String(bytes,&quot;UTF-8&quot;);</span><br><span class="line">                    System.out.println(&quot;服务器收到消息：&quot; + expression);</span><br><span class="line">                    //处理数据</span><br><span class="line">                    String result = null;</span><br><span class="line">                    try&#123;</span><br><span class="line">                        result = Calculator.cal(expression).toString();</span><br><span class="line">                    &#125;catch(Exception e)&#123;</span><br><span class="line">                        result = &quot;计算错误：&quot; + e.getMessage();</span><br><span class="line">                    &#125;</span><br><span class="line">                    //发送应答消息</span><br><span class="line">                    doWrite(sc,result);</span><br><span class="line">                &#125;</span><br><span class="line">                //没有读取到字节 忽略</span><br><span class="line">//				else if(readBytes==0);</span><br><span class="line">                //链路已经关闭，释放资源</span><br><span class="line">                else if(readBytes&lt;0)&#123;</span><br><span class="line">                    key.cancel();</span><br><span class="line">                    sc.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //异步发送应答消息</span><br><span class="line">    private void doWrite(SocketChannel channel,String response) throws IOException &#123;</span><br><span class="line">        //将消息编码为字节数组</span><br><span class="line">        byte[] bytes = response.getBytes();</span><br><span class="line">        //根据数组容量创建ByteBuffer</span><br><span class="line">        ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);</span><br><span class="line">        //将字节数组复制到缓冲区</span><br><span class="line">        writeBuffer.put(bytes);</span><br><span class="line">        //flip操作</span><br><span class="line">        writeBuffer.flip();</span><br><span class="line">        //发送缓冲区的字节数组</span><br><span class="line">        channel.write(writeBuffer);</span><br><span class="line">        //****此处不含处理“写半包”的代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final class Calculator &#123;</span><br><span class="line">    private final static ScriptEngine jse = new ScriptEngineManager().getEngineByName(&quot;JavaScript&quot;);</span><br><span class="line">    public static Object cal(String expression) throws ScriptException &#123;</span><br><span class="line">        return jse.eval(expression);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.SelectionKey;</span><br><span class="line">import java.nio.channels.Selector;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    private static String DEFAULT_HOST = &quot;127.0.0.1&quot;;</span><br><span class="line">    private static int DEFAULT_PORT = 12345;</span><br><span class="line">    private static ClientHandle clientHandle;</span><br><span class="line">    public static void start()&#123;</span><br><span class="line">        start(DEFAULT_HOST,DEFAULT_PORT);</span><br><span class="line">    &#125;</span><br><span class="line">    public static synchronized void start(String ip,int port)&#123;</span><br><span class="line">        if(clientHandle!=null)</span><br><span class="line">            clientHandle.stop();</span><br><span class="line">        clientHandle = new ClientHandle(ip,port);</span><br><span class="line">        new Thread(clientHandle,&quot;Server&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    //向服务器发送消息</span><br><span class="line">    public static boolean sendMsg(String msg) throws Exception&#123;</span><br><span class="line">        if(msg.equals(&quot;q&quot;)) return false;</span><br><span class="line">        clientHandle.sendMsg(msg);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ClientHandle implements Runnable&#123;</span><br><span class="line">    private String host;</span><br><span class="line">    private int port;</span><br><span class="line">    private Selector selector;</span><br><span class="line"></span><br><span class="line">    private SocketChannel socketChannel;</span><br><span class="line"></span><br><span class="line">    private volatile boolean started;</span><br><span class="line"></span><br><span class="line">    public ClientHandle(String ip,int port) &#123;</span><br><span class="line">        this.host = ip;</span><br><span class="line">        this.port = port;</span><br><span class="line">        try&#123;</span><br><span class="line">            //创建选择器</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            //打开监听通道</span><br><span class="line">            socketChannel = SocketChannel.open();</span><br><span class="line">            //如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式</span><br><span class="line">            socketChannel.configureBlocking(false);//开启非阻塞模式</span><br><span class="line">            started = true;</span><br><span class="line">        &#125;catch(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void stop()&#123;</span><br><span class="line">        started = false;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            doConnect();</span><br><span class="line">        &#125;catch(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        //循环遍历selector</span><br><span class="line">        while(started)&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                //无论是否有读写事件发生，selector每隔1s被唤醒一次</span><br><span class="line">                selector.select(1000);</span><br><span class="line">                //阻塞,只有当至少一个注册的事件发生的时候才会继续.</span><br><span class="line">//				selector.select();</span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; it = keys.iterator();</span><br><span class="line">                SelectionKey key = null;</span><br><span class="line">                while(it.hasNext())&#123;</span><br><span class="line">                    key = it.next();</span><br><span class="line">                    it.remove();</span><br><span class="line">                    try&#123;</span><br><span class="line">                        handleInput(key);</span><br><span class="line">                    &#125;catch(Exception e)&#123;</span><br><span class="line">                        if(key != null)&#123;</span><br><span class="line">                            key.cancel();</span><br><span class="line">                            if(key.channel() != null)&#123;</span><br><span class="line">                                key.channel().close();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;catch(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.exit(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //selector关闭后会自动释放里面管理的资源</span><br><span class="line">        if(selector != null)</span><br><span class="line">            try&#123;</span><br><span class="line">                selector.close();</span><br><span class="line">            &#125;catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void handleInput(SelectionKey key) throws IOException&#123;</span><br><span class="line">        if(key.isValid())&#123;</span><br><span class="line">            SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">            if(key.isConnectable())&#123;</span><br><span class="line">                if(sc.finishConnect());</span><br><span class="line">                else System.exit(1);</span><br><span class="line">            &#125;</span><br><span class="line">            //读消息</span><br><span class="line">            if(key.isReadable())&#123;</span><br><span class="line">                //创建ByteBuffer，并开辟一个1M的缓冲区</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">                //读取请求码流，返回读取到的字节数</span><br><span class="line">                int readBytes = sc.read(buffer);</span><br><span class="line">                //读取到字节，对字节进行编解码</span><br><span class="line">                if(readBytes&gt;0)&#123;</span><br><span class="line">                    //将缓冲区当前的limit设置为position=0，用于后续对缓冲区的读取操作</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    //根据缓冲区可读字节数创建字节数组</span><br><span class="line">                    byte[] bytes = new byte[buffer.remaining()];</span><br><span class="line">                    //将缓冲区可读字节数组复制到新建的数组中</span><br><span class="line">                    buffer.get(bytes);</span><br><span class="line">                    String result = new String(bytes,&quot;UTF-8&quot;);</span><br><span class="line">                    System.out.println(&quot;客户端收到消息：&quot; + result);</span><br><span class="line">                &#125;</span><br><span class="line">                //没有读取到字节 忽略</span><br><span class="line">//				else if(readBytes==0);</span><br><span class="line">                //链路已经关闭，释放资源</span><br><span class="line">                else if(readBytes&lt;0)&#123;</span><br><span class="line">                    key.cancel();</span><br><span class="line">                    sc.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //异步发送消息</span><br><span class="line">    private void doWrite(SocketChannel channel,String request) throws IOException &#123;</span><br><span class="line">        //将消息编码为字节数组</span><br><span class="line">        byte[] bytes = request.getBytes();</span><br><span class="line">        //根据数组容量创建ByteBuffer</span><br><span class="line">        ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);</span><br><span class="line">        //将字节数组复制到缓冲区</span><br><span class="line">        writeBuffer.put(bytes);</span><br><span class="line">        //flip操作</span><br><span class="line">        writeBuffer.flip();</span><br><span class="line">        //发送缓冲区的字节数组</span><br><span class="line">        channel.write(writeBuffer);</span><br><span class="line">        //****此处不含处理“写半包”的代码</span><br><span class="line">        // TODO: 2019/8/28 因为应答消息的发送，</span><br><span class="line">        //  SocketChannel也是异步非阻塞的，</span><br><span class="line">        //  所以不能保证一次能吧需要发送的数据发送完，</span><br><span class="line">        //  此时就会出现写半包的问题。我们需要注册写操作，</span><br><span class="line">        //  不断轮询Selector将没有发送完的消息发送完毕，</span><br><span class="line">        //  然后通过Buffer的hasRemain()方法判断消息是否发送完成。</span><br><span class="line">    &#125;</span><br><span class="line">    private void doConnect() throws IOException&#123;</span><br><span class="line">        if(socketChannel.connect(new InetSocketAddress(host,port)));</span><br><span class="line">        else socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">    &#125;</span><br><span class="line">    public void sendMsg(String msg) throws Exception&#123;</span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_WRITE);</span><br><span class="line">        doWrite(socketChannel, msg);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Test class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2017/6/24</span><br><span class="line"> */</span><br><span class="line">public class NIOTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        //运行服务器</span><br><span class="line">        Server.start();</span><br><span class="line">        //避免客户端先于服务器启动前执行代码</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        //运行客户端</span><br><span class="line">        Client.start();</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line"></span><br><span class="line">        Random random = new Random(System.currentTimeMillis());</span><br><span class="line">        char operators[] = &#123;&apos;+&apos;,&apos;-&apos;,&apos;*&apos;,&apos;/&apos;&#125;;</span><br><span class="line">//        String expression = random.nextInt(10)+&quot;&quot;+operators[random.nextInt(4)]+(random.nextInt(10)+1);</span><br><span class="line">//        while(Client.sendMsg(new Scanner(System.in).nextLine()));</span><br><span class="line">        while(</span><br><span class="line">                Client.sendMsg(random.nextInt(10)+&quot;&quot;+operators[random.nextInt(4)]+(random.nextInt(10)+1)))&#123;</span><br><span class="line">            Thread.sleep(random.nextInt(1000));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><a id="nio__47"></a><a class="header-anchor" href="#nio-结构">¶</a>nio 结构</h4><p><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/UTOOLS1571752663233.png" alt></p><h5><a id="_49"></a><a class="header-anchor" href="#服务端">¶</a>服务端</h5><ul><li>打开ServerSocketChannel，监听客户端连接</li><li>绑定监听端口，设置连接为非阻塞模式</li><li>创建Reactor线程，创建多路复用器并启动线程</li><li>将ServerSocketChannel注册到Reactor线程中的Selector上，监听ACCEPT事件</li><li>Selector轮询准备就绪的key</li><li>Selector监听到新的客户端接入，处理新的接入请求，完成TCP三次握手，建立链路</li></ul><h5><a id="_56"></a><a class="header-anchor" href="#客户端">¶</a>客户端</h5><ul><li>设置客户端链路为非阻塞模式</li><li>将新接入的客户端连接注册到Reactor线程的Selector上，监听读操作，读取客户端发送的网络消息</li><li>异步读取客户端消息到缓冲区</li><li>对Buffer编解码，处理半包消息，将解码成功的消息封装成Task</li><li>将应答消息编码为Buffer，调用SocketChannel的write将消息异步发送给客户端</li></ul><h6><a id="Selector_63"></a><a class="header-anchor" href="#selector-多路复用器-选择某个通道器">¶</a>Selector（多路复用器|选择某个通道器）</h6><p>选择器类管理着一个被注册的通道集合的信息和它们的就绪状态。<br>通道是和选择器一起被注册的，并且使用选择器来更新通道的就绪状态，<br>当这么做的时候，可以选择将被激发的线程挂起直到有就绪的通道。<br>使用Selector的好处在于： 使用更少的线程来就可以来处理通道了， 相比使用多个线程，避免了线程上下文切换带来的开销。</p><h5><a id="SelectionKey_69"></a><a class="header-anchor" href="#selectionkey">¶</a>SelectionKey</h5><p>表示了一个特定的通道对象和一个特定的选择器对象之间的注册关系。<br>key.attachment(); //返回SelectionKey的attachment，attachment可以在注册channel的时候指定。<br>key.channel(); // 返回该SelectionKey对应的channel。<br>key.selector(); // 返回该SelectionKey对应的Selector。<br>key.interestOps(); //返回代表需要Selector监控的IO操作的bit mask<br>key.readyOps(); // 返回一个bit mask，代表在相应channel上可以进行的IO操作。</p><table><thead><tr><th style="text-align:center">事件名</th><th style="text-align:center">对应值</th></tr></thead><tbody><tr><td style="text-align:center">服务端接收客户端连接事件</td><td style="text-align:center">SelectionKey.OP_ACCEPT(16)</td></tr><tr><td style="text-align:center">客户端连接服务端事件</td><td style="text-align:center">SelectionKey.OP_CONNECT(8)</td></tr><tr><td style="text-align:center">读事件</td><td style="text-align:center">SelectionKey.OP_READ(1)</td></tr><tr><td style="text-align:center">写事件</td><td style="text-align:center">SelectionKey.OP_WRITE(4)</td></tr></tbody></table><h4><a id="bufferbio_85"></a><a class="header-anchor" href="#buffer-解决bio中数据不可重复读的问题">¶</a>buffer（解决bio中数据不可重复读的问题）</h4><p>存储基本类型数组数据：ByteBuffer、CharBuffer、FloatBuffer、ShortBuffer、StringCharBuffer等等<br>这些方法中大部分是对mark、position、limit、capacity的操作。<br>对于数组来说，需要以下一些重要元素，比如数组大小（capacity）<br>此时如果是对数组的读取操作时，需要表明当前读到了哪个位置（position），总共可以读到哪个位置（limit），也就是当前数组中有几个元素。<br>此时如果是写操作，那么需要知道现在写到了哪个位置（position），最大可以写到哪个位置（limit）<br>最后为了实现可重复读，产生一个备忘位置，即标记（mark）。<br>源码（只截取部分）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Buffer &#123;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">    // Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span><br><span class="line">    private int mark = -1;</span><br><span class="line">    private int position = 0;</span><br><span class="line">    private int limit;</span><br><span class="line">    private int capacity;</span><br><span class="line">    // ...</span><br><span class="line">    </span><br><span class="line">    // Creates a new buffer with the given mark, position, limit, and capacity,</span><br><span class="line">    // after checking invariants.</span><br><span class="line">    //</span><br><span class="line">    Buffer(int mark, int pos, int lim, int cap) &#123;       // package-private</span><br><span class="line">        if (cap &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Negative capacity: &quot; + cap);</span><br><span class="line">        this.capacity = cap;</span><br><span class="line">        limit(lim);</span><br><span class="line">        position(pos);</span><br><span class="line">        if (mark &gt;= 0) &#123;</span><br><span class="line">            if (mark &gt; pos)</span><br><span class="line">                throw new IllegalArgumentException(&quot;mark &gt; position: (&quot;</span><br><span class="line">                                                   + mark + &quot; &gt; &quot; + pos + &quot;)&quot;);</span><br><span class="line">            this.mark = mark;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns this buffer&apos;s capacity.</span><br><span class="line">     *</span><br><span class="line">     * @return  The capacity of this buffer</span><br><span class="line">     */</span><br><span class="line">    public final int capacity() &#123;</span><br><span class="line">        return capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns this buffer&apos;s position.</span><br><span class="line">     *</span><br><span class="line">     * @return  The position of this buffer</span><br><span class="line">     */</span><br><span class="line">    public final int position() &#123;</span><br><span class="line">        return position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Sets this buffer&apos;s position.  If the mark is defined and larger than the</span><br><span class="line">     * new position then it is discarded.</span><br><span class="line">     *</span><br><span class="line">     * @param  newPosition</span><br><span class="line">     *         The new position value; must be non-negative</span><br><span class="line">     *         and no larger than the current limit</span><br><span class="line">     *</span><br><span class="line">     * @return  This buffer</span><br><span class="line">     *</span><br><span class="line">     * @throws  IllegalArgumentException</span><br><span class="line">     *          If the preconditions on &lt;tt&gt;newPosition&lt;/tt&gt; do not hold</span><br><span class="line">     */</span><br><span class="line">    public final Buffer position(int newPosition) &#123;</span><br><span class="line">        if ((newPosition &gt; limit) || (newPosition &lt; 0))</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        position = newPosition;</span><br><span class="line">        if (mark &gt; position) mark = -1;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns this buffer&apos;s limit.</span><br><span class="line">     *</span><br><span class="line">     * @return  The limit of this buffer</span><br><span class="line">     */</span><br><span class="line">    public final int limit() &#123;</span><br><span class="line">        return limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Sets this buffer&apos;s limit.  If the position is larger than the new limit</span><br><span class="line">     * then it is set to the new limit.  If the mark is defined and larger than</span><br><span class="line">     * the new limit then it is discarded.</span><br><span class="line">     *</span><br><span class="line">     * @param  newLimit</span><br><span class="line">     *         The new limit value; must be non-negative</span><br><span class="line">     *         and no larger than this buffer&apos;s capacity</span><br><span class="line">     *</span><br><span class="line">     * @return  This buffer</span><br><span class="line">     *</span><br><span class="line">     * @throws  IllegalArgumentException</span><br><span class="line">     *          If the preconditions on &lt;tt&gt;newLimit&lt;/tt&gt; do not hold</span><br><span class="line">     */</span><br><span class="line">    public final Buffer limit(int newLimit) &#123;</span><br><span class="line">        if ((newLimit &gt; capacity) || (newLimit &lt; 0))</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        limit = newLimit;</span><br><span class="line">        if (position &gt; limit) position = limit;</span><br><span class="line">        if (mark &gt; limit) mark = -1;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Sets this buffer&apos;s mark at its position.</span><br><span class="line">     *</span><br><span class="line">     * @return  This buffer</span><br><span class="line">     */</span><br><span class="line">    public final Buffer mark() &#123;</span><br><span class="line">        mark = position;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Resets this buffer&apos;s position to the previously-marked position.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; Invoking this method neither changes nor discards the mark&apos;s</span><br><span class="line">     * value. &lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * @return  This buffer</span><br><span class="line">     *</span><br><span class="line">     * @throws  InvalidMarkException</span><br><span class="line">     *          If the mark has not been set</span><br><span class="line">     */</span><br><span class="line">    public final Buffer reset() &#123;</span><br><span class="line">        int m = mark;</span><br><span class="line">        if (m &lt; 0)</span><br><span class="line">            throw new InvalidMarkException();</span><br><span class="line">        position = m;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Clears this buffer.  The position is set to zero, the limit is set to</span><br><span class="line">     * the capacity, and the mark is discarded.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; Invoke this method before using a sequence of channel-read or</span><br><span class="line">     * &lt;i&gt;put&lt;/i&gt; operations to fill this buffer.  For example:</span><br><span class="line">     *</span><br><span class="line">     * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line">     * buf.clear();     // Prepare buffer for reading</span><br><span class="line">     * in.read(buf);    // Read data&lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; This method does not actually erase the data in the buffer, but it</span><br><span class="line">     * is named as if it did because it will most often be used in situations</span><br><span class="line">     * in which that might as well be the case. &lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * @return  This buffer</span><br><span class="line">     */</span><br><span class="line">    public final Buffer clear() &#123;</span><br><span class="line">        position = 0;</span><br><span class="line">        limit = capacity;</span><br><span class="line">        mark = -1;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Flips this buffer.  The limit is set to the current position and then</span><br><span class="line">     * the position is set to zero.  If the mark is defined then it is</span><br><span class="line">     * discarded.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; After a sequence of channel-read or &lt;i&gt;put&lt;/i&gt; operations, invoke</span><br><span class="line">     * this method to prepare for a sequence of channel-write or relative</span><br><span class="line">     * &lt;i&gt;get&lt;/i&gt; operations.  For example:</span><br><span class="line">     *</span><br><span class="line">     * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line">     * buf.put(magic);    // Prepend header</span><br><span class="line">     * in.read(buf);      // Read data into rest of buffer</span><br><span class="line">     * buf.flip();        // Flip buffer</span><br><span class="line">     * out.write(buf);    // Write header + data to channel&lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; This method is often used in conjunction with the &#123;@link</span><br><span class="line">     * java.nio.ByteBuffer#compact compact&#125; method when transferring data from</span><br><span class="line">     * one place to another.  &lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * @return  This buffer</span><br><span class="line">     */</span><br><span class="line">    public final Buffer flip() &#123;</span><br><span class="line">        limit = position;</span><br><span class="line">        position = 0;</span><br><span class="line">        mark = -1;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Rewinds this buffer.  The position is set to zero and the mark is</span><br><span class="line">     * discarded.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; Invoke this method before a sequence of channel-write or &lt;i&gt;get&lt;/i&gt;</span><br><span class="line">     * operations, assuming that the limit has already been set</span><br><span class="line">     * appropriately.  For example:</span><br><span class="line">     *</span><br><span class="line">     * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line">     * out.write(buf);    // Write remaining data</span><br><span class="line">     * buf.rewind();      // Rewind buffer</span><br><span class="line">     * buf.get(array);    // Copy data into array&lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="line">     *</span><br><span class="line">     * @return  This buffer</span><br><span class="line">     */</span><br><span class="line">    public final Buffer rewind() &#123;</span><br><span class="line">        position = 0;</span><br><span class="line">        mark = -1;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接缓冲区与非直接缓冲区(ByteBuffer)：</p><ul><li>非直接缓冲区：<br>优点：在虚拟机内存中创建，易回收<br>缺点：但占用虚拟机内存开销，处理中有复制过程。</li><li>直接缓冲区：<br>优点：在虚拟机内存外，开辟的内存，IO操作直接进行,没有再次复制<br>缺点：创建和销毁开销大，没有管理权(基于系统的物理内存没有分代回收机制)<br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/UTOOLS1571752679822.png" alt><br><img src="https://raw.githubusercontent.com/jeff-eric/images_bed/master/blog/UTOOLS1571752697750.png" alt><br>用通俗的话讲就是，比如你是个小组长（jvm堆内存），你管理者你底下的人，<br>但是你的领导（内核[物理空间]）要知道你的情况，你需要把你的组内的情况汇报给他（复制），而他自己本身只知道你的情况，你下面人的情况他是不了解的也是不关心的，相当于他把这块区域分配给你，至于你要干什么，他是不管的</li></ul><p>JVM创建一个缓冲区的时候，实际上做了如下几件事：</p><ul><li>JVM确保Heap区域内的空间足够，如果不够则使用触发GC在内的方法获得空间;</li><li>获得空间之后会找一组堆内的连续地址分配数组, 这里需要注意的是，在物理内存上，这些字节是不一定连续的;</li><li>对于不涉及到IO的操作，这样的处理没有任何问题，但是当进行IO操作的时候就会出现一点性能问题.<br>所有的IO操作都需要操作系统进入内核态才行，而JVM进程属于用户态进程, 当JVM需要把一个缓冲区写到某个Channel或Socket的时候，需要切换到内核态.<br>而内核态由于并不知道JVM里面这个缓冲区存储在物理内存的什么地址，并且这些物理地址并不一定是连续的(或者说不一定是IO操作需要的块结构)，<br>所以在切换之前JVM需要把缓冲区复制到物理内存一块连续的内存上, 然后由内核去读取这块物理内存，整合成连续的、分块的内存.</li></ul><h1><a id="AIO_115"></a>三、AIO</h1><h4><a id="_116"></a><a class="header-anchor" href="#代码示例：">¶</a>代码示例：</h4><p>服务端代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">import javax.script.ScriptEngine;</span><br><span class="line">import javax.script.ScriptEngineManager;</span><br><span class="line">import javax.script.ScriptException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.UnsupportedEncodingException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line">import java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line">import java.nio.channels.CompletionHandler;</span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Server class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2017/6/24</span><br><span class="line"> */</span><br><span class="line">public class Server &#123;</span><br><span class="line"></span><br><span class="line">    private static int DEFAULT_PORT = 12345;</span><br><span class="line">    private static AsyncServerHandler serverHandle;</span><br><span class="line">    public volatile static long clientCount = 0;</span><br><span class="line">    public static void start()&#123;</span><br><span class="line">        start(DEFAULT_PORT);</span><br><span class="line">    &#125;</span><br><span class="line">    public static synchronized void start(int port)&#123;</span><br><span class="line">        if(serverHandle!=null)</span><br><span class="line">            return;</span><br><span class="line">        serverHandle = new AsyncServerHandler(port);</span><br><span class="line">        new Thread(serverHandle,&quot;Server&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Server.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AsyncServerHandler implements Runnable &#123;</span><br><span class="line">    public CountDownLatch latch;</span><br><span class="line">    public AsynchronousServerSocketChannel channel;</span><br><span class="line">    public AsyncServerHandler(int port) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //创建服务端通道</span><br><span class="line">            channel = AsynchronousServerSocketChannel.open();</span><br><span class="line">            //绑定端口</span><br><span class="line">            channel.bind(new InetSocketAddress(port));</span><br><span class="line">            System.out.println(&quot;服务器已启动，端口号：&quot; + port);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        //CountDownLatch初始化</span><br><span class="line">        //它的作用：在完成一组正在执行的操作之前，允许当前的现场一直阻塞</span><br><span class="line">        //此处，让现场在此阻塞，防止服务端执行完成后退出</span><br><span class="line">        //也可以使用while(true)+sleep</span><br><span class="line">        //生成环境就不需要担心这个问题，以为服务端是不会退出的</span><br><span class="line">        latch = new CountDownLatch(1);</span><br><span class="line">        //用于接收客户端的连接</span><br><span class="line">        channel.accept(this,new AcceptHandler());</span><br><span class="line">        try &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AcceptHandler implements CompletionHandler&lt;AsynchronousSocketChannel, AsyncServerHandler&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void completed(AsynchronousSocketChannel channel,AsyncServerHandler serverHandler) &#123;</span><br><span class="line">        //继续接受其他客户端的请求</span><br><span class="line">        Server.clientCount++;</span><br><span class="line">        System.out.println(&quot;连接的客户端数：&quot; + Server.clientCount);</span><br><span class="line">        serverHandler.channel.accept(serverHandler, this);</span><br><span class="line">        //创建新的Buffer</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">        //异步读  第三个参数为接收消息回调的业务Handler</span><br><span class="line">        channel.read(buffer, buffer, new ReadHandler(channel));</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void failed(Throwable exc, AsyncServerHandler serverHandler) &#123;</span><br><span class="line">        exc.printStackTrace();</span><br><span class="line">        serverHandler.latch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ReadHandler implements CompletionHandler&lt;Integer, ByteBuffer&gt; &#123;</span><br><span class="line">    //用于读取半包消息和发送应答</span><br><span class="line">    private AsynchronousSocketChannel channel;</span><br><span class="line">    public ReadHandler(AsynchronousSocketChannel channel) &#123;</span><br><span class="line">        this.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line">    //读取到消息后的处理</span><br><span class="line">    @Override</span><br><span class="line">    public void completed(Integer result, ByteBuffer attachment) &#123;</span><br><span class="line">        //flip操作</span><br><span class="line">        attachment.flip();</span><br><span class="line">        //根据</span><br><span class="line">        byte[] message = new byte[attachment.remaining()];</span><br><span class="line">        attachment.get(message);</span><br><span class="line">        try &#123;</span><br><span class="line">            String expression = new String(message, &quot;UTF-8&quot;);</span><br><span class="line">            System.out.println(&quot;服务器收到消息: &quot; + expression);</span><br><span class="line">            String calrResult = null;</span><br><span class="line">            try&#123;</span><br><span class="line">                calrResult = Calculator.cal(expression).toString();</span><br><span class="line">            &#125;catch(Exception e)&#123;</span><br><span class="line">                calrResult = &quot;计算错误：&quot; + e.getMessage();</span><br><span class="line">            &#125;</span><br><span class="line">            //向客户端发送消息</span><br><span class="line">            doWrite(calrResult);</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //发送消息</span><br><span class="line">    private void doWrite(String result) &#123;</span><br><span class="line">        byte[] bytes = result.getBytes();</span><br><span class="line">        ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);</span><br><span class="line">        writeBuffer.put(bytes);</span><br><span class="line">        writeBuffer.flip();</span><br><span class="line">        //异步写数据 参数与前面的read一样</span><br><span class="line">        channel.write(writeBuffer, writeBuffer,new CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void completed(Integer result, ByteBuffer buffer) &#123;</span><br><span class="line">                //如果没有发送完，就继续发送直到完成</span><br><span class="line">                if (buffer.hasRemaining())</span><br><span class="line">                    channel.write(buffer, buffer, this);</span><br><span class="line">                else&#123;</span><br><span class="line">                    //创建新的Buffer</span><br><span class="line">                    ByteBuffer readBuffer = ByteBuffer.allocate(1024);</span><br><span class="line">                    //异步读  第三个参数为接收消息回调的业务Handler</span><br><span class="line">                    channel.read(readBuffer, readBuffer, new ReadHandler(channel));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void failed(Throwable exc, ByteBuffer attachment) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void failed(Throwable exc, ByteBuffer attachment) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.channel.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final class Calculator &#123;</span><br><span class="line">    private final static ScriptEngine jse = new ScriptEngineManager().getEngineByName(&quot;JavaScript&quot;);</span><br><span class="line">    public static Object cal(String expression) throws ScriptException &#123;</span><br><span class="line">        return jse.eval(expression);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.UnsupportedEncodingException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line">import java.nio.channels.CompletionHandler;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Client class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2017/6/24</span><br><span class="line"> */</span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    private static String DEFAULT_HOST = &quot;127.0.0.1&quot;;</span><br><span class="line">    private static int DEFAULT_PORT = 12345;</span><br><span class="line">    private static AsyncClientHandler clientHandle;</span><br><span class="line">    public static void start()&#123;</span><br><span class="line">        start(DEFAULT_HOST,DEFAULT_PORT);</span><br><span class="line">    &#125;</span><br><span class="line">    public static synchronized void start(String ip,int port)&#123;</span><br><span class="line">        if(clientHandle!=null)</span><br><span class="line">            return;</span><br><span class="line">        clientHandle = new AsyncClientHandler(ip,port);</span><br><span class="line">        new Thread(clientHandle,&quot;Client&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    //向服务器发送消息</span><br><span class="line">    public static boolean sendMsg(String msg) throws Exception&#123;</span><br><span class="line">        if(msg.equals(&quot;q&quot;)) return false;</span><br><span class="line">        clientHandle.sendMsg(msg);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    @SuppressWarnings(&quot;resource&quot;)</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        Client.start();</span><br><span class="line">        System.out.println(&quot;请输入请求消息：&quot;);</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while(Client.sendMsg(scanner.nextLine()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AsyncClientHandler implements CompletionHandler&lt;Void, AsyncClientHandler&gt;, Runnable &#123;</span><br><span class="line">    private AsynchronousSocketChannel clientChannel;</span><br><span class="line">    private String host;</span><br><span class="line">    private int port;</span><br><span class="line">    private CountDownLatch latch;</span><br><span class="line">    public AsyncClientHandler(String host, int port) &#123;</span><br><span class="line">        this.host = host;</span><br><span class="line">        this.port = port;</span><br><span class="line">        try &#123;</span><br><span class="line">            //创建异步的客户端通道</span><br><span class="line">            clientChannel = AsynchronousSocketChannel.open();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        //创建CountDownLatch等待</span><br><span class="line">        latch = new CountDownLatch(1);</span><br><span class="line">        //发起异步连接操作，回调参数就是这个类本身，如果连接成功会回调completed方法</span><br><span class="line">        clientChannel.connect(new InetSocketAddress(host, port), this, this);</span><br><span class="line">        try &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; catch (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            clientChannel.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //连接服务器成功</span><br><span class="line">    //意味着TCP三次握手完成</span><br><span class="line">    @Override</span><br><span class="line">    public void completed(Void result, AsyncClientHandler attachment) &#123;</span><br><span class="line">        System.out.println(&quot;客户端成功连接到服务器...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //连接服务器失败</span><br><span class="line">    @Override</span><br><span class="line">    public void failed(Throwable exc, AsyncClientHandler attachment) &#123;</span><br><span class="line">        System.err.println(&quot;连接服务器失败...&quot;);</span><br><span class="line">        exc.printStackTrace();</span><br><span class="line">        try &#123;</span><br><span class="line">            clientChannel.close();</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //向服务器发送消息</span><br><span class="line">    public void sendMsg(String msg)&#123;</span><br><span class="line">        System.out.println(&quot;算术表达式为：&quot; + msg);</span><br><span class="line">        byte[] req = msg.getBytes();</span><br><span class="line">        ByteBuffer writeBuffer = ByteBuffer.allocate(req.length);</span><br><span class="line">        writeBuffer.put(req);</span><br><span class="line">        writeBuffer.flip();</span><br><span class="line">        //异步写</span><br><span class="line">        clientChannel.write(writeBuffer, writeBuffer,new WriteHandler(clientChannel, latch));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class WriteHandler implements CompletionHandler&lt;Integer, ByteBuffer&gt; &#123;</span><br><span class="line">    private AsynchronousSocketChannel clientChannel;</span><br><span class="line">    private CountDownLatch latch;</span><br><span class="line">    public WriteHandler(AsynchronousSocketChannel clientChannel,CountDownLatch latch) &#123;</span><br><span class="line">        this.clientChannel = clientChannel;</span><br><span class="line">        this.latch = latch;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void completed(Integer result, ByteBuffer buffer) &#123;</span><br><span class="line">        //完成全部数据的写入</span><br><span class="line">        if (buffer.hasRemaining()) &#123;</span><br><span class="line">            clientChannel.write(buffer, buffer, this);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            //读取数据</span><br><span class="line">            ByteBuffer readBuffer = ByteBuffer.allocate(1024);</span><br><span class="line">            clientChannel.read(readBuffer,readBuffer,new ClientReadHandler(clientChannel, latch));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void failed(Throwable exc, ByteBuffer attachment) &#123;</span><br><span class="line">        System.err.println(&quot;数据发送失败...&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            clientChannel.close();</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ClientReadHandler implements CompletionHandler&lt;Integer, ByteBuffer&gt; &#123;</span><br><span class="line">    private AsynchronousSocketChannel clientChannel;</span><br><span class="line">    private CountDownLatch latch;</span><br><span class="line">    public ClientReadHandler(AsynchronousSocketChannel clientChannel,CountDownLatch latch) &#123;</span><br><span class="line">        this.clientChannel = clientChannel;</span><br><span class="line">        this.latch = latch;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void completed(Integer result,ByteBuffer buffer) &#123;</span><br><span class="line">        buffer.flip();</span><br><span class="line">        byte[] bytes = new byte[buffer.remaining()];</span><br><span class="line">        buffer.get(bytes);</span><br><span class="line">        String body;</span><br><span class="line">        try &#123;</span><br><span class="line">            body = new String(bytes,&quot;UTF-8&quot;);</span><br><span class="line">            System.out.println(&quot;客户端收到结果:&quot;+ body);</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void failed(Throwable exc,ByteBuffer attachment) &#123;</span><br><span class="line">        System.err.println(&quot;数据读取失败...&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            clientChannel.close();</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Test class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2017/6/24</span><br><span class="line"> */</span><br><span class="line">public class AIOTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        //运行服务器</span><br><span class="line">        Server.start();</span><br><span class="line">        //避免客户端先于服务器启动前执行代码</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        //运行客户端</span><br><span class="line">        Client.start();</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line"></span><br><span class="line">        Random random = new Random(System.currentTimeMillis());</span><br><span class="line">        char operators[] = &#123;&apos;+&apos;,&apos;-&apos;,&apos;*&apos;,&apos;/&apos;&#125;;</span><br><span class="line"></span><br><span class="line">        while(Client.sendMsg(random.nextInt(10)+&quot;&quot;+operators[random.nextInt(4)]+(random.nextInt(10)+1)))&#123;</span><br><span class="line">            Thread.sleep(random.nextInt(1000));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><a id="_124"></a>四、总结</h1><h4><a id="_125"></a><a class="header-anchor" href="#同步和异步">¶</a>同步和异步</h4><p>我认为的网络层面io的同步和异步描述的是一种消息通知的机制，<strong><em>主动等待消息返回</em></strong>还是<strong><em>被动接受消息</em></strong><br>同步io：指的是调用方通过主动等待获取调用返回的结果来获取消息通知。<br>异步io：指的是被调用方通过某种方式（如，回调函数）来通知调用方获取消息。</p><h4><a id="_129"></a><a class="header-anchor" href="#阻塞和非阻塞">¶</a>阻塞和非阻塞</h4><p>NIO、AIO为什么被称为非阻塞？</p><ul><li>BIO在发起读请求以后，会一直等待，一直到拿到结果</li><li>NIO在发起读请求以后，不会立即拿到结果</li><li>AIO通过回调方法，被动的接受</li></ul><h4><a id="BIOblocking_IO_135"></a><a class="header-anchor" href="#bio-blocking-io-：">¶</a>BIO（blocking IO)：</h4><p>同步阻塞式IO 面向流 操作字节或字符 单向传输数据</p><h4><a id="NIOnon_blocking_IO_137"></a><a class="header-anchor" href="#nio-non-blocking-io-：">¶</a>NIO（non blocking IO)：</h4><p>同步非阻塞式IO 面向通道 操作缓冲区 双向传输数据</p><h4><a id="AIOasync_IO_139"></a><a class="header-anchor" href="#aio-async-io-：">¶</a>AIO（async IO)：</h4><p>同步非阻塞式IO 大量使用回调函数 异步处理通信过程 异步的双向传输数据</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jeff-eric.github.com/blog/blog/2019/08/20/Java%E4%BB%A3%E7%90%86/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jeff-Eric"><meta itemprop="description" content=""><meta itemprop="image" content="/blog/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="纯天然绿色学渣"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/blog/2019/08/20/Java%E4%BB%A3%E7%90%86/" class="post-title-link" itemprop="url">java 代理</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-08-20 19:39:15" itemprop="dateCreated datePublished" datetime="2019-08-20T19:39:15+08:00">2019-08-20</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-10-22 13:46:20" itemprop="dateModified" datetime="2019-10-22T13:46:20+08:00">2019-10-22</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/blog/2019/08/20/Java%E4%BB%A3%E7%90%86/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/2019/08/20/Java%E4%BB%A3%E7%90%86/" itemprop="commentCount"></span> </a></span><span id="/blog/2019/08/20/Java%E4%BB%A3%E7%90%86/" class="leancloud_visitors" data-flag-title="java 代理"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body han-init-context" itemprop="articleBody"><h1><a id="1JDK_1"></a>1、JDK静态代理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package org.jphoebe.edu.demo.proxy.staticProxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 静态代理</span><br><span class="line"> */</span><br><span class="line">public class UserProxy implements StaticPerson &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 静态代理</span><br><span class="line">        StaticUser targetObj = new StaticUser();</span><br><span class="line">        new UserProxy(targetObj).exection();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public StaticUser user;</span><br><span class="line"></span><br><span class="line">    public UserProxy(StaticUser user) &#123;</span><br><span class="line">        this.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exection() &#123;</span><br><span class="line">        System.out.println(&quot;执行真正的代码前。。。。。。&quot;);</span><br><span class="line">        user.exection();</span><br><span class="line">        System.out.println(&quot;执行真正的代码后。。。。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">interface StaticPerson &#123;</span><br><span class="line">    void exection();</span><br><span class="line">&#125;</span><br><span class="line">class StaticUser implements StaticPerson &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void exection() &#123;</span><br><span class="line">        System.out.println(&quot;实际执行的代码&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><a id="2JDK_4"></a>2、JDK动态代理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package org.jphoebe.edu.demo.proxy.dynamic;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 动态代理</span><br><span class="line"> */</span><br><span class="line">public class ProxyHandle implements InvocationHandler &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 参数：-Dsun.misc.ProxyGenerator.saveGeneratedFiles 可以让jdk生成代理后的class文件， 源码：ProxyGenerator.saveGeneratedFiles</span><br><span class="line">        DynamicUser targetObj = new DynamicUser();</span><br><span class="line">        ProxyHandle proxyHandle = new ProxyHandle(new DynamicUser());</span><br><span class="line">        DynamicPerson proxyObject = (DynamicPerson) Proxy.newProxyInstance(</span><br><span class="line">                DynamicUser.class.getClassLoader(),</span><br><span class="line">                DynamicUser.class.getInterfaces(),</span><br><span class="line">                proxyHandle);</span><br><span class="line">        proxyObject.exection();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    private Object proxyObj;</span><br><span class="line">    public ProxyHandle(Object targetObj) &#123;</span><br><span class="line">        this.proxyObj = targetObj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        System.out.println(&quot;DynamicProxy类对&quot; + methodName + &quot;进行了增强处理,begin....&quot;);</span><br><span class="line">        // 执行原有方法</span><br><span class="line">        method.invoke(proxyObj, args);</span><br><span class="line">        System.out.println(&quot;DynamicProxy类对&quot; + methodName + &quot;进行了增强处理,end....&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface DynamicPerson &#123;</span><br><span class="line">    void exection();</span><br><span class="line">&#125;</span><br><span class="line">class DynamicUser implements DynamicPerson &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void exection() &#123;</span><br><span class="line">        System.out.println(&quot;实际执行的代码&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以解释Mybatis为什么定义一个接口就可以执行sql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package org.jphoebe.edu.demo.proxy.dynamic;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * ProxyFactory class</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MybatisProxy implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // mybatis mapper代理的实现</span><br><span class="line">        MybatisProxy mybatisProxy = new MybatisProxy(PersonMapper.class);</span><br><span class="line">        PersonMapper proxyObject = (PersonMapper) Proxy.newProxyInstance(</span><br><span class="line">                PersonMapper.class.getClassLoader(),</span><br><span class="line">                new Class[] &#123; PersonMapper.class &#125;,</span><br><span class="line">                mybatisProxy);</span><br><span class="line">        proxyObject.exection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Object proxyObj;</span><br><span class="line"></span><br><span class="line">    public MybatisProxy(Object targetObj) &#123;</span><br><span class="line">        this.proxyObj = targetObj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        System.out.println(&quot;执行与该接口对应的mapping xml文件中的sql&quot;);</span><br><span class="line">        // 执行sql的操作</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface PersonMapper &#123;</span><br><span class="line">    void exection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态代理生成的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">package org.jphoebe.edu.demo.proxy.dynamic;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line">final class $Proxy0 extends Proxy implements PersonMapper &#123;</span><br><span class="line">    private static Method m1;</span><br><span class="line">    private static Method m2;</span><br><span class="line">    private static Method m3;</span><br><span class="line">    private static Method m0;</span><br><span class="line"></span><br><span class="line">    public $Proxy0(InvocationHandler var1) throws  &#123;</span><br><span class="line">        super(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object var1) throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; catch (RuntimeException | Error var3) &#123;</span><br><span class="line">            throw var3;</span><br><span class="line">        &#125; catch (Throwable var4) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final String toString() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (String)super.h.invoke(this, m2, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void exection() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m3, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final int hashCode() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Integer)super.h.invoke(this, m0, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));</span><br><span class="line">            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;);</span><br><span class="line">            m3 = Class.forName(&quot;org.jphoebe.edu.demo.proxy.dynamic.PersonMapper&quot;).getMethod(&quot;exection&quot;);</span><br><span class="line">            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;);</span><br><span class="line">        &#125; catch (NoSuchMethodException var2) &#123;</span><br><span class="line">            throw new NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; catch (ClassNotFoundException var3) &#123;</span><br><span class="line">            throw new NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，生成的类继承了被代理对象的接口，所以JDK原生的动态代理是基于接口的，如果对象没有使用接口，那么就无法使用jdk动态代理，需要使用cglib动态代理</p><h1><a id="2cglib_12"></a>2、cglib动态代理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">package org.jphoebe.edu.demo.proxy.cglib;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import net.sf.cglib.core.DebuggingClassWriter;</span><br><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * CglibProxy class</span><br><span class="line"> *</span><br><span class="line"> * @author 蒋时华</span><br><span class="line"> * @date 2019/8/29</span><br><span class="line"> */</span><br><span class="line">public class CglibProxy implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // cglib 代理</span><br><span class="line">        // 代理类class文件存入本地磁盘方便我们反编译查看源码</span><br><span class="line">        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;E:\\prod\\edu-demo&quot;);</span><br><span class="line">        // 通过CGLIB动态代理获取代理对象的过程</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        // 设置enhancer对象的父类</span><br><span class="line">        enhancer.setSuperclass(CglibUser.class);</span><br><span class="line">        // 设置enhancer的回调对象</span><br><span class="line">        enhancer.setCallback(new CglibProxy());</span><br><span class="line">        // 创建代理对象</span><br><span class="line">        CglibUser proxy= (CglibUser)enhancer.create();</span><br><span class="line">        // 通过代理对象调用目标方法</span><br><span class="line">        proxy.exection();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 源码</span><br><span class="line">        // MethodInterceptor</span><br><span class="line">        // Enhancer.createHelper()</span><br><span class="line">        // KeyFactory.generateClass()</span><br><span class="line">        // AbstractClassGenerator.create()</span><br><span class="line">        // BeanGenerator.nextInstance()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * sub：cglib生成的代理对象</span><br><span class="line">     * method：被代理对象方法</span><br><span class="line">     * objects：方法入参</span><br><span class="line">     * methodProxy: 代理方法</span><br><span class="line">     */</span><br><span class="line">    /**</span><br><span class="line">     * FastClass f1; // net.sf.cglib.test.Target的fastclass</span><br><span class="line">     * FastClass f2; // Target$$EnhancerByCGLIB$$788444a0 的fastclass</span><br><span class="line">     * int i1; //方法g在f1中的索引</span><br><span class="line">     * int i2; //方法CGLIB$g$0在f2中的索引</span><br><span class="line">     *</span><br><span class="line">    **/</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object sub, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;======插入前置通知======&quot;);</span><br><span class="line">        Object object = methodProxy.invokeSuper(sub, objects);</span><br><span class="line">        System.out.println(&quot;======插入后者通知======&quot;);</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CglibUser&#123;</span><br><span class="line">    public void exection() &#123;</span><br><span class="line">        System.out.println(&quot;实际执行的代码&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用cglib代理,会生成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CglibUser$$EnhancerByCGLIB$$45809d07$$FastClassByCGLIB$$db8bd788.class</span><br><span class="line">CglibUser$$EnhancerByCGLIB$$45809d07.class</span><br><span class="line">CglibUser$$FastClassByCGLIB$$575d67e9.class</span><br></pre></td></tr></table></figure><p>三个文件<br>EnhancerByCGLIB：是生成的代理对象<br>FastClassByCGLIB：是原对象方法的索引地址（避免使用了反射，而是直接调用对象方法）<br>EnhancerByCGLIB$$45809d07$$FastClassByCGLIB：是生成代理对方法的索引地址<br>fastclass中的部分代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public int getIndex(Signature var1) &#123;</span><br><span class="line">        String var10000 = var1.toString();</span><br><span class="line">        switch(var10000.hashCode()) &#123;</span><br><span class="line">        case -1651887568:</span><br><span class="line">            if (var10000.equals(&quot;exection()V&quot;)) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case 1826985398:</span><br><span class="line">            if (var10000.equals(&quot;equals(Ljava/lang/Object;)Z&quot;)) &#123;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case 1913648695:</span><br><span class="line">            if (var10000.equals(&quot;toString()Ljava/lang/String;&quot;)) &#123;</span><br><span class="line">                return 2;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case 1984935277:</span><br><span class="line">            if (var10000.equals(&quot;hashCode()I&quot;)) &#123;</span><br><span class="line">                return 3;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>生成class源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// MethodInterceptor</span><br><span class="line">// Enhancer.createHelper()</span><br><span class="line">// KeyFactory.generateClass()</span><br><span class="line">// AbstractClassGenerator.create()</span><br><span class="line">// BeanGenerator.nextInstance()</span><br></pre></td></tr></table></figure><p>生成对象核心代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">public void generateClass(ClassVisitor v) &#123;</span><br><span class="line">			ClassEmitter ce = new ClassEmitter(v);</span><br><span class="line"></span><br><span class="line">			Method newInstance = ReflectUtils.findNewInstance(keyInterface);</span><br><span class="line">			if (!newInstance.getReturnType().equals(Object.class)) &#123;</span><br><span class="line">				throw new IllegalArgumentException(&quot;newInstance method must return Object&quot;);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Type[] parameterTypes = TypeUtils.getTypes(newInstance.getParameterTypes());</span><br><span class="line">			ce.begin_class(Constants.V1_2,</span><br><span class="line">					Constants.ACC_PUBLIC,</span><br><span class="line">					getClassName(),</span><br><span class="line">					KEY_FACTORY,</span><br><span class="line">					new Type[]&#123;Type.getType(keyInterface)&#125;,</span><br><span class="line">					Constants.SOURCE_FILE);</span><br><span class="line">			EmitUtils.null_constructor(ce);</span><br><span class="line">			EmitUtils.factory_method(ce, ReflectUtils.getSignature(newInstance));</span><br><span class="line"></span><br><span class="line">			int seed = 0;</span><br><span class="line">			CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC,</span><br><span class="line">					TypeUtils.parseConstructor(parameterTypes),</span><br><span class="line">					null);</span><br><span class="line">			e.load_this();</span><br><span class="line">			e.super_invoke_constructor();</span><br><span class="line">			e.load_this();</span><br><span class="line">			List&lt;FieldTypeCustomizer&gt; fieldTypeCustomizers = getCustomizers(FieldTypeCustomizer.class);</span><br><span class="line">			for (int i = 0; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">				Type parameterType = parameterTypes[i];</span><br><span class="line">				Type fieldType = parameterType;</span><br><span class="line">				for (FieldTypeCustomizer customizer : fieldTypeCustomizers) &#123;</span><br><span class="line">					fieldType = customizer.getOutType(i, fieldType);</span><br><span class="line">				&#125;</span><br><span class="line">				seed += fieldType.hashCode();</span><br><span class="line">				ce.declare_field(Constants.ACC_PRIVATE | Constants.ACC_FINAL,</span><br><span class="line">						getFieldName(i),</span><br><span class="line">						fieldType,</span><br><span class="line">						null);</span><br><span class="line">				e.dup();</span><br><span class="line">				e.load_arg(i);</span><br><span class="line">				for (FieldTypeCustomizer customizer : fieldTypeCustomizers) &#123;</span><br><span class="line">					customizer.customize(e, i, parameterType);</span><br><span class="line">				&#125;</span><br><span class="line">				e.putfield(getFieldName(i));</span><br><span class="line">			&#125;</span><br><span class="line">			e.return_value();</span><br><span class="line">			e.end_method();</span><br><span class="line"></span><br><span class="line">			// hash code</span><br><span class="line">			e = ce.begin_method(Constants.ACC_PUBLIC, HASH_CODE, null);</span><br><span class="line">			int hc = (constant != 0) ? constant : PRIMES[(Math.abs(seed) % PRIMES.length)];</span><br><span class="line">			int hm = (multiplier != 0) ? multiplier : PRIMES[(Math.abs(seed * 13) % PRIMES.length)];</span><br><span class="line">			e.push(hc);</span><br><span class="line">			for (int i = 0; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">				e.load_this();</span><br><span class="line">				e.getfield(getFieldName(i));</span><br><span class="line">				EmitUtils.hash_code(e, parameterTypes[i], hm, customizers);</span><br><span class="line">			&#125;</span><br><span class="line">			e.return_value();</span><br><span class="line">			e.end_method();</span><br><span class="line"></span><br><span class="line">			// equals</span><br><span class="line">			e = ce.begin_method(Constants.ACC_PUBLIC, EQUALS, null);</span><br><span class="line">			Label fail = e.make_label();</span><br><span class="line">			e.load_arg(0);</span><br><span class="line">			e.instance_of_this();</span><br><span class="line">			e.if_jump(CodeEmitter.EQ, fail);</span><br><span class="line">			for (int i = 0; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">				e.load_this();</span><br><span class="line">				e.getfield(getFieldName(i));</span><br><span class="line">				e.load_arg(0);</span><br><span class="line">				e.checkcast_this();</span><br><span class="line">				e.getfield(getFieldName(i));</span><br><span class="line">				EmitUtils.not_equals(e, parameterTypes[i], fail, customizers);</span><br><span class="line">			&#125;</span><br><span class="line">			e.push(1);</span><br><span class="line">			e.return_value();</span><br><span class="line">			e.mark(fail);</span><br><span class="line">			e.push(0);</span><br><span class="line">			e.return_value();</span><br><span class="line">			e.end_method();</span><br><span class="line"></span><br><span class="line">			// toString</span><br><span class="line">			e = ce.begin_method(Constants.ACC_PUBLIC, TO_STRING, null);</span><br><span class="line">			e.new_instance(Constants.TYPE_STRING_BUFFER);</span><br><span class="line">			e.dup();</span><br><span class="line">			e.invoke_constructor(Constants.TYPE_STRING_BUFFER);</span><br><span class="line">			for (int i = 0; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">				if (i &gt; 0) &#123;</span><br><span class="line">					e.push(&quot;, &quot;);</span><br><span class="line">					e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);</span><br><span class="line">				&#125;</span><br><span class="line">				e.load_this();</span><br><span class="line">				e.getfield(getFieldName(i));</span><br><span class="line">				EmitUtils.append_string(e, parameterTypes[i], EmitUtils.DEFAULT_DELIMITERS, customizers);</span><br><span class="line">			&#125;</span><br><span class="line">			e.invoke_virtual(Constants.TYPE_STRING_BUFFER, TO_STRING);</span><br><span class="line">			e.return_value();</span><br><span class="line">			e.end_method();</span><br><span class="line"></span><br><span class="line">			ce.end_class();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure><p>再来看看正常java代码的字节码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">// class version 52.0 (52)</span><br><span class="line">// access flags 0x21</span><br><span class="line">public class org/jphoebe/edu/demo/proxy/staticProxy/UserProxy implements org/jphoebe/edu/demo/proxy/staticProxy/StaticPerson &#123;</span><br><span class="line"></span><br><span class="line">  // compiled from: UserProxy.java</span><br><span class="line"></span><br><span class="line">  // access flags 0x1</span><br><span class="line">  public Lorg/jphoebe/edu/demo/proxy/staticProxy/StaticUser; user</span><br><span class="line"></span><br><span class="line">  // access flags 0x9</span><br><span class="line">  public static main([Ljava/lang/String;)V</span><br><span class="line">    // parameter  args</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER 10 L0</span><br><span class="line">    NEW org/jphoebe/edu/demo/proxy/staticProxy/StaticUser</span><br><span class="line">    DUP</span><br><span class="line">    INVOKESPECIAL org/jphoebe/edu/demo/proxy/staticProxy/StaticUser.&lt;init&gt; ()V</span><br><span class="line">    ASTORE 1</span><br><span class="line">   L1</span><br><span class="line">    LINENUMBER 11 L1</span><br><span class="line">    NEW org/jphoebe/edu/demo/proxy/staticProxy/UserProxy</span><br><span class="line">    DUP</span><br><span class="line">    ALOAD 1</span><br><span class="line">    INVOKESPECIAL org/jphoebe/edu/demo/proxy/staticProxy/UserProxy.&lt;init&gt; (Lorg/jphoebe/edu/demo/proxy/staticProxy/StaticUser;)V</span><br><span class="line">    INVOKEVIRTUAL org/jphoebe/edu/demo/proxy/staticProxy/UserProxy.exection ()V</span><br><span class="line">   L2</span><br><span class="line">    LINENUMBER 13 L2</span><br><span class="line">    RETURN</span><br><span class="line">   L3</span><br><span class="line">    LOCALVARIABLE args [Ljava/lang/String; L0 L3 0</span><br><span class="line">    LOCALVARIABLE targetObj Lorg/jphoebe/edu/demo/proxy/staticProxy/StaticUser; L1 L3 1</span><br><span class="line">    MAXSTACK = 3</span><br><span class="line">    MAXLOCALS = 2</span><br><span class="line"></span><br><span class="line">  // access flags 0x1</span><br><span class="line">  public &lt;init&gt;(Lorg/jphoebe/edu/demo/proxy/staticProxy/StaticUser;)V</span><br><span class="line">    // parameter  user</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER 17 L0</span><br><span class="line">    ALOAD 0</span><br><span class="line">    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V</span><br><span class="line">   L1</span><br><span class="line">    LINENUMBER 18 L1</span><br><span class="line">    ALOAD 0</span><br><span class="line">    ALOAD 1</span><br><span class="line">    PUTFIELD org/jphoebe/edu/demo/proxy/staticProxy/UserProxy.user : Lorg/jphoebe/edu/demo/proxy/staticProxy/StaticUser;</span><br><span class="line">   L2</span><br><span class="line">    LINENUMBER 19 L2</span><br><span class="line">    RETURN</span><br><span class="line">   L3</span><br><span class="line">    LOCALVARIABLE this Lorg/jphoebe/edu/demo/proxy/staticProxy/UserProxy; L0 L3 0</span><br><span class="line">    LOCALVARIABLE user Lorg/jphoebe/edu/demo/proxy/staticProxy/StaticUser; L0 L3 1</span><br><span class="line">    MAXSTACK = 2</span><br><span class="line">    MAXLOCALS = 2</span><br><span class="line"></span><br><span class="line">  // access flags 0x1</span><br><span class="line">  public exection()V</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER 23 L0</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    LDC &quot;\u6267\u884c\u771f\u6b63\u7684\u4ee3\u7801\u524d\u3002\u3002\u3002\u3002\u3002\u3002&quot;</span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V</span><br><span class="line">   L1</span><br><span class="line">    LINENUMBER 25 L1</span><br><span class="line">    ALOAD 0</span><br><span class="line">    GETFIELD org/jphoebe/edu/demo/proxy/staticProxy/UserProxy.user : Lorg/jphoebe/edu/demo/proxy/staticProxy/StaticUser;</span><br><span class="line">    INVOKEVIRTUAL org/jphoebe/edu/demo/proxy/staticProxy/StaticUser.exection ()V</span><br><span class="line">   L2</span><br><span class="line">    LINENUMBER 27 L2</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    LDC &quot;\u6267\u884c\u771f\u6b63\u7684\u4ee3\u7801\u540e\u3002\u3002\u3002\u3002\u3002\u3002&quot;</span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V</span><br><span class="line">   L3</span><br><span class="line">    LINENUMBER 28 L3</span><br><span class="line">    RETURN</span><br><span class="line">   L4</span><br><span class="line">    LOCALVARIABLE this Lorg/jphoebe/edu/demo/proxy/staticProxy/UserProxy; L0 L4 0</span><br><span class="line">    MAXSTACK = 2</span><br><span class="line">    MAXLOCALS = 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会发现有诸多相似的命令，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dup (dup())</span><br><span class="line">aload (load_this())</span><br><span class="line">return (return_value())</span><br></pre></td></tr></table></figure><p>等等<br>所以CGlib实际上是直接写字节码来创建代理类，所以也就无所无是否继承了接口，代理类只需要直接代理这个类就行。</p><h1><a id="_34"></a>总结</h1><h3><a id="jdk_36"></a><a class="header-anchor" href="#jdk动态代理">¶</a>jdk动态代理</h3><h4><a id="_37"></a><a class="header-anchor" href="#特点">¶</a>特点</h4><ul><li><p>Interface：对于JDK Proxy,业务类是需要一个Interface的，这是一个缺陷；</p></li><li><p>Proxy：Proxy类是动态产生的，这个类在调用Proxy.newProxyInstance()方法之后，产生一个Proxy类的实力。实际上，这个Proxy类也是存在的，不仅仅是类的实例，这个Proxy类可以保存在硬盘上；</p></li><li><p>Method：对于业务委托类的每个方法，现在Proxy类里面都不用静态显示出来。</p></li><li><p>InvocationHandler：这个类在业务委托类执行时，会先调用invoke方法。invoke方法在执行想要的代理操作，可以实现对业务方法的再包装。</p></li><li><p>JDK动态代理类实现了InvocationHandler接口，重写的invoke方法。<br>JDK动态代理的基础是反射机制（method.invoke(对象，参数)）Proxy.newProxyInstance()</p></li></ul><h3><a id="cglib_46"></a><a class="header-anchor" href="#cglib动态代理">¶</a>cglib动态代理</h3><h4><a id="_47"></a><a class="header-anchor" href="#特点-v2">¶</a>特点</h4><ul><li>CGLib采用底层的字节码技术，全称是：Code Generation Library，CGLib可以为一个类创建一个子类，在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势织入横切逻辑。</li><li>对指定的目标生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。</li><li>注意:jdk的动态代理只可以为接口去完成操作，而cglib它可以为没有实现接口的类去做代理，也可以为实现接口的类去做代理。</li></ul><h3><a id="_52"></a><a class="header-anchor" href="#性能对比">¶</a>性能对比</h3><p>关于两者之间的性能的话，JDK动态代理所创建的代理对象，在以前的JDK版本中，性能并不是很高，虽然在高版本中JDK动态代理对象的性能得到了很大的提升，但是他也并不是适用于所有的场景。主要体现在如下的两个指标中：</p><ul><li>CGLib所创建的动态代理对象在实际运行时候的性能要比JDK动态代理高不少，有研究表明，大概要高10倍；</li><li>但是CGLib在创建对象的时候所花费的时间却比JDK动态代理要多很多，有研究表明，大概有8倍的差距；</li><li>对于singleton的代理对象或者具有实例池的代理，因为无需频繁的创建代理对象，所以比较适合采用CGLib动态代理，反正，则比较适用JDK动态代理。</li></ul><h5><a id="__httpsblogcsdnnetxlgen157387articledetails82497594_58"></a><a class="header-anchor" href="#查看-具体测试结果">¶</a>查看 =&gt;&gt;&gt; <a href="https://blog.csdn.net/xlgen157387/article/details/82497594" target="_blank" rel="noopener">具体测试结果</a></h5></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jeff-eric.github.com/blog/blog/2019/03/15/%E8%B7%B3%E5%8F%B0%E9%98%B6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jeff-Eric"><meta itemprop="description" content=""><meta itemprop="image" content="/blog/uploads/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="纯天然绿色学渣"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/blog/2019/03/15/%E8%B7%B3%E5%8F%B0%E9%98%B6/" class="post-title-link" itemprop="url">跳台阶</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-03-15 23:58:03" itemprop="dateCreated datePublished" datetime="2019-03-15T23:58:03+08:00">2019-03-15</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-03-16 00:05:54" itemprop="dateModified" datetime="2019-03-16T00:05:54+08:00">2019-03-16</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/" itemprop="url" rel="index"><span itemprop="name">算法技巧</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/blog/2019/03/15/%E8%B7%B3%E5%8F%B0%E9%98%B6/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/2019/03/15/%E8%B7%B3%E5%8F%B0%E9%98%B6/" itemprop="commentCount"></span> </a></span><span id="/blog/2019/03/15/%E8%B7%B3%E5%8F%B0%E9%98%B6/" class="leancloud_visitors" data-flag-title="跳台阶"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div></header><div class="post-body han-init-context" itemprop="articleBody"><h3><a id="_1"></a><a class="header-anchor" href="#题目描述">¶</a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。<br><br></p><h5><a id="python__4"></a><a class="header-anchor" href="#python-穷举法解二元一次方程">¶</a>python 穷举法解二元一次方程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#3x+4y = 100 求 x = ? ,y = ?</span><br><span class="line">x = 0</span><br><span class="line">while x &lt;= (100//3):</span><br><span class="line">    if(100 - 3*x) % 4 == 0:</span><br><span class="line">        y = (100 - 3*x) // 4</span><br><span class="line">        print(&quot;共有解：x的值是 %d,y的值是 %d&quot;%(x,y))</span><br><span class="line">    x += 1</span><br><span class="line">    </span><br><span class="line">共有解：x的值是 0,y的值是 25</span><br><span class="line">共有解：x的值是 4,y的值是 22</span><br><span class="line">共有解：x的值是 8,y的值是 19</span><br><span class="line">共有解：x的值是 12,y的值是 16</span><br><span class="line">共有解：x的值是 16,y的值是 13</span><br><span class="line">共有解：x的值是 20,y的值是 10</span><br><span class="line">共有解：x的值是 24,y的值是 7</span><br><span class="line">共有解：x的值是 28,y的值是 4</span><br><span class="line">共有解：x的值是 32,y的值是 1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article></section><nav class="pagination"><a class="extend prev" rel="prev" href="/blog/">&lt;i class=&quot;fa fa-angle-left&quot; aria-label=&quot;上一页&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/blog/">1</a><span class="page-number current">2</span><a class="page-number" href="/blog/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/5/">5</a><a class="extend next" rel="next" href="/blog/page/3/">&lt;i class=&quot;fa fa-angle-right&quot; aria-label=&quot;下一页&quot;&gt;&lt;&#x2F;i&gt;</a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><div class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/blog/uploads/avatar.jpg" alt="Jeff-Eric"><p class="site-author-name" itemprop="name">Jeff-Eric</p><div class="site-description motion-element" itemprop="description"></div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/blog/archives/%20%7C%7C%20archive"><span class="site-state-item-count">42</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/blog/categories/%20%7C%7C%20th"><span class="site-state-item-count">12</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/blog/tags/%20%7C%7C%20tags"><span class="site-state-item-count">28</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/jeff-eric" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;jeff-eric" rel="noopener" target="_blank">&lt;i class=&quot;fa fa-fw fa-github&quot;&gt;&lt;&#x2F;i&gt;GitHub</a> </span><span class="links-of-author-item"><a href="/blog/jphoebe4086824@gmail.com" title="E-Mail &amp;rarr; jphoebe4086824@gmail.com">&lt;i class=&quot;fa fa-fw fa-envelope&quot;&gt;&lt;&#x2F;i&gt;E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank">&lt;img src=&quot;&#x2F;blog&#x2F;images&#x2F;cc-by-nc-sa.svg&quot; alt=&quot;Creative Commons&quot;&#x2F;&gt;</a></div></div></div><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Jeff-Eric</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0</div><span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.0.1</div></div></footer><div id="needsharebutton-float"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script><script id="ribbon" size="300" alpha="0.6" zindex="-1" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@2/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/npm/fastclick@1/lib/fastclick.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery-lazyload@1/jquery.lazyload.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three-waves.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_lines.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_sphere.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-reading-progress@1/reading_progress.min.js"></script><script src="/blog/js/src/utils.js?v=7.0.1"></script><script src="/blog/js/src/motion.js?v=7.0.1"></script><script src="/blog/js/src/affix.js?v=7.0.1"></script><script src="/blog/js/src/schemes/pisces.js?v=7.0.1"></script><script src="/blog/js/src/next-boot.js?v=7.0.1"></script><script src="/blog/js/src/js.cookie.js?v=7.0.1"></script><script src="/blog/js/src/scroll-cookie.js?v=7.0.1"></script><script src="//cdn.jsdelivr.net/npm/quicklink@1.0.0/dist/quicklink.umd.js"></script><script>window.addEventListener('load', () => {
      
        quicklink({
          timeout: 3000,
          priority: true,
          ignores: [uri => uri.includes('#'),uri => uri == 'https://jeff-eric.github.com/blog/page/2/',]
        });
      
        });</script><script src="//cdn.jsdelivr.net/npm/leancloud-storage@3/dist/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js"></script><script>var GUEST=["nick","mail","link"],guest="nick,mail,link";guest=guest.split(",").filter(function(e){return GUEST.indexOf(e)>-1}),new Valine({el:"#comments",verify:!0,notify:!1,appId:"MKGyMx7EafphCr9hAbMPAwAc-gzGzoHsz",appKey:"4SB8MPoE51bFPHDoKtPM8vLG",placeholder:"Just go go",avatar:"mm",meta:guest,pageSize:"10",visitor:!0})</script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var e=$("#local-search-input");e.attr("autocapitalize","none"),e.attr("autocorrect","off"),e.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/blog/"+search_path,onPopupClose=function(e){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(e,t,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:e,dataType:isXml?"xml":"json",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,r=document.getElementById(t),s=document.getElementById(o),a=function(){var e=r.value.trim().toLowerCase(),t=e.split(/[\s\-]+/);t.length>1&&t.push(e);var o=[];if(e.length>0&&n.forEach(function(n){function r(t,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===e&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(e,t){var o="",n=t.start;return t.hits.forEach(function(t){o+=e.substring(n,t.position);var r=t.position+t.length;o+='<b class="search-keyword">'+e.substring(t.position,r)+"</b>",n=r}),o+=e.substring(n,t.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url).replace(/\/{2,}/g,"/"),d=[],g=[];if(""!=l&&(t.forEach(function(e){function t(e,t,o){var n=e.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(t=t.toLowerCase(),e=e.toLowerCase());(s=t.indexOf(e,r))>-1;)a.push({position:s,word:e}),r=s+n;return a}d=d.concat(t(e,h,!1)),g=g.concat(t(e,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(e){e.sort(function(e,t){return t.position!==e.position?t.position-e.position:e.word.length-t.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hits.length!==t.hits.length?t.hits.length-e.hits.length:e.start-t.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(e){b+="<a href='"+f+'\'><p class="search-result">'+s(p,e)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===t.length&&""===t[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x"></i></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>';else{o.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hitCount!==t.hitCount?t.hitCount-e.hitCount:t.id-e.id});var a='<ul class="search-result-list">';o.forEach(function(e){a+=e.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(e){e.stopPropagation()}),$(document).on("keyup",function(e){var t=27===e.which&&$(".search-popup").is(":visible");t&&onPopupClose()})</script><script src="https://www.gstatic.com/firebasejs/4.6.0/firebase.js"></script><script src="https://www.gstatic.com/firebasejs/4.6.0/firebase-firestore.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/bluebird/3.5.1/bluebird.core.min.js"></script><script>!function(){function getCount(t,e){return t.get().then(function(s){var i;return s.exists?(i=s.data().count,e&&(window.localStorage&&window.localStorage.getItem(title)||(t.set({count:i+1}),i++))):e?(t.set({count:1}),i=1):i=0,window.localStorage&&e&&localStorage.setItem(title,!0),i})}function appendCountTo(t){return function(e){$(t).append($("<span>").addClass("post-visitors-count").append($("<span>").addClass("post-meta-divider").text("|")).append($("<span>").addClass("post-meta-item-icon").append($("<i>").addClass("fa fa-users"))).append($("<span>").text("阅读次数 "+e)))}}firebase.initializeApp({apiKey:"AIzaSyD-BIMnFQcvrv1utthoP5z5shcYP8JMKmY",projectId:"blog-6cbe0"});var db=firebase.firestore(),articles=db.collection("articles"),isPost="".length>0,isArchive=!1,isCategory="".length>0,isTag="".length>0;if(isPost){var title="",doc=articles.doc(title);getCount(doc,!0).then(appendCountTo($(".post-meta")))}else if(!isArchive&&!isCategory&&!isTag){var titles=[],postsstr='titles.push("spring - DI");titles.push("spring - 简介");titles.push("synchronized 和 Lock");titles.push("分布式架构的演化");titles.push("多线程题目");titles.push("锁");titles.push("CompletableFuture");titles.push("NIO、BIO、AIO网络通信");titles.push("java 代理");titles.push("跳台阶");';eval(postsstr);var promises=titles.map(function(t){return articles.doc(t)}).map(function(t){return getCount(t)});Promise.all(promises).then(function(t){var e=$(".post-meta");t.forEach(function(t,s){appendCountTo(e[s])(t)})})}}()</script><style>.pdfobject-container{position:relative;overflow:auto;width:100%}</style><script>$("body").find("div.pdf").length&&$.ajax({type:"GET",url:"//cdn.jsdelivr.net/npm/pdfobject@2.1.1/pdfobject.min.js",dataType:"script",cache:!0,success:function(){$("body").find("div.pdf").each(function(e,t){PDFObject.embed($(t).attr("target"),$(t),{pdfOpenParams:{navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"},PDFJS_URL:"/lib/pdf/web/viewer.html",height:$(t).attr("height")||"500px"})})}})</script><script>$("body").find("pre.mermaid").length&&$.ajax({type:"GET",url:"//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js",dataType:"script",cache:!0,success:function(){mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})}})</script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script><script>pbOptions={},pbOptions.iconStyle="box",pbOptions.boxForm="horizontal",pbOptions.position="bottomCenter",pbOptions.networks="Weibo,Wechat,Douban,QQZone,Twitter,Facebook",new needShareButton("#needsharebutton-postbottom",pbOptions),flOptions={},flOptions.iconStyle="box",flOptions.boxForm="horizontal",flOptions.position="middleRight",flOptions.networks="Weibo,Wechat,Douban,QQZone,Twitter,Facebook",new needShareButton("#needsharebutton-float",flOptions)</script><script src="//cdn.jsdelivr.net/npm/pangu@3/dist/browser/pangu.min.js"></script><script>pangu.spacingPage()</script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@1/bookmark.min.js"></script><script>bookmark.loadBookmark()</script><style>.copy-btn{display:inline-block;padding:6px 12px;font-size:13px;font-weight:700;line-height:20px;color:#333;white-space:nowrap;vertical-align:middle;cursor:pointer;background-color:#eee;background-image:linear-gradient(#fcfcfc,#eee);border:1px solid #d5d5d5;border-radius:3px;user-select:none;outline:0}.highlight-wrap .copy-btn{transition:opacity .3s ease-in-out;opacity:0;padding:2px 6px;position:absolute;right:4px;top:8px}.highlight-wrap .copy-btn:focus,.highlight-wrap:hover .copy-btn{opacity:1}.highlight-wrap{position:relative}</style><script>$(".highlight").each(function(t,e){var n=$("<div>").addClass("highlight-wrap");$(e).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(t){var e=$(this).parent().find(".code").find(".line").map(function(t,e){return $(e).text()}).toArray().join("\n"),n=document.createElement("textarea"),o=window.pageYOffset||document.documentElement.scrollTop;n.style.top=o+"px",n.style.position="absolute",n.style.opacity="0",n.readOnly=!0,n.value=e,document.body.appendChild(n),n.select(),n.setSelectionRange(0,e.length),n.readOnly=!1;var a=document.execCommand("copy");a?$(this).text("复制成功"):$(this).text("复制失败"),n.blur(),$(this).blur()})).on("mouseleave",function(t){var e=$(this).find(".copy-btn");setTimeout(function(){e.text("复制")},300)}).append(e)})</script></body></html><!-- rebuild by neat -->